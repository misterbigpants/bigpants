<HTML>
<HEAD>
<TITLE>You Can Always Go Back</TITLE>
<meta name="viewport" content="minimal-ui, width=device-width, initial-scale=1">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">

<META name="Description" content="You Can Always Go Back" />
<link rel="stylesheet" type='text/css' href="normalize.css">
<SCRIPT Src="jsmin.js"></SCRIPT>
<link rel="manifest" href="index.json" crossorigin="use-credentials">

<SCRIPT>
// https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
const urlParams = new URLSearchParams(window.location.search);

var configCacheBreaker = Math.floor(Math.random() * 10000);
var configDebug = 0;
var configPaid = 0;
var configVersion = "2024-10-15";
var configMouseDisable = false;
var configAnalytics = 1;
</SCRIPT>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7E4FMKR8QT"></script>
<script>
	if (configAnalytics > 0)
	{
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());
		gtag('config', 'G-7E4FMKR8QT');
	}
</script>

<!--
ToDo:
DONE. Check all Frank's levels pass WorldCheck (suspect they don't)

. Check Frank's extra pool doesn't include anything too crazy

. 	Translation: Use Fetch and dump into HTML
	https://stackoverflow.com/questions/70582744/import-html-to-dynamically-add-elements-using-js
	
	Simple MEtrics: Gemini AI for sheets
	https://www.youtube.com/watch?v=FhsPrzOPRhA	
	
	According to Google Gemini, "Gemini for Google Sheets" is not publicly available yet
	(i guess if it exists at all)
-->


<STYLE>
@font-face { font-family:"Lato"; src:url("Lato-Regular.ttf"); font-weight:400; }
@font-face { font-family:"Lato Bold"; src:url("Lato-Bold.ttf"); font-weight:700; }

html { margin:0px; padding:0px;}

body {
	background:#FFFFFF url("") no-repeat;
	overflow:hidden;
	margin:0px; padding:0px;
	font-family:'Lato', Verdana, Geneva, sans-serif; font-style:normal; font-variant:normal; font-weight:400;
	-webkit-touch-callout: none; -webkit-user-select:none; -khtml-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none;
	touch-action:none;
}

#WorldContainer { touch-action:none; margin:0px; padding:0px; position:absolute; left:0px; top:0px; width:100px; height:100px; overflow:hidden;}

a { text-decoration:none; color:#4444ff; font-weight:700; }
a:hover { color:#ff00ff; }

/* <TABLE> tag does not inherit style because I'm in quirks mode, use DIVs for tables */

/* divtable */

.divtable {
  display: table;       
  padding:0px 0px 0px calc(100vw * 0.05);
  width: auto;
  margin:0 auto;
}

.divtable div {
  display: table-row;
  width: auto;
  clear: both;
}

.divtable div div {
  display: table-cell;
  text-align:right;
  padding:0px calc(100vw * 0.05) 0px 0px;
}

/* divtable2 */

.divtable2 {
	display: table;
	padding-left:calc(100vw * 0.05);
	width: auto;
	margin:0 auto;
}

.divtable2 div {
	padding-bottom:3%;
	display: table-row;
	width: auto;
	clear: both;
}

.divtable2 div div {
	display: table-cell;
	text-align:left;
	padding-right:calc(100vw * 0.05);
}

/*
padding-bottom:calc(100vh * 0.035);
  padding:0px calc(100vw * 0.05) 0px 0px;
*/

.Buttons {position:absolute;top:10px;left:10px;width:60px;margin:0px;padding:0px;}
/*
.ButtonClose {margin:0px; padding:0px; border:2px solid white; font-size:20px; width:30px; height:30px; text-align:center;}
*/

@media screen and (max-width:1000px)
{
	// .Buttons {width:150px;}
	// .ButtonClose {margin:0px 0px 40px 0px; font-size:100px;width:150px;height:150px;}
}
</STYLE>


<SCRIPT>
"use strict"; 

function GoogleAnalytics(pExtra)
{
	if (configAnalytics > 0)
	{
		let preface = "You";
		
		if (mWorldMode == 0)
		{
			preface += "-Frank";
		}
		else
		{
			preface += "-" + mUserData.weekday[mWorldDayOfWeek][mWorldEvening].caption;
			if (mWorldEvening == 1) { preface += "-Eve"; } else { preface += "-Day"; } 
		}
		
		gtag('event', preface + "-" + pExtra, {});
	}
}

var mCanvasMain = null;
var mCanvasMainContext = null;
var mWorldClick = null;   // if player clicks page, this has the function to call
var mWorldFrameCounter = 0;   // fixed 60fps frame rate. counts up ever 1/60th of a second
var mWorldFreezeTime = 0;   // all input is ignored until FreezeTime returns to 0


// ------------------------------------------------------------------------------------------------------
// <MISCELLANEOUS>
// ------------------------------------------------------------------------------------------------------
function ButtonUpdate()
{
	if (
		(mButtonCloseDiv.style.display == "")
		&& (mButtonCloseDiv.style.visibility == "")
	)
	{
		if (parseInt(mButtonCloseDiv.style.width) > 50)
		{
			mButtonCloseDiv.style.width = Math.floor(parseInt(mButtonCloseDiv.style.width) * 0.99) + "px";
			if (mButtonCloseDiv.style.width <= 50) { mButtonCloseDiv.style.width = "50px"; }
			mButtonCloseDiv.style.height = mButtonCloseDiv.style.width;
		}
		
		if (mButtonCloseDiv.style.opacity > 0)
		{
			mButtonCloseDiv.style.opacity -= 0.001;
			if (mButtonCloseDiv.style.opacity < 0.01) {  mButtonCloseDiv.style.visibility = "hidden"; }
		}
	}
}

function ButtonChangeState(pState = 0)
{
	// 0:Hide
	if (pState == 0)
	{
		if (mButtonCloseDiv.style.display != "none") { mButtonCloseDiv.style.display = "none"; }
	}
	
	// 1:Show
	else
	{
		if (mButtonCloseDiv.style.display == "none")
		{
			let size = (mWorldWidth < mWorldHeight) ? Math.floor(mWorldWidth * 0.5) : Math.floor(mWorldHeight * 0.5)
			mButtonCloseDiv.style.width = size + "px";
			mButtonCloseDiv.style.height = size + "px";
			mButtonCloseDiv.style.opacity = 1.0;
			mButtonCloseDiv.style.visibility = "";
			mButtonCloseDiv.style.display = "";
		}
	}
}

function GetDayEvening()
{
	// Using current local Date, returns Day & Evening Mantra should use (does NOT change it) 
	let holdDate = new Date();   // Test: "2024-09-09T05:30:00" > local time
	// let holdDate = new Date("Oct 14 2024 20:15:17 GMT-0400");   // Evening
	// let holdDate = new Date("Oct 14 2024 16:15:17 GMT-0400");   // Daytime
	if (holdDate.getHours() < 6) { holdDate.setDate(holdDate.getDate() - 1); }   // it's still yesterday until 6am (life should be like that)
	let holdWorldDayOfWeek = holdDate.getDay();
	let holdWorldDayOfWeekCaptionShort = holdDate.toLocaleDateString(undefined, { weekday: 'short' }); 
	let holdWorldDayOfWeekCaptionLong = holdDate.toLocaleDateString(undefined, { weekday: 'long' });
		
	let holdWorldEvening = 0;
	if (configPaid == 1)
	{
		// we may have switched to evening
		holdWorldEvening = ((holdDate.getHours() >= 18) || (holdDate.getHours() < 6)) ? 1 : 0;   // evening is 6pm to 6am
	}
	
	return [holdWorldDayOfWeek, holdWorldEvening, holdWorldDayOfWeekCaptionShort, holdWorldDayOfWeekCaptionLong];
}

function GetTextSize(pText, pFontSize, pLineHeight = -1)
{
	// https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript
	var returnValue = new Object();
	var test = document.getElementById("TextSize");
	test.innerHTML = pText;
	test.style.fontSize = pFontSize;
	if (pLineHeight == -1) { test.style.lineHeight = "normal"; } else { test.style.lineHeight = pLineHeight; }
	returnValue.height = (test.clientHeight + 1);
	returnValue.width = (test.clientWidth + 1);
	return returnValue;
}

function JimPow(pValue, pExponent)
{
	if (pValue < 0)
	{
		return -Math.pow(-pValue, pExponent);
	}
	else
	{
		return Math.pow(pValue, pExponent);
	}
}

// ------------------------------------------------------------------------------------------------------
// <MENU>
// ------------------------------------------------------------------------------------------------------
function CurtainRefresh(pType)
{
	// pType: 0:remember what it was   1:plaid-overlap   2:wavy-background 
	if (pType != 0) { mWordCurtain.type = pType; }   // remember in case of resize

	mWordCurtain.style.width = mWorldWidth; mWordCurtain.style.height = mWorldHeight;
	let size = mWorldWidth; if (size < 1200) { size = 1200; }
	mWordCurtain.style.backgroundSize = size + "px " + size + "px";		

	// Display Curtain (overlap game)
	if (mWordCurtain.type == 1)
	{
		mWordCurtain.style.backgroundImage = "url('plaid-902419_1280-2.jpg')";		
		mWordCurtain.style.zIndex = "15";
		mWordCurtain.style.display = "";
	}
	// Remove Curtain
	else if (mWordCurtain.type == 2)
	{
		mWordCurtain.style.backgroundImage = ""; // url('wavy-9018344.png')";
		mWordCurtain.style.zIndex = "-1";
		mWordCurtain.style.display = "none";
	}

	// Background Image (might be overlapped by curtain)
	size = mWorldWidth; if (size < 600) { size = 600; }
	document.body.style.backgroundImage = ((mWorldMode > 0) && (mWorldEvening == 1)) ? "url('background-evening.png')" : "url('background-daytime.png')";
	document.body.style.backgroundSize = size + "px " + parseInt(size * (1652.0 / 2714.0)) + "px";			
}

function MenuFrankEnd()
{
	SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundgavel);

	// Player finished "Frank's Story", need to remove "Continue" and offer fresh Start
	mTalkIndex = 0;
	setCookie("TalkIndex", mTalkIndex);
	mStatNewFrankWin = 0;
	setCookie("StatWin", mStatNewFrankWin);
	mStatNewFrankLoss = 0;
	setCookie("StatLoss", mStatNewFrankLoss);			

	let innerHTML = ""
		+ "<DIV Style='padding-bottom:3%'>TO BE<BR>CONTINUED</DIV>"
		+ "<DIV Style='font-size:40%; line-height:100%; textShadow75; color:#FFFFFF;'>"
		+ "THERE'S WAY MORE<BR>"
		+ "TO FRANK'S STORY,<BR>"
		+ "BUT I RAN<BR>"
		+ "OUT OF TIME.<BR>"
		+ "SORRY."
		+ "</DIV>";
	return MenuShow(null, innerHTML, MenuMain);
}

function MenuShow(pEvent, pInnerHTML, pmWorldClick = null, pCurtainImageInnerHTML = "")
{
	// window.setTimeout(WorldResize, 100, 1);
	window.setTimeout(
		function () { MenuShow2(pEvent, pInnerHTML, pmWorldClick, pCurtainImageInnerHTML); }
		, 100
	);

	if (pEvent != null)
	{
		pEvent.preventDefault();
		pEvent.stopPropagation();
	}
	return false;
}

function MenuShow2(pEvent, pInnerHTML, pmWorldClick = null, pCurtainImageInnerHTML = "")
{
	if (configMouseDisable) { try { document.exitPointerLock(); } catch { }; }
	
	mWord.style.display = "";   // "Tale of Frank" turns out lights, which sets mWord.display = "none"
	mWorldState = 0;   // stop game from running
	ButtonChangeState(0);   // code is unable to support menu button when menu is displayed, so hide
	CurtainRefresh(1);

	pInnerHTML = "<DIV Style='margin:0px; padding-left:50px; padding-right:50px;'>" + pInnerHTML + "</DIV>";
	// pInnerHTML = "<DIV Style='margin:0px; padding-left:calc(100vw * 0.1); padding-right:calc(100vw * 0.1);'>" + pInnerHTML + "</DIV>";
	WordShow(pInnerHTML, "", "", 0, 0, 0.0, true);   // my kingdom for named parameters :)
	WordUpdate();

	if (pCurtainImageInnerHTML == "")
	{ 
		mWordCurtainImage.style.display = "none";
	}
	else
	{
		mWordCurtainImage.style.width = mWorldWidth;
		mWordCurtainImage.style.height = mWorldHeight;
		mWordCurtainImage.style.zIndex = 16;
		mWordCurtainImage.innerHTML = pCurtainImageInnerHTML;		
		mWordCurtainImage.style.display = "";
	}

	mWorldClick = pmWorldClick;   // Clicking screen causes this function to be called (transitioning to next screen)
	
	if (pEvent != null)
	{
		pEvent.preventDefault();
		pEvent.stopPropagation();
	}
	return false;
}

function MenuMainResume(pEvent, pWorldState)
{
	// Only called from MainMenu:Resume
	console.assert(pWorldState > 0, "MenuMainResume Error: pWorldState == 0! which means there's no game to resume.");

	mMenuMainPreserveWorldState = 0;

	if (configMouseDisable) { try { document.body.requestPointerLock( {unadjustedMovement: true} ); } catch { } }
	ButtonChangeState(1);
	CurtainRefresh(2);

	mWorldState = pWorldState;
	mWord.aliveRemember = Date.now() - 100000;   // When WorldUpdate/WordUpdate restarts, will put Word into the background
	if (mMusic.currentTime != 0) { mMusic.play(); }
	WorldUpdate();   // start game loop

	if (pEvent != null)
	{
		pEvent.stopPropagation();
		pEvent.preventDefault();
	}
	return false;
}

function MenuMainRestart(pEvent, pWorldMode, pDayOfWeek, pEvening)
{	
	mTalkIndex = -1;   // Tale of FRANK
	
	WorldChange(pWorldMode, pDayOfWeek, pEvening);

	if (configMouseDisable) { try { document.body.requestPointerLock( {unadjustedMovement: true} ); } catch { } }
	ButtonChangeState(1);

	// <RESET>
	mMenuMainPreserveWorldState = 0;
	mWorldLevelCount = -1;
	TalkStop3000();   // Stop interruptions
	TalkStop1();   // Stop narrative
	MusicStop();
	console.assert(mMusic.talkIndex == -1,  "MenuMainRestart Error() Stopped both Talks BUT mMusic.talkIndex != -1 '" + mMusic.talkIndex + "'");

	TalkStatesReset();
	TilesWhite();
	mPlayback.Reset();
	gBrowser.KeyReset();	

	mWeekdayLevelsRemaining = -1;
	mWorldResetNewLevelIndexSpecial = -1;

	// Remove Tiles
	mCanvasMainContext.clearRect(0, 0, mCanvasMain.width, mCanvasMain.height);	
	for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
	{
		mPlayField[xyIndex] = 0;
		mPlayFieldDivs[xyIndex].visualState = 0;
		mPlayFieldDivs[xyIndex].transform.LerpChangeTile(-1000, -1000, 1, 1, 1, 1);
	}
	
	// Remove flag saying Level has been used (marking progress) - applies to both FRANK and WEEKDAY
	// Remember: mLevels MIGHT not be laoded from disk again.
	// Rmemeber: mLevelIndex is USELESS never rely on it.
	if (mLevels != null)
	{
		for (let index = 0; index < mLevels.length; index++) { mLevels[index][3] = 0; }
		mWeekdayLevelsRemaining = mLevels.length;
	}
	
	mWorldWidth = -1; mWorldHeight = -1;
	WorldResize(1);
	
	mStatNewTime = 0;
	mStatNewSteps = 0;
	mStatNewFail = 0;
	// </RESET>

	if (mWorldMode == 1)
	{
		mStatBottomLeftDiv.innerHTML = FormatTime(mStatNewTime);
		mStatBottomRightDiv.innerHTML = mStatNewSteps.toLocaleString();
		MenuDayStart();
	}
	else
	{
		// 7:Bonus   10:Boss   ?:MileStone   49:OneHundred	
		mTalkIndex = parseInt(getCookie("TalkIndex", 0)); 
		const myParam = urlParams.get("talkindex");
		if (myParam != null)
		{
			mTalkIndex = parseInt(myParam);
			setCookie("TalkIndex", mTalkIndex);
			mStatNewFrankWin = mTalkIndex * 20;
			setCookie("StatWin", mStatNewFrankWin);
			mStatNewFrankLoss = 1;
			setCookie("StatLoss", mStatNewFrankLoss);			
		}
		mStatBottomLeftDiv.innerHTML = "Losses:" + mStatNewFrankLoss.toLocaleString();
		mStatBottomRightDiv.innerHTML = "Wins:" + mStatNewFrankWin.toLocaleString();
		TalkRestart();   // Puts world into proper mode (Lights Out, Player disabled, etc.)
		WorldReset(true);   // The Tale of Frank (WorldReset MIGHT call itself over and over to build levels on the fly)
	}

	if (pEvent != null) { pEvent.stopPropagation(); pEvent.preventDefault(); }
	return false;
}


var mMenuMainPreserveWorldState = 0;
function MenuMain(pEvent, pMenuMainPreserveWorldState = -1)
{	
	if ((mWorldState == 2) && (Date.now() > mWorldStateAlive))
	{
		alert("Unable to open menu right now, try again later.");
		return;
	}

	// Can't touch ANYTHING because player might resume
	if (mWeekdayLevelsRemaining != 0) { if (mMusic.currentTime != 0) { mMusic.pause(); } }   // if player finished all 10 levels of Weekday, keep Happy Hollows playing!
	SoundBuffersStop();
	// SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundyoucanalwaysgobacktitle);   // last buffered sound

	// MenuMain can be called while game is playing (mWorldState > 0) or while menus are showing (mWorldState = 0)
	// Need to remember that State
	if (pMenuMainPreserveWorldState != -1)
	{
		// future: if player has completed game (worldstate==2 and (mStatNewFrankLoss + mStatNewFrankWin == mLevels.length), don't offere resume 
		mMenuMainPreserveWorldState = pMenuMainPreserveWorldState;
	}

	let innerHTML = "";
	if (configPaid > 0)
	{
		innerHTML += "<DIV Style='padding-bottom:3%'>YOU CAN<BR><SPAN Style='color:#FFFFFF'>ALWAYS</SPAN><BR>GO BACK</DIV>";
	}
	else
	{
		innerHTML += "<DIV Style='padding-bottom:3%'>YOU CAN<BR><SPAN Style='color:#FFFFFF'>ALWAYS</SPAN><BR>GO BACK</DIV>";	
	}
			
	innerHTML += "<DIV Style='font-size:40%; line-height:100%; textShadow75; color:#FFFFFF;'>"

	// <RESUME>
	// there might be no game to resume
	if (mMenuMainPreserveWorldState == 0)
	{
		innerHTML += "<DIV Style='padding-bottom:6%; color:#909090;'>RESUME</DIV>";
	}
	else
	{
		innerHTML += "<DIV Style='padding-bottom:6%'><SPAN Style='cursor:pointer;' " + gBrowser.inputTypeEventHTML + "='MenuMainResume(event, " + mMenuMainPreserveWorldState + ");'>RESUME</SPAN></DIV>";
	}
	// </RESUME>

	// <DATE>
	// mWorldDayOfWeek and mWorldEvening contain current Mantra, BUT hours may have passed and that needs to change
	// do NOT change mWorldDayOfWeek/mWorldEvening until player clicks "Restart Mantra", because they might resume their game
	let holdDayEvening = GetDayEvening();
	let holdWorldDayOfWeek = holdDayEvening[0];
	let holdWorldEvening = holdDayEvening[1]; if (configPaid == 0) { holdWorldEvening = 0; }
	let holdWorldDayOfWeekCaptionShort = holdDayEvening[2].toUpperCase();
	let holdWorldDayOfWeekCaptionLong = holdDayEvening[3].toUpperCase();
	// </DATE>

	let eveningCaption = ((configPaid == 1) && (holdWorldEvening == 1)) ? " EVENING" : "";


	// <RESTART MANTRA>
	{
		let holdHTML = holdWorldDayOfWeekCaptionLong + eveningCaption;
				
		// things may have changed so (if chosen) Mantra is going to be different			
		if ((holdWorldDayOfWeek != mWorldDayOfWeek) || (holdWorldEvening != mWorldEvening))
		{
			holdHTML = "START " + holdHTML;
			// holdHTML = "*NEW* " + holdHTML;
		}
		else if (mMenuMainPreserveWorldState == 0)
		{
			// we finished the Day, and can start again
			holdHTML = "START " + holdHTML;
		}
		else
		{
			// we're in the middle fo the day
			holdHTML = "RESTART " + holdHTML;
		}
		holdHTML = "<SPAN Style='color:#FFFF00'>" + holdHTML + "</SPAN>";
		
		innerHTML += "<DIV Style='padding-bottom:3%'>"
			+ "<SPAN Style='cursor:pointer;' " + gBrowser.inputTypeEventHTML + "='MenuMainRestart(event, 1, " + holdWorldDayOfWeek + "," + holdWorldEvening + ");'>"
			+ holdHTML
			+ "</SPAN>"
			+ "</DIV>";
	}
	// </RESTART MANTRA>

	// <WEEKDAY>
	innerHTML += "<DIV Style='padding-bottom:3%; color:#FFFF00;'>"
		+ "<SPAN Style='cursor:pointer;' " + gBrowser.inputTypeEventHTML + "='MenuChallenges(event, 0);'>"
		+ "WEEKDAY" + eveningCaption + " STATS"
		+ "</SPAN>"
		+ "</DIV>";
	// </WEEKDAY>

	// <CHALLENGES>
	innerHTML += "<DIV Style='padding-bottom:6%; color:#FFFF00;'>"
		+ "<SPAN Style='cursor:pointer;' " + gBrowser.inputTypeEventHTML + "='MenuChallenges(event, 1);'>"
		+ eveningCaption + " CHALLENGES"
		+ "</SPAN>"
		+ "</DIV>";
	// </CHALLENGES>

	// innerHTML += "<DIV Style='padding-bottom:3%; color:#909090;'>BEGIN \"THE CLIMB\"</DIV>";
	// innerHTML += "<DIV Style='padding-bottom:3%; color:#909090;'>BEGIN \"GRATUITOUS\"</DIV>";

	if (true)
	// if (configPaid > 0)
	{
		let hold = (mStatNewFrankLoss + mStatNewFrankWin == 0) ? "BEGIN": "CONTINUE";
		innerHTML += "<DIV Style='padding-bottom:3%;'><SPAN Style='cursor:pointer;' " + gBrowser.inputTypeEventHTML + "='MenuMainRestart(event, 0, " + holdWorldDayOfWeek + "," + holdWorldEvening + ");'>" + hold + " \"FRANK'S STORY\"</SPAN></DIV>";   // CONTINUE / REPLAY
	}
	innerHTML += "<DIV Style='padding-bottom:3%;'><SPAN Style='cursor:pointer;' " + gBrowser.inputTypeEventHTML + "='MenuAbout(event);'>ABOUT HAROLD</SPAN></DIV>";
	innerHTML += "<DIV Style='padding-bottom:6%;'><SPAN Style='cursor:pointer;' " + gBrowser.inputTypeEventHTML + "='MenuCredits(event);'>CREDITS</SPAN></DIV>";

	innerHTML += "<DIV Style='padding-bottom:6%;'><SPAN Style='cursor:pointer;' " + gBrowser.inputTypeEventHTML + "='MenuQuit(event);'>QUIT</SPAN></DIV>";
	
	innerHTML += "</DIV>";

	return MenuShow(pEvent, innerHTML);
}

function MenuQuit(pEvent)
{
	try
	{
		nw.App.quit();   // if running as an app (started by nw.exe), nw will be an object
		return;
	}
	catch { }

	let innerHTML = ""
		+ "<DIV Style='padding-bottom:3%'>I KNEW<BR>YOU'D QUIT<BR></DIV>"
		+ "<DIV Style='font-size:40%; line-height:100%; textShadow75; color:#FFFFFF;'>"
		+ "YOU'VE QUIT EVERYTHING<BR>"
		+ "YOU'VE EVER STARTED."
		+ "</DIV>";
	return MenuShow(pEvent, innerHTML);
}

function MenuFinalLevelFailed()
{
	SoundBuffersStop();
	SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundyoublewit);   // last buffered sound
	let innerHTML = "YOU<BR><SPAN Style='color:#FFFFFFFF'>BLEW</SPAN><BR>IT";
	GoogleAnalytics("Completed-Fail");	
	return MenuShow(null, innerHTML, MenuMain);
}

function MenuFinalLevelYes(pEvent)
{
	mWorldClick = null;
	WorldResetNew();
	if (pEvent != null)
	{
		pEvent.stopPropagation();
		pEvent.preventDefault();
	}
	return false;
}

function MenuFinalLevelNo(pEvent)
{
	let innerHTML = ""
		+ "<DIV Style='padding-bottom:3%'>IF YOU FAIL<BR>ONCE,<BR>YOU'LL LOSE<BR>EVERYTHING.<BR></DIV>"
		+ "<DIV Style='font-size:40%; line-height:100%; textShadow75; color:#FFFFFF;'>"
		+ "MEANING ALL PROGRESS WILL BE DELETED<BR>"
		+ "I THOUGHT THAT WAS PRETTY CLEAR"
		+ "</DIV>";
	// ISN'T IT THRILLING?
	return MenuShow(pEvent, innerHTML, WorldResetNew);
}

function MenuFinalLevel(pEvent)
{
	MusicSelect();
	let innerHTML = ""
		+ "<DIV Style='padding-bottom:3%'>FINAL LEVEL</DIV>"
		+ "<DIV Style='font-size:40%; line-height:100%; textShadow75; color:#FFFFFF;'>"
			+ "YOU'VE WORKED INCREDIBLY HARD<BR>"
			+ "YOUR REWARD IS WITHIN REACH<BR>"
			+ "NOTE: IF YOU FAIL ONCE,<BR>"
			+ "YOU LOSE EVERYTHING<BR>"
			+ "<BR>"
			+ "DO YOU UNDERSTAND?<BR>"
			+ "<DIV>"
				+ "<SPAN Style='cursor:pointer;color:#FFFF00;' " + gBrowser.inputTypeEventHTML + "='MenuFinalLevelYes(event);'>YES</SPAN>"
				+ " &nbsp;&nbsp;&nbsp;"
				+ " <SPAN Style='cursor:pointer;' " + gBrowser.inputTypeEventHTML + "='MenuFinalLevelNo(event);'>NO</SPAN>"
			+ "</DIV>"
		+ "</DIV>";
	return MenuShow(pEvent, innerHTML, MenuFinalLevelYes);
}

function MenuFinished(pEvent)
{
	// Don't stop Sound or Music, keep Happy Hollows GOING!
		
	// FIRST - first time completing "the bar has been set"
	// YAWN/FAIL - you were worse in every category
	// PROGRESS/CONGRATS

	// <MESSAGE>
	let innerHTML = "";
	if (mUserData.weekday[mWorldDayOfWeek][mWorldEvening].steps == -1)
	{
		// all the userdata -1 values will be updated
		innerHTML = ""
			+ "<DIV Style='color:#FFFF00FF;padding-bottom:3%;'>THE <SPAN Style='color:#FFFFFFFF;'>BAR</SPAN><BR><SPAN Style='color:#FFFFFFFF;'>IS</SPAN> SET</DIV>"
			+ "<DIV Style='color:#FFFFFFFF; font-size:40%; line-height:100%; textShadow75;'><DIV Class='divtable2'>"
			+ "<DIV><DIV>STEPS</DIV><DIV>" + mStatNewSteps.toLocaleString() + "</DIV></DIV>"
			+ "<DIV><DIV>TIME</DIV><DIV>" + FormatTime(mStatNewTime) + "</DIV></DIV>"
			+ "<DIV><DIV>FAILED</DIV><DIV>" + mStatNewFail.toLocaleString() + "</DIV></DIV>"
			+ "</DIV></DIV>";
	}
	else
	{
		let stepHTML = "";
		stepHTML += "<DIV>";
			if (mStatNewSteps < mUserData.weekday[mWorldDayOfWeek][mWorldEvening].steps)
			{
				stepHTML += "<DIV>&#128513</DIV><DIV Style='color:#FFFF00FF;'>LESS STEPS!</DIV>";
			}
			else if (mStatNewSteps > mUserData.weekday[mWorldDayOfWeek][mWorldEvening].steps)
			{
				stepHTML += "<DIV>&#128546</DIV><DIV>more steps</DIV>";
			}
			else
			{
				stepHTML += "<DIV>&#128529</DIV><DIV>same steps</DIV>";
			}
			stepHTML += "<DIV>" + mStatNewSteps.toLocaleString() + "</DIV><DIV Style='color:909090;'>" + mUserData.weekday[mWorldDayOfWeek][mWorldEvening].steps.toLocaleString() + "</DIV>"
		stepHTML += "</DIV>";
		
		let timeHTML = "";
		timeHTML += "<DIV>";
			if (mStatNewTime < mUserData.weekday[mWorldDayOfWeek][mWorldEvening].time)
			{
				timeHTML += "<DIV>&#128513</DIV><DIV Style='color:#FFFF00FF;'>LESS TIME!</DIV>";
			}
			else if (mStatNewTime > mUserData.weekday[mWorldDayOfWeek][mWorldEvening].time)
			{
				timeHTML += "<DIV>&#128546</DIV><DIV>more time</DIV>";
			}
			else
			{
				timeHTML += "<DIV>&#128562</DIV><DIV Style='color:#FFFF00FF;'>SAME TIME!</DIV>";
			}
			timeHTML += "<DIV>" + FormatTime(mStatNewTime) + "</DIV><DIV Style='color:909090;'>" + FormatTime(mUserData.weekday[mWorldDayOfWeek][mWorldEvening].time) + "</DIV>"
		timeHTML += "</DIV>";

		let failHTML = "";
		failHTML += "<DIV>";
			if (mStatNewFail < mUserData.weekday[mWorldDayOfWeek][mWorldEvening].fail)
			{
				failHTML += "<DIV>&#128513</DIV><DIV Style='color:#FFFF00FF;'>LESS FAILS!</DIV>";
			}
			else if (mStatNewFail > mUserData.weekday[mWorldDayOfWeek][mWorldEvening].fail)
			{
				failHTML += "<DIV>&#128546</DIV><DIV>more fails</DIV>";
			}
			else
			{
				failHTML += "<DIV>&#128529</DIV><DIV>same fails</DIV>";
			}
			failHTML += "<DIV>" + mStatNewFail.toLocaleString() + "</DIV><DIV Style='color:909090;'>" + mUserData.weekday[mWorldDayOfWeek][mWorldEvening].fail.toLocaleString() + "</DIV>"
		failHTML += "</DIV>";

		let titleHTML = "";
		titleHTML += ""
		if (
			(mStatNewSteps < mUserData.weekday[mWorldDayOfWeek][mWorldEvening].steps)
			|| (mStatNewTime < mUserData.weekday[mWorldDayOfWeek][mWorldEvening].time)
			|| (mStatNewFail < mUserData.weekday[mWorldDayOfWeek][mWorldEvening].fail)
		)
		{
			titleHTML += "<DIV Style='color:#FFFF00FF;padding-bottom:3%;'>SUCCESS!</DIV>";
		}
		else if (
			(mStatNewSteps == mUserData.weekday[mWorldDayOfWeek][mWorldEvening].steps)
			&& (mStatNewTime == mUserData.weekday[mWorldDayOfWeek][mWorldEvening].time)
			&& (mStatNewFail == mUserData.weekday[mWorldDayOfWeek][mWorldEvening].fail)
		)
		{
			titleHTML += "<DIV Style='color:#FFFF00FF;padding-bottom:3%;'><SPAN Style='color:#FFFFFFFF;'>A PERFECT</SPAN><BR>MATCH</DIV>";
		}
		else
		{
			titleHTML += "<DIV Style='padding-bottom:3%;'><SPAN Style='color:#FFFFFFFF;'>success yet</SPAN><BR><SPAN Style='color:#FF0000FF;'>failure</SPAN></DIV>";
		}
		
		innerHTML = titleHTML
			+ "<DIV Style='color:#FFFFFFFF; font-size:40%; line-height:100%; textShadow75;'><DIV Class='divtable2'>"
			+ stepHTML
			+ timeHTML
			+ failHTML
			+ "</DIV></DIV>";
	}
	// </MESSAGE>

	// <SAVE>
	let save = false;
	let stepsValue = mUserData.weekday[mWorldDayOfWeek][mWorldEvening].steps;
	if ((stepsValue == -1) || (mStatNewSteps < stepsValue)) { stepsValue = mStatNewSteps; save = true; }
	mStatNewSteps = 0;

	let timeValue = mUserData.weekday[mWorldDayOfWeek][mWorldEvening].time;
	if ((timeValue == -1) || (mStatNewTime < timeValue)) { timeValue = mStatNewTime; save = true; }
	mStatNewTime = 0;

	let failValue = mUserData.weekday[mWorldDayOfWeek][mWorldEvening].fail;
	if ((failValue == -1) || (mStatNewFail < failValue)) { failValue = mStatNewFail; save = true; }
	mStatNewFail = 0;

	if (save) { mUserData.SaveCurrentDay(stepsValue, timeValue, failValue); }
	// </SAVE>

	GoogleAnalytics("Completed-Success");

	return MenuShow(pEvent, innerHTML, MenuMain);
}

function MenuChallenges(pEvent, pSet = 0, pToggle = false)
{
	let holdDayEvening = GetDayEvening();
	if (configPaid == 0) { holdDayEvening[1] = 0; }
	let pWorldEvening = holdDayEvening[1];

	if (pToggle)
	{	
		if (pWorldEvening > 0) { pWorldEvening = 0; } else { pWorldEvening = 1; }
	}

	// <TITLE>
	// pSet = 0: Weekdays   1:Challenge1
	let innerHTML = "";
		
	innerHTML += "<DIV Style='text-align:center; font-size:50%; line-height:100%; textShadow75; padding-bottom:3%; cursor:pointer; color:#FFFF00FF;'>"
	if (configDebug > 0)
	{
		if (pSet == 0) { innerHTML += "WEEKDAY"; } else { innerHTML += "CHALLENGES"; }
		if (pWorldEvening == 1) { innerHTML += " EVENING"; } else { innerHTML += " DAYTIME"; }
		innerHTML += "<BR>DEBUG CHOOSE";
	}
	else if ((configPaid > 0) && (pWorldEvening == 1))
	{
		if (pSet == 0) { innerHTML += "WEEKDAY EVENING<BR>STATS"; } else { innerHTML += "EVENING<BR>CHALLENGES"; }
	}
	else
	{
		if (pSet == 0) { innerHTML += "WEEKDAY STATS"; } else { innerHTML += "CHALLENGES"; }
	}	
	innerHTML += "</DIV>";
	// </TITLE>

	// <TOTAL>
	let success = true;
	let totalSteps = 0, totalTime = 0, totalFail = 0;
	for (let index = pSet * 7; index < pSet * 7 + 7; index++)
	{
		if (mUserData.weekday[index][pWorldEvening].steps == -1)
		{
			success = false;
		}
		else
		{
			if (mUserData.weekday[index][pWorldEvening].steps > 0) { totalSteps += mUserData.weekday[index][pWorldEvening].steps; }
			if (mUserData.weekday[index][pWorldEvening].time > 0) { totalTime += mUserData.weekday[index][pWorldEvening].time; }
			if (mUserData.weekday[index][pWorldEvening].fail > 0) { totalFail += mUserData.weekday[index][pWorldEvening].fail; }
		}
	}

	if (success)
	{
		innerHTML += "<DIV Style='padding-bottom:3%; color:#FFFF00FF; text-align:center;'>"
			+ totalSteps.toLocaleString()
			+ " &nbsp; " + FormatTime(totalTime)
			+ " &nbsp; " + totalFail.toLocaleString()
			+ "</DIV>";
	}
	// </TOTAL>

	// <DAYS>
	innerHTML += "<DIV Style='font-size:40%; line-height:100%; textShadow75;'><DIV Class='divtable2'>";
	for (let index = pSet * 7; index < pSet * 7 + 7; index++)
	{
		// Players CAN'T click Weekdays, they CAN click Challenges
		if ((pSet == 0) && (configDebug == 0))
		{
			innerHTML += "<DIV Style='color:#FFFFFFFF;'>"
		}
		else
		{
			innerHTML += "<DIV Style='color:#FFFFFFFF;cursor:pointer;'"
				+ " " + gBrowser.inputTypeEventHTML + "='MenuMainRestart(event, 1, " + index + ", " + pWorldEvening + ");'"
				+ " >";
		}
		
		innerHTML += "<DIV>" + mUserData.weekday[index][pWorldEvening].caption.toUpperCase() + "</DIV>";
		
			if (mUserData.weekday[index][pWorldEvening].steps == -1)
			{
				innerHTML += "<DIV>-</DIV><DIV>-</DIV><DIV>-</DIV>";
			}
			else
			{
				innerHTML += "<DIV>" + mUserData.weekday[index][pWorldEvening].steps.toLocaleString() + "</DIV>"
					+ "<DIV>" + FormatTime(mUserData.weekday[index][pWorldEvening].time) + "</DIV>"
					+ "<DIV>" + mUserData.weekday[index][pWorldEvening].fail.toLocaleString() + "</DIV>";
			}
		
		innerHTML += "</DIV>"
	}
	innerHTML += "</DIV></DIV>";   // Extra BRs to provide some padding
	// </DAYS>

	if ((!pToggle) && (configDebug > 0))
	{
		return MenuShow(pEvent, innerHTML, function () { MenuChallenges(null, pSet, true); } );	
	}
	else
	{
		return MenuShow(pEvent, innerHTML, MenuMain);
	}
}

function MenuWeekdayInvisible()
{
	let innerHTML = ""
		+ "<DIV Style='padding-bottom:3%'>TILES <SPAN Style='color:#FFFFFF;'>BE</SPAN><BR>BOKEN</DIV>"
		+ "<DIV Style='font-size:40%; line-height:100%; textShadow75; color:#FFFFFF;'>"
		+ ""
		+ "<DIV Style='padding-bottom:3%'>"
		+ "3 TILES HAVE BURNT OUT.<BR>"
		+ "FIND THEM.<BR>"
		+ "SUCKLE THEM."
		+ "</DIV>"
		+ ""
		+ "</DIV>";
	return MenuShow(null, innerHTML, WorldResetFinish);
}

function MenuWeekdayRandomFail()
{
	let innerHTML = ""
		+ "<DIV Style='padding-bottom:3%'>FAIL<SPAN Style='color:#FFFFFF;'>'</SPAN>S<BR>BROKEN</DIV>"
		+ "<DIV Style='font-size:40%; line-height:100%; textShadow75; color:#FFFFFF;'>"
		+ ""
		+ "<DIV Style='padding-bottom:3%'>"
		+ "SOMETIMES FAIL WILL TRIGGER<BR>"
		+ "WHEN EVERYTHING IS FINE<BR>"
		+ "CAUSING MASSIVE<BR>"
		+ "TRUST ISSUES"
		+ "</DIV>"
		+ ""
		+ "</DIV>";
	return MenuShow(null, innerHTML, WorldResetFinish);
}

function MenuWeekdayFinishTile()
{
	let innerHTML = ""
		+ "<DIV Style='padding-bottom:3%'>FINAL <SPAN Style='color:#FFFFFF;'>TILE</SPAN><BR>ALERT</DIV>"
		+ "<DIV Style='font-size:40%; line-height:100%; textShadow75; color:#FFFFFF;'>"
		+ ""
		+ "<DIV Style='padding-bottom:3%'>"
		+ "YOU MUST FINISH<BR>"
		+ "ON THE THAT FINAL<BR>"
		+ "PULSATING TILE.<BR>"
		+ "OTHERWISE,<BR>"
		+ "BLUH."
		+ "</DIV>"
		+ ""
		+ "</DIV>";
	return MenuShow(null, innerHTML, WorldResetFinish);
}

function MenuWeekdayExtraTile()
{
	// to keep you guessing?
	let innerHTML = ""
		+ "<DIV Style='padding-bottom:3%'>EXTRA <SPAN Style='color:#FFFFFF;'>TILE</SPAN><BR>ALERT</DIV>"
		+ "<DIV Style='font-size:40%; line-height:100%; textShadow75; color:#FFFFFF;'>"
		+ ""
		+ "<DIV Style='padding-bottom:3%'>"
		+ "ADDED AN EXTRA TILE.<BR>"
		+ "DON'T TOUCH IT.<BR>"
		+ "IT'S DEADLY.<BR>"
		+ "SERIOUSLY,<BR>"
		+ "DON'T TOUCH IT."
		+ "</DIV>"
		+ ""
		+ "</DIV>";
	return MenuShow(null, innerHTML, WorldResetFinish);
}

function MenuCredits(pEvent)
{
	let innerHTML = "<DIV Style='padding-bottom:3%'>BIGPANTS</DIV>";
	
	innerHTML += "<DIV Style='font-size:40%; line-height:100%; textShadow75; color:#FFFFFF;'>";
	
		innerHTML += "<DIV Style='padding-bottom:3%'>"
			+ "A COMPANY CLOSE TO YOUR HEART<BR>"
			+ "A COMPANY CLOSE TO YOUR BUM<BR>"
			+ "WE MAKE GAMES FOR YOU<BR>"
			+ "YOU PAY US MONEY"
			+ "</DIV>"
			+ ""
			
		innerHTML += "<DIV Style='padding-bottom:3%; color:#909090;'>VERSION: " + configVersion;
		if (configPaid == 0) { innerHTML += " FREE"; } else { innerHTML += " $PAID$"; }
		if (configDebug != 0) { innerHTML += " *DEBUG*"; }
		innerHTML += "</DIV>";
	
	innerHTML += "</DIV>";
	
	return MenuShow(pEvent, innerHTML, MenuMain);
}

function MenuAbout(pEvent)
{
	let extraHTML = (configPaid == 1) ? " <SPAN Style='font-size:40%;'>1 of 2</SPAN>" : "";

	// and wishes he were dead
	// and wishes he didn't
	// and thinks dark thoughts
	// and cries uncontrollably
	// CRIES UNCONTROLLABLY
	/*
	mPlayer.transform.LerpChange(
		Math.floor(mWorldWidth * 0.5), Math.floor(mWorldHeight * 0.5), 1
		, Math.floor(mWorldWidth * 0.5), Math.floor(mWorldWidth * 0.5), 1
	);
	*/
		
	// he'd end it all > he'd change things
	let innerHTML = ""
		+ "<DIV Style='padding-bottom:3%'>HAROLD" + extraHTML + "</DIV>"
		+ "<DIV Style='font-size:40%; line-height:100%; textShadow75; color:#FFFFFF;'>"
		+ ""
		+ "<DIV Style='padding-bottom:3%'>"
		+ "EVERYDAY <SPAN Style='color:#FFFF00'>HAROLD</SPAN> WAKES UP<BR>"
		+ "AND WISHES HE WERE DEAD.<BR>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> HAD PANCAKES FOR BREAKFAST."
		+ "</DIV>"
		+ ""
		+ "<DIV Style='padding-bottom:3%'>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> ONCE SAW A MAN DROWNING.<BR>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> CANNOT SWIM.<BR>"
		+ "HE WAVED, THEN FELT STUPID.<BR>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> OWNS 3 PAIRS OF SOCKS."
		+ "</DIV>"
		+ ""
		+ "<DIV Style='padding-bottom:3%'>"
		+ "A YOUNG BOY ONCE SPOTTED <SPAN Style='color:#FFFF00'>HAROLD</SPAN>.<BR>"
		+ "HE POINTED, THEN SCREAMED 'PATHETIC!'<BR>"
		+ "YEARS LATER, <SPAN Style='color:#FFFF00'>HAROLD</SPAN> REALIZED<BR>"
		+ "HE HAD GONE BACK IN TIME."
		+ "</DIV>"
		+ ""
		+ "<DIV Style='padding-bottom:3%'>"
		+ "MORE THAN ANYTHING,<BR>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> HATES HIS JOB<BR>"
		+ "IF HE WEREN'T SUCH A COWARD,<BR>"
		+ "HE'D END IT ALL.<BR>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> LIKES PIZZA."
		+ "</DIV>"
		+ ""
		+ "</DIV>";
		
	let imageSize = (mWorldHeight < mWorldWidth) ? Math.floor(mWorldHeight) : Math.floor(mWorldWidth);
	let pictureInnerHTML = "<IMG Src='myface-01-normal.png' Style='"
		+ "position:absolute;"
		+ "left:" + (Math.floor((mWorldWidth - imageSize) * 0.5) - Math.floor(imageSize * 0.5)) + "px;"
		+ "top:" + (Math.floor((mWorldHeight - imageSize) * 0.5) + Math.floor(imageSize * 0.3)) + "px;"
		+ "width:" + imageSize + "px;"
		+ "height:" + imageSize + "px;"
		+ "opacity:0.4;"
	+ "'>";
		
	if (configPaid == 1)
	{
		return MenuShow(pEvent, innerHTML, MenuAbout2, pictureInnerHTML);
	}
	else
	{
		return MenuShow(pEvent, innerHTML, MenuMain, pictureInnerHTML);
	}
}

function MenuAbout2(pEvent)
{
	let innerHTML = ""
		+ "<DIV Style='padding-bottom:3%'>HAROLD <SPAN Style='font-size:40%;'>2 of 2</SPAN></DIV>"
		+ "<DIV Style='font-size:40%; line-height:100%; textShadow75; color:#FFFFFF;'>"
		+ ""
		+ "<DIV Style='padding-bottom:3%'>"
		+ "BUT THAT WAS 10 YEARS AGO<BR>"
		+ "WHEN IT SUDDENLY HIT <SPAN Style='color:#FFFF00'>HAROLD</SPAN>,<BR>"
		+ "\"THIS MIGHT BE ALL THERE IS\"<BR>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> EMBRACED TODAY,<BR>"
		+ "LIKE A RABID DOG."
		+ "</DIV>"
		+ ""
		+ "<DIV Style='padding-bottom:3%'>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> ASKED THAT GIRL OUT.<BR>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> MADE HER LAUGH.<BR>"
		+ "THEY GOT MARRIED.<BR>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> WAS INCREDIBLE IN BED."
		+ "</DIV>"
		+ ""
		+ "<DIV Style='padding-bottom:3%'>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN>'S 9 YEAR OLD DAUGHTER<BR>"
		+ "WAS SMART AND BUILT LIKE A TANK.<BR>"
		+ "\"I LOVE YOU <SPAN Style='color:#FFFF00'>HAROLD</SPAN>\"<BR>"
		+ "\"DO YOU LIKE MY PANCAKES?\"<BR>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> SMILED.<BR>"
		+ "HE LOVED THAT TANK."
		+ "</DIV>"
		+ ""
		+ "</DIV>";

	let imageSize = (mWorldHeight < mWorldWidth) ? Math.floor(mWorldHeight) : Math.floor(mWorldWidth);
	let pictureInnerHTML = "<IMG Src='myface-04-success.png' Style='"
		+ "position:absolute;"
		+ "left:" + (Math.floor((mWorldWidth - imageSize) * 0.5) - Math.floor(imageSize * 0.5)) + "px;"
		+ "top:" + (Math.floor((mWorldHeight - imageSize) * 0.5) + Math.floor(imageSize * 0.3)) + "px;"
		+ "width:" + imageSize + "px;"
		+ "height:" + imageSize + "px;"
		+ "opacity:0.4;"
	+ "'>";

	return MenuShow(pEvent, innerHTML, MenuMain, pictureInnerHTML);

		/*
		+ ""
		+ "<DIV Style='padding-bottom:3%'>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> DEMANDED A RAISE<BR>"
		+ "AND COMPLETE AUTONOMY.<BR>"
		+ "<SPAN Style='color:#FFFF00'>HAROLD</SPAN> GOT NEITHER,<BR>"
		+ "THEN EMBEZZLED MILLIONS."
		+ "</DIV>"
		*/

}

function MenuInstructions(pEvent)
{	
	let innerHTML = "";
	innerHTML += "<DIV Style='padding:0px 0px 3% 0px;'>CLEAR<BR><SPAN Style='color:#FFFFFFFF;'>IT</SPAN> ALL</DIV>";
	switch (gBrowser.inputType)
	{
		case 999:   // 1 they likely clicke on mouse to get here, but don't want them playing with a mout
		{
			innerHTML += "<DIV Style='font-size:40%;line-height:100%;textShadow75;'><DIV Class='divtable2'>"
				+ "<DIV><DIV Style='color:#FFFFFFFF;'>DRAG</DIV><DIV>MOVE</DIV></DIV>"
				+ "<DIV><DIV Style='color:#FFFFFFFF;'>CLICK</DIV><DIV>INSTANT MOVE</DIV></DIV>"
				+ "</DIV></DIV>";
			break;
		}	
		case 2:
		{
			innerHTML += "<DIV Style='font-size:40%;line-height:100%;textShadow75;'><DIV Class='divtable2'>"
				+ "<DIV><DIV Style='color:#FFFFFFFF;'>SWIPE</DIV><DIV>MOVE</DIV></DIV>"
				+ "<DIV><DIV Style='color:#FFFFFFFF;'>HOLD SWIPE</DIV><DIV>INSTANT MOVE<BR>(KEEP HOLDING)</DIV></DIV>"
				+ "<DIV><DIV Style='color:#FFFFFFFF;'>TAP</DIV><DIV>CORNER</DIV></DIV>"
				+ "</DIV></DIV>";
			break;
		}
		default:
		{
			innerHTML += "<DIV Style='font-size:40%;line-height:100%;textShadow75;'><DIV Class='divtable2'>"
				+ "<DIV><DIV Style='color:#FFFFFFFF;'>ARROW KEYS</DIV><DIV>MOVE</DIV></DIV>"
				+ "<DIV><DIV Style='color:#FFFFFFFF;'>SHIFT + ARROW</DIV><DIV>INSTANT MOVE</DIV></DIV>"
				+ "<DIV><DIV Style='color:#FFFFFFFF;'>SPACEBAR</DIV><DIV>CORNER</DIV></DIV>"
				+ "</DIV></DIV>";
			break;
		}
	}

	return MenuShow(pEvent, innerHTML, WorldResetNew);
}

function MenuDayStart()
{
	// Assumptions
	// mWorldMode == 1, mWorldDayOfWeek and mWorldEvening have been set
	// Called by "START" and by "MenuMain:Restart Mantra"

	/*
	// https://dobrian.github.io/cmp/topics/sample-recording-and-playback-with-web-audio-api/1.loading-and-playing-sound-files.html
	// synchronous (regular soundbuffer is asynchronous)
	var filename = "sound-thanks.mp3";
	if (Math.random() > 0.5) { filename = "sound-title" + (1 + parseInt(Math.random() * 8)) + ".mp3" }	
	const titleaudio = new Audio(filename);
	const source = mAudioContext.createMediaElementSource(titleaudio);   // player hit spacebar, mAudioContext is ready (has resumed)
	source.connect(mAudioContext.destination);
	titleaudio.play();	

	// "Thanks" is the first sound buffered [0]. Started in OnLoad BUT it might not be here yet
	var thanks = mAudioContext.createBufferSource();
	thanks.connect(mAudioContext.destination);
	if (mSoundBufferMisc[0] != null)
	{	
		try
		{
			thanks.buffer = mSoundBufferMisc[0];
			thanks.start(0);
		}
		catch(err)
		{
			console.log("no thanks");
		}
	}
	*/

	SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundgavel);   // last buffered sound

	let innerHTML = "";

	innerHTML += "<DIV Style='color:#FFFF00FF;padding-bottom:3%;'>"
		+ mUserData.weekday[mWorldDayOfWeek][mWorldEvening].captionLong.toUpperCase().replace("DAY", "<SPAN Style='color:#FFFFFFFF;'>DAY</SPAN>")
	innerHTML += (mWorldEvening > 0) ? "<BR><SPAN Style='color:#FFFFFFFF;'>EVE</SPAN>NING" : "";
	innerHTML += "</DIV>";

	if (mUserData.weekday[mWorldDayOfWeek][mWorldEvening].steps == -1)
	{
		innerHTML += "<DIV Style='color:#FFFFFFFF;font-size:40%;line-height:100%;textShadow50;'>FIRST <SPAN Style='color:#FFFF00FF;'>TIME</SPAN>!</DIV>";
	}
	else
	{
		let steps = (mUserData.weekday[mWorldDayOfWeek][mWorldEvening].steps == -1) ? "-" : mUserData.weekday[mWorldDayOfWeek][mWorldEvening].steps.toLocaleString();
		let time = (mUserData.weekday[mWorldDayOfWeek][mWorldEvening].time == -1) ? "-" : FormatTime(mUserData.weekday[mWorldDayOfWeek][mWorldEvening].time);
		let fail = (mUserData.weekday[mWorldDayOfWeek][mWorldEvening].fail == -1) ? "-" : mUserData.weekday[mWorldDayOfWeek][mWorldEvening].fail.toLocaleString();

		innerHTML += "<DIV Style='color:#FFFFFFFF;font-size:40%;line-height:100%;textShadow50;'><DIV Class='divtable2'>"
			+ "<DIV><DIV>STEPS</DIV><DIV Style='color:#FFFF00FF;'>" + steps + "</DIV></DIV>"
			+ "<DIV><DIV>TIME</DIV><DIV Style='color:#FFFF00FF;'>" + time + "</DIV></DIV>"
			+ "<DIV><DIV>FAILS</DIV><DIV Style='color:#FFFF00FF;'>" + fail + "</DIV></DIV>"
			+ "</DIV></DIV>";
	}
	
	let hold = mUserData.weekday[mWorldDayOfWeek][mWorldEvening].captionLong;
	hold += (mWorldEvening == 1) ? " Evening" : " Daytime";
	// create a new `Date` object
	const now = new Date();
	console.log(hold + " Started " + now.toLocaleString());
	
	return MenuShow(null, innerHTML, MenuInstructions);
}


// ------------------------------------------------------------------------------------------------------
// <USERDATA>
// stores score for both Challenges and Weekday (a specialized challenge)
// ------------------------------------------------------------------------------------------------------
function UserData()
{
	// Used when playing Weekdays (not Narrative)
	this.weekday = [];
		
	this.LoadAllDays = function()
	{		
		// MUST ONLY BE CALLED BY WorldChange. mWorldEvening MUST stay in sync with SaveCurrentDay
		// otherwise could play Daytime and save Evening
		let d = null;
		for (let index = 0; index < 14; index++)   // 0=Sunday, 6=Sat
		{
			this.weekday[index] = new Array(2);   // short form doesn't allow length (which might not do anything)

			for (let evening = 0; evening < 2; evening++)
			{
				// this.weekday[index] = {"caption": d.toLocaleDateString(undefined, { weekday: 'short' }), "steps": 10, "time": 0.0, "bonus": 0}; 
				d = new Date(0);   // the first possible date Javascript represents (starts on Wednesday so need to add 4 to get to Sunday)
				d.setDate(d.getDate() + 4 + index);

				this.weekday[index][evening] = {};

				this.weekday[index][evening].caption = "missing short";
				this.weekday[index][evening].captionLong = "missing long";
				this.weekday[index][evening].growCount = (evening > 0) ? 20 : 10
				this.weekday[index][evening].talkType = 0;
				this.weekday[index][evening].talkTypeValue = 0;

				if (index < 7)
				{
					// Sunday:kevel00.json   Sunday Evening:level10.json
					this.weekday[index][evening].caption = d.toLocaleDateString(undefined, { weekday: 'short' });
					this.weekday[index][evening].captionLong = d.toLocaleDateString(undefined, { weekday: 'long' });
				}
				else
				{
					switch (index)
					{
					case 7:
					{
						// Level07.json
						this.weekday[index][evening].caption = "EZ";
						this.weekday[index][evening].captionLong = "Easy Living";
						break;
					}
					case 8:
					{
						this.weekday[index][evening].caption = "Long";
						this.weekday[index][evening].captionLong = "Lonnng";
						break;
					}
					case 9:
					{
						this.weekday[index][evening].caption = "Paths";
						this.weekday[index][evening].captionLong = "Paths";
						break;
					}
					case 10:
					{
						this.weekday[index][evening].caption = "Limit";
						this.weekday[index][evening].captionLong = "Limited Options";
						break;
					}
					case 11:
					{
						this.weekday[index][evening].caption = "Abound";
						this.weekday[index][evening].captionLong = "Abundance";
						break;
					}
					case 12:
					{
						this.weekday[index][evening].caption = "Mirror";
						this.weekday[index][evening].captionLong = "Mirrored";
						break;
					}
					case 13:
					{
						this.weekday[index][evening].caption = "FunBags";
						this.weekday[index][evening].captionLong = "Fun Bags";
						break;
					}
					}
				}

				// UserData0D0=Day Sunday   UserData0D6=Day Saturday   UserData1D1=Evening Monday			
				let preface = "UserData" + evening + "D" + index;
				this.weekday[index][evening].steps = parseInt(getCookie(preface + "Steps", -1));
				this.weekday[index][evening].time = parseInt(getCookie(preface + "Time", -1));
				this.weekday[index][evening].fail = parseInt(getCookie(preface + "Fail", -1));
			}
		}		
	}
			
	this.SaveCurrentDay = function(pSteps, pTime, pFail)   // Change and Save are synonymous since any change gets immediately saved
	{
		this.weekday[mWorldDayOfWeek][mWorldEvening].steps = pSteps;
		this.weekday[mWorldDayOfWeek][mWorldEvening].time = pTime;
		this.weekday[mWorldDayOfWeek][mWorldEvening].fail = pFail;

		// UserData0D0=Day Sunday   UserData0D6=Day Saturday   UserData1D1=Evening Monday			
		let preface = "UserData" + mWorldEvening + "D" + mWorldDayOfWeek;
		setCookie(preface + "Steps", this.weekday[mWorldDayOfWeek][mWorldEvening].steps);
		setCookie(preface + "Time", this.weekday[mWorldDayOfWeek][mWorldEvening].time);
		setCookie(preface + "Fail", this.weekday[mWorldDayOfWeek][mWorldEvening].fail);
	}
}
var mUserData = new UserData();

// ------------------------------------------------------------------------------------------------------
// <START>
// ------------------------------------------------------------------------------------------------------
var mWorldMode = 1;  // 0:Narrative (Original)   1:DayOfWeek (Monday - Sunday, mUserData)
var mWorldDayOfWeek = -1;   // maps to Javascript:getDay 0:Sun 1:Mon .. 6:Sa (set in Load)
var mWorldEvening = -1;   // 0:Daytime 1:Evening

var documentBodyStyleBackgroundColor = "";

var mWorldLevelCount = -1;   // NEW 2024-10-14. Counts from when player started/restarted. Note: If they continue Frank, mWorldLevelCount starts at 0

var WorldType =
{
	Dense: 0
	, DenseEasy: 1   // no extreme
	, DenseMirror: 2   // can produce BOSS
	, Snake: 3
	, SnakeMirror: 4   // can produce BOSS
	, CrissCross: 5
	, SnakeDense: 6   // fixed an infinite loop, still froze once (might need failsafe returned)
	, SnakeDenseMirror: 7
	, Mold: 8
	, Paintball: 9   // extreme takes a long time
	, SnakeTwoByTwo: 10
	, Spiral: 11
	, Patches: 12   // extreme takes a long time
	, DenseMold: 13   // no extreme (I tried!)
	, Vertigo: 14
	, Plus: 15
	, Donut: 16   // extreme takes a long time
	, Box: 17
	, PlusPlus: 18
	, Pane: 19   // no extreme (I tried!)
	, ThreeSixty: 20
	, SinWav: 21
	, HashTag: 22
	, SnakeImproved: 23
	, Monolith: 24
	, Corner: 25

	, Stripes: 26   // BOSS EXCLUSIVE. Might use DenseMirror creations instead (listed as BOSS below)

	, TwoByTwoBonus: 27
	, TwoByTwoBonusMirror: 28
	, SnakeTwoByTwoBonus: 29
	, RingsBonus: 30
	, RailsBonus: 31   // ONLY extreme
	, RailsBonusMirror: 32   // ONLY extreme

	, Monolith2: 33
};


function LevelName()
{
	return ""
		+ "WorldType." + Object.keys(WorldType)[mWorldType]
		+ "," + mWorldExtreme
		+ ",0"   // used
		
		+ "," + mUrineState
		+ "," + mTileXCount
		+ "," + mTileYCount
		+ "," + mPlayer.left
		+ "," + mPlayer.top
}

var mLevelGenerate = null;   // holds values passed in from URL
var mLevelGenerateCount = 0;   // Limits generation to 40 levels

var mLevels = null;

function LevelsGet(pURL)
{
	// Asynchronous (thanks to fetch)
	mLevels = null;

	// pURL = "fetch-content-full.json";
	fetch(pURL + "?cachebreak=" + configCacheBreaker)
	
	.then(function(response)
	{
		if(!response.ok) { throw new Error("Response NOT Ok"); } return response.text()
	}).then(function(result)
	{
		if(result.stat === "fail")
		{
			throw new Error(result.message);
		}
		// Everything should be ok, process the result here
		mLevels = JSON.parse(jsmin(result));   // jsmin removes the comments in the json file and returns the string json

/*
// 2024-10-15 This Test Worked
let holdErrorMessage = "";
for (mLevelIndex = 0; mLevelIndex < mLevels.length; mLevelIndex++)
{ 
	holdErrorMessage = LevelFileIntoMemory();
	if (holdErrorMessage != "")
	{
		console.log(mLevelIndex + "  LevelFileIntoMemory\n" + holdErrorMessage);
	}
	else
	{
		holdErrorMessage = WorldCheck();
		if (holdErrorMessage != "")
		{
			console.log(mLevelIndex + "  WorldCheck\n" + holdErrorMessage);
		}
	}
}
console.log("DONE");
*/

/*
	// CONSOLE OUTPUT
	let hold = "";
	console.log("--\n\n");

	hold += "// ---------------------------------------------------------------------------------------------------------------------\n";
	hold += "// " + mUserData.weekday[mWorldDayOfWeek][mWorldEvening].captionLong.toUpperCase() + ":";
	if (mWorldEvening == 1) { hold += " EVENING"; } else { hold += " DAYTIME"; } 
	hold += "\n";
	hold += "// ---------------------------------------------------------------------------------------------------------------------\n";
	hold += "[\n";
	
	let count = 0;
	for (let index = 0; index < mLevels.length; index++)
	{
		if ( 
			(mLevels[index][4] == 2) 
			&& (mLevels[index][5] >= 10000)
			// && ((mLevels[index][5] > 5000) && (mLevels[index][5] < 10000))
			// && ((mLevels[index][5] > 1000) && (mLevels[index][5] < 5000))
		)
		{
			count++;
			hold += "// " + count + " " + mLevels[index][0] + ":" + Object.keys(WorldType)[mLevels[index][0]]
			if (mLevels[index][2] > 0) { hold += " Extreme"; }
			hold += "\n";
			if (count > 1) { hold += ", "; }
			hold += JSON.stringify(mLevels[index]) + "\n";
		}
	}
	hold += "]\n";
	
	console.log("--\n\n");
	console.log("--\n\n");	
	console.log(hold);
*/
	if (false)
	{
		mLevels =
		[
		];

		// JSON CONVERSION (copy paste from console window)
		let hold = "";
		console.log("--\n\n");

		hold += "// ---------------------------------------------------------------------------------------------------------------------\n";
		hold += "// " + mUserData.weekday[mWorldDayOfWeek][mWorldEvening].captionLong.toUpperCase() + ":";
		if (mWorldEvening == 1) { hold += " EVENING"; } else { hold += " DAYTIME"; } 
		hold += "\n";
		hold += "// ---------------------------------------------------------------------------------------------------------------------\n";
		hold += "[\n";
		
		let count = 0;
		for (let index = 0; index < mLevels.length; index++)
		{
			count++;
			hold += "// " + count + " " + mLevels[index][0] + ":" + Object.keys(WorldType)[mLevels[index][0]]
			if (mLevels[index][2] > 0) { hold += " Extreme"; }
			hold += "\n";
			if (count > 1) { hold += ", "; }
			hold += JSON.stringify(mLevels[index]) + "\n";
		}
		hold += "]\n";
		
		console.log("--\n\n");
		console.log("--\n\n");	
		console.log(hold);

	}

	// [3] indicates whether we've played this level this session
	for (let index = 0; index < mLevels.length; index++) { mLevels[index][3] = 0; }

	if (mWorldMode == 1) { mWeekdayLevelsRemaining = mLevels.length; } else { mWeekdayLevelsRemaining = -1; }

	}).catch(function(err) { alert("Sorry! There's a problem retrieving levels '" + pURL + "'. Try refreshing. Technical Details\n" + err); });
}
		

function TileExtraChangePlayFieldState(pState)
{
	for (let xyIndex = 0; xyIndex < mPlayField.length; xyIndex++) { if (mPlayFieldDivs[xyIndex].extra > 0) { mPlayField[xyIndex] = pState; } }
}

function TileExtraGetPlayFieldState()
{
	// 0: No Extra tiles, or Extra tiles are ALL OFF (.extra is true BUT tile is not showing)
	// 1: Extra tiles are ALL ON
	// Note: All on or all off.

	let returnValue = -1;
	for (let xyIndex = 0; xyIndex < mPlayField.length; xyIndex++)
	{
		if (mPlayFieldDivs[xyIndex].extra > 0)
		{
			if (mPlayField[xyIndex] == 0)
			{
				if (returnValue == -1) { returnValue = 0; } else if (returnValue == 1) { console.assert(false, "Extra tiles only partially on."); }
			}
			else
			{
				if (returnValue == -1) { returnValue = 1; } else if (returnValue == 0) { console.assert(false, "Extra tiles only partially on."); }
			}
		}
	}
	if (returnValue == -1) { returnValue = 0; }	
	return returnValue;
}

function WorldCheck()
{
	// Checks the World/Memory contents - NOT the JSON file (which will load into Memory and THEN be checked)
	
	// assumes that mSolvedPlayfieldTurn and mSolvedPlayfield are filled out.
	var errorMessage = "";

	// Ensure all Extra Tiles OFF (interferes with some checks)
	let holdExtraState = TileExtraGetPlayFieldState();
	if (holdExtraState > 0) { TileExtraChangePlayFieldState(0); }

	var answerLimit = -1;

	if (mTileXYCount < 6)
	{
		errorMessage += "Main: mTileXYCount is SUPER WRONG '" + mTileXYCount + "'\n";
	}
	if (mTileXYCount != (mTileXCount * mTileYCount))
	{
		errorMessage += "Main: mTileXYCount '" + mTileXYCount + "' out-of-sync with mTileXCount '" + mTileXCount + "' and mTileYCount '" + mTileYCount + "'\n";
	}

	let checkTileTotal = 0;
	for (let index = 0; index < mTileXYCount; index++) { if (mPlayField[index] > 0) { checkTileTotal++; } }
	if (mTileTotal != checkTileTotal)
	{
		errorMessage += "Main: mTileTotal '" + mTileTotal + "' out-of-sync with mPlayfield '" + checkTileTotal + "'\n";		
	}
	// </mPlayField>
			
	// <SHIFT CHECK>
	TileExtraChangePlayFieldState(1);
	var x1 = 1000, x2 = -1, y1 = 1000, y2 = -1;	
	for (var xx = 0; xx < mTileXCount; xx++)
	{
		for (var yy = 0; yy < mTileYCount; yy ++)
		{
			if (mPlayField[yy * mTileXCount + xx] > 0)
			{
				if (xx < x1) { x1 = xx; }
				if (xx > x2) { x2 = xx; }
				if (yy < y1) { y1 = yy; }
				if (yy > y2) { y2 = yy; }			
			}
		}
	}
	if ((x1 == 1000) || (x2 == -1) || (y1 == 1000) || (y2 == -1))
	{
		errorMessage += "Playfield: is beyond fucked.\n"; 
	}	
	else if ( (((x2 - x1) + 1) != mTileXCount) || (((y2 - y1) + 1) != mTileYCount) )
	{
		errorMessage += "Playfield: mTileXCount x mTileYCount '" + mTileXCount + "x" + mTileYCount + "' includes BLANK AREAS. Should be '" + ((x2 - x1) + 1) + "x" + ((y2 - y1) + 1) + "'\n";
	}
	TileExtraChangePlayFieldState(0);
	// </SHIFT CHECK>

	// <SOLVED PLAYFIELD>
	// either they're both filled in or neither is filled in. Note: Don't confuse with JSON where the rules are slightly different to save space
	if (!((mSolvedPlayfieldTurn[0] == 100000) && (mSolvedPlayfieldTurn[1] == -1)))
	{
		for (var answer = 0; answer < 2; answer++)
		{
			if (mSolvedPlayfieldTurn[answer] < 2)
			{
				errorMessage += "Turn[" + answer + "] is INVALID '" + mSolvedPlayfieldTurn[answer] + "'\n";
			}
			
			if (mSolvedPlayfield[answer] == null)
			{
				errorMessage += "mSolvedPlayfield[" + answer + "] is NULL.\n";	
			}
			else
			{
				var holdErrorMessage = "";
				for (var index = 0; index < mTileXYCount; index++)
				{
					switch (mSolvedPlayfield[answer][index])
					{
						case 0:
						case 1:
						case -1:
						case -2:
						case -3:
						case -4:
						{
							// fine
							break;
						}
						default:
						{
							holdErrorMessage = "Tile '" + index + "' has INVALID value '" + mSolvedPlayfield[answer][index] + "'\n";
							break;
						}
					}
					if (holdErrorMessage != "") { errorMessage += holdErrorMessage; break; }
				}	
				
				var check2 = 0;
				for (var index = 0; index < mTileXYCount; index++)
				{
					// < 10 removed 992 nastiness in Answer1
					if ( (mSolvedPlayfield[answer][index] != 0) && (mSolvedPlayfield[answer][index] < 10) ) { check2++; }
				}
				if (check2 != mTileTotal)
				{
					errorMessage += "mSolvedPlayfield[" + answer + "] does NOT have all the tiles! '" + check2 + ":" + mTileTotal + "'\n";
				}	
				
				for (var index = 0; index < mTileXYCount; index++)
				{
					if (
						((mPlayField[index] == 0) && (mSolvedPlayfield[answer][index] != 0))
						|| ((mPlayField[index] != 0) && (mSolvedPlayfield[answer][index] == 0))
					)
					{
						var hold1 = "" + mPlayField.length + ":";
						for (var index333 = 0; index333 < mPlayField.length; index333++) { hold1 += mPlayField[index333]; }
						var hold2 = "" + mSolvedPlayfield[answer].length + ":";
						for (var index333 = 0; index333 < mSolvedPlayfield[answer].length; index333++) { hold2 += mSolvedPlayfield[answer][index333]; }
						
						errorMessage += "mPlayfield and Answer[" + answer + "] do NOT match!\n" + hold1 + "\n" + hold2 + "\n";
						break;
					}
				}
				
				var check4 = 0;
				for (var index = 0; index < mTileXYCount; index++)
				{
					if (mSolvedPlayfield[answer][index] == 1) { check4++; }
				}
				if (check4 == 0)
				{
					errorMessage += "mSolvedPlayfield[" + answer + "] has NO FINAL TILE=1\n";
				}
				else if (check4 > 1)
				{
					errorMessage += "mSolvedPlayfield[" + answer + "] has MULTIPLE '" + check4 + "' FINAL TILES=1\n";
				}
				
				// Make player walk through solution, ensure every tile is removed.
				var pX = mPlayer.left, pY = mPlayer.top;
				var holdTileTotal = mTileTotal;
				var hold = -1, holdOld = 999;
				var turnCount = 0;
				while (holdTileTotal > 0)
				{
					hold = mSolvedPlayfield[answer][pY * mTileXCount + pX];
					if (
						( ((holdOld == -1) || (holdOld == -2)) && ((hold == -3) || (hold == -4)) )
						|| ( ((holdOld == -3) || (holdOld == -4)) && ((hold == -1) || (hold == -2)) )
					)
					{ turnCount++; }
					holdOld = hold;

					if (holdTileTotal == 1)
					{
						if (mSolvedPlayfield[answer][pY * mTileXCount + pX] != 1)
						{
							errorMessage += "mSolvedPlayfield[" + answer + "] final tile != 1 '" + mSolvedPlayfield[answer][pY * mTileXCount + pX] + "'\n";
						}
						if (turnCount != mSolvedPlayfieldTurn[answer])
						{
							errorMessage += "Turns in mSolvedPlayfield[" + answer + "] don't match mSolvedPlayfieldTurn[" + answer + "] " + turnCount + ":" + mSolvedPlayfieldTurn[answer] + "\n";
						}
					}
					else
					{
						var dirX = 0, dirY = 0;
						if (hold == -1) { dirX = -1; } else if (hold == -2) { dirX = 1; } else if (hold == -3) { dirY = -1; } else if (hold == -4) { dirY = 1; }
						else
						{
							errorMessage += "mSolvedPlayfield[" + answer + "] has invalid tile value '" + hold + "' Index:" + pY * mTileXCount + pX + " Totals:" + holdTileTotal + "/" + mTileTotal + "\n";
							break;
						}
						pX += dirX; pY += dirY;	
						if ((pX < 0) || (pX >= mTileXCount) || (pY < 0) || (pY >= mTileYCount))
						{
							errorMessage += "mSolvedPlayfield[" + answer + "] moved OUTSIDE playfield! '" + pX + "x" + pY + " " + mTileXCount + "x" + mTileYCount + "\n";
							break;
						}
					}
					holdTileTotal--;
				}
			}
		}		
	}
	else if (
		((mSolvedPlayfieldTurn[0] == 100000) && (mSolvedPlayfieldTurn[1] != -1))
		|| ((mSolvedPlayfieldTurn[0] != 100000) && (mSolvedPlayfieldTurn[1] == -1))
	)
	{
		errorMessage += "Only ONE mSolvedPlayfieldTurn is initialized - they're out of sync. mSolvedPlayfieldTurn[0/100000]:" + mSolvedPlayfieldTurn[0] + " mSolvedPlayfieldTurn[1/-1]:" + mSolvedPlayfieldTurn[1] + "\n"; 
	}		
	// </SOLVED PLAYFIELD>

	let levelState = -1;
	if ((mSolvedPlayfieldTurn[0] == 100000) && (mSolvedPlayfieldTurn[1] == -1))
	{
		levelState = 0;
		for (let xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
		{
			if (mSolvedPlayfield[0][xyIndex] == 1)	
			{
				errorMessage += "LevelState: No Answers BUT found a final tile '" + xyIndex + "'. This should never happen.";
			}
		}
	}
	else if ( (mSolvedPlayfield[0] != null) && (mSolvedPlayfield[1] != null) )
	{
		let same = true;
		for (let xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
		{
			if (mSolvedPlayfield[0][xyIndex] != mSolvedPlayfield[1][xyIndex]) { same = false; break; }
		}
		if (same)
		{
			if (mSolvedPlayfieldTurn[0] != mSolvedPlayfieldTurn[1])
			{
				errorMessage += "SolvedPlayfield: Playfields are the same BUT SolvedPlayfieldTurns are different '" + mSolvedPlayfieldTurn[0] + "','" + mSolvedPlayfieldTurn[1] + "'\n";
 			}
			levelState = 1;
		}
		else
		{
			levelState = 2;
		}
	}
	if ( (mLevelIndex > -1) && (mLevels[mLevelIndex][4] != levelState) )
	{
		if ((levelState == 2) && (mLevels[mLevelIndex][4] == 1))
		{
			// Not an error. While we have 2 different answers there may have been more, so they were saved with a LevelState of 1 (with no indication that mStatePushPopped had happened)
		}
		else
		{
			// definitely some errors in the BIG JSON FILE :(
			// errorMessage += "LevelState: File LevelState '" + mLevels[mLevelIndex][4] + "' does NOT match Levelstate I just calculated '" + levelState + "'\n";
		}
	}

	if (holdExtraState > 0) { TileExtraChangePlayFieldState(1); }
	if (errorMessage != "") { errorMessage += JSON.stringify(mLevels[mLevelIndex]); }
	return errorMessage;	
}

function LevelFileIntoMemory()
{
	console.assert(
		(mLevelIndex > -1) && (mLevelIndex < mLevels.length)
		, "LevelFileIntoMemory Error: Needs to be 'passed' a valid mLevelIndex '" + mLevelIndex + "'"
	);
	
	// Copies data from file/JSON into the World. Called by WorldResetNew and WorldReset
	mState = 0;
	mSolutions = 0;
	
	var errorMessage = "";
	if ( (mLevels[mLevelIndex].length != 13) && (mLevels[mLevelIndex].length != 15) && (mLevels[mLevelIndex].length != 16) )
	{
		// 15:2nd Answer optional, 16:Extra Tiles Optional
		errorMessage += "Incorrect array mLevels[].length '" + mLevels[mLevelIndex].length + "'\n";	
	}
	else
	{
		mWorldType = mLevels[mLevelIndex][0];
		// mLevels[mLevelIndex][1]; = # of final tiles, used for filtering levels before we getg here
		mWorldExtreme = mLevels[mLevelIndex][2];
		if (mLevels[mLevelIndex][3] != 0) { errorMessage += "mLevels[mLevelIndex][3] != 0 '" + mLevels[mLevelIndex][3] + "'. We're trying to use a level we already used this session."; }
		
		ChangeTileCount(mLevels[mLevelIndex][7], mLevels[mLevelIndex][8]);		
		mPlayer.ChangePosition(mLevels[mLevelIndex][9], mLevels[mLevelIndex][10]);

		if (mLevels[mLevelIndex][12].length != mTileXYCount)
		{
			errorMessage += "Answer[0] length should be mTileXYCount '" + mTileXYCount + "', instead it's " + mLevels[mLevelIndex][12].length + "\n";		
		}
		if ((mLevels[mLevelIndex][14] != null) && (mLevels[mLevelIndex][14].length != mTileXYCount))
		{
			errorMessage += "Answer[1] length should be mTileXYCount '" + mTileXYCount + "', instead it's " + mLevels[mLevelIndex][14].length + "\n";
		}

		// <MPLAYFIELD>
		// First Answer/Block stored in mLevelIndex][12] as a string.
		// It could be 010101010 >OR< 12300040321 - mPlayField NEED JUST 01010101
		for (var index = 0; index < mPlayField.length; index++) { mPlayField[index] = 0; }
		mTileTotal = 0;
		var hold = 0;
		for (var index = 0; index < mTileXYCount; index++)
		{
			hold = parseInt(mLevels[mLevelIndex][12][index]);
			if (hold != 0) { mPlayField[index] = 1; mTileTotal++; }
		}
		// </MPLAYFIELD>

		mSolvedPlayfieldTurn[0] = 100000;
		mSolvedPlayfieldTurn[1] = -1;
		for (var answer = 0; answer < 2; answer++)
		{
			for (var index = 0; index < mSolvedPlayfield[answer].length; index++) { mSolvedPlayfield[answer][index] = 0; }
		}

		// -----
		if (mLevelGenerate == "fix")
		{
			// Going to overwrite the rest of the values (mSolvedPlayfields, Extras). Only keeping playfield
			mState = 0;
			mStatePushPopped = false;
			mSolutions = 0;
		}
		else
		{
			let levelState = mLevels[mLevelIndex][4];   // 0=no answers, 1=2 unreliable answers, 2=2 reliable answers
			if ((levelState < 0) || (levelState > 2))
			{
				errorMessage += "levelState has UNKNOWN value '" + levelState + "'\n";
			}
			else
			{
				// Convert levelState into what LevelGenerate/SolveUpdate use (mSolutions/mStatePushPopped).
				if (levelState == 0)
				{
					// There's 1+ solutions (of course, otherwise it wouldn't be in array)
					// BUT solutions are beyond our ability to calculate (too many possibilities, even for a 1,750,000 playfield array)
					mState = 0;
					mStatePushPopped = true;
				}
				else if (levelState == 1)
				{
					// we have most/least, but they can't be trusted
					mState = 0;
					mStatePushPopped = true;
				}
				else if (levelState == 2)
				{
					// we have most/least, and they CAN be trusted
					mState = 2;
					mStatePushPopped = false;	
				}
			}

			if (mLevels[mLevelIndex][5] == null) { errorMessage += "mLevels[mLevelIndex][5] / solutions is somehow null. i blame you."; }
			mSolutions = mLevels[mLevelIndex][5];
			mSolutionsFileRemember = mSolutions;
			
			// mUrineState = mLevels[mLevelIndex][6];   // UrineState NOT decided by level being read in. [6] Just a filter to FIND broken urine levels
		
			// <MSOLVEDPLAYFIELD>			
			if (levelState == 0)
			{
				if (Math.floor(mLevels[mLevelIndex][11]) != 0)
				{
					errorMessage += "LevelState is 0 in the file, BUT there's an answer '" + mLevels[mLevelIndex][11] + "'";
				}			
			}
			else
			{
				var root = 11;
				var hold = 0;
				for (var answer = 0; answer < 2; answer++)
				{
					mSolvedPlayfieldTurn[answer] = parseInt(mLevels[mLevelIndex][root]);
					root++;

					var holdErrorMessage = "";
					for (var index = 0; index < mTileXYCount; index++)
					{
						// I store negative values -1,-2,-3,-4 as 2,3,4,5 to save room in this TEXT file. Convert them back
						hold = parseInt(mLevels[mLevelIndex][root][index]);
						switch (hold)
						{
							case 0:
							{
								break;
							}
							case 1:
							{
								break;
							}
							case 2:
							{
								hold = -1;
								break;
							}
							case 3:
							{
								hold = -2;
								break;
							}
							case 4:
							{
								hold = -3;
								break;
							}
							case 5:
							{
								hold = -4;
								break;
							}
							default:
							{
								holdErrorMessage = "Tile '" + index + "' has INVALID Level compressed value '" + hold + "'\n";
								break;
							}
						}

						if (holdErrorMessage != "")
						{
							errorMessage += holdErrorMessage;
							break;
						}
						else
						{
							mSolvedPlayfield[answer][index] = hold;
						}
					}
					root++;					
				}

				// Check: TurnCount
				if (mSolvedPlayfieldTurn[0] > mSolvedPlayfieldTurn[1])
				{
					errorMessage += "Least Turns[0] '" + mSolvedPlayfieldTurn[0] + "' is LARGER than Most Turns[1] '" + mSolvedPlayfieldTurn[1] + "'\n";
				}	

				// Check: Match
				for (var index = 0; index < mTileXYCount; index++)
				{
					if (
						( (mSolvedPlayfield[0][index] == 0) && (mSolvedPlayfield[1][index] != 0) )
						|| ( (mSolvedPlayfield[0][index] != 0) && (mSolvedPlayfield[1][index] == 0) )
					)
					{
						errorMessage += "mSolvedPlayfield[0] and mSolvedPlayfield[1] do NOT HURT match.\n";
						break;
					}
				}
			}
			// </MSOLVEDPLAYFIELD>

			// Extra handled in WorldResetFinish (hingent on TalkState)
		}
	}
	
	if (errorMessage != "")
	{
		mState = 1;
		mSolvedPlayfieldTurn[0] = 100000;
		mSolvedPlayfieldTurn[1] = -1;
		for (var answer = 0; answer < 2; answer++)
		{
			for (var index = 0; index < mSolvedPlayfield[answer].length; index++) { mSolvedPlayfield[answer][index] = 0; }
		}
		
		mSolveStatTitle = "ERROR!";
		errorMessage = "LevelFileIntoMemory Error:" + LevelName2(mLevelIndex) + "\n" + errorMessage;		
	}
	else
	{
		mSolveStatTitle = Object.keys(WorldType)[mWorldType];
		mSolveStatTitle += " " + mTileXCount + "x" + mTileYCount;
		if (mWorldExtreme) { mSolveStatTitle += "E"; }
	}
	
	return errorMessage;
}

function LevelMemoryIntoFile()
{
	// Returns NOTHING. All errors are dumped into console window
	// Rather than store the result in a file, dump it to Console
	// Ignores mState = 1, meaning it will Display broken Levels (believe UrineState needs this)
	// Ignores mSolutions = 0, meaning it will Display broken levels (believe UrineState needs this)

	/*
	// SHOW MAZE
	console.log("");
	for (var y = 0; y < (mTileXYCount / mTileXCount); y++)
	{
		var hold = "";
		var c = 0;
		for (var x = 0; x < mTileXCount; x++)
		{
			c = mSolvedPlayfield[0][y * mTileXCount + x];
			if (c < 0) { c = (-c + 1); }
			hold += c;
		}
		console.log(hold);
	}
	console.log("");
	*/

		// we may not have ALL the answers, or the correct least/most answer, BUT we'll take the ONLY answer we could get
		// if there's only 1 answer, stringAnswers[0] and stringAnswers[1] will be the same.
		// *** if we TOP OUT with 1 answer - AWESOME. if we don't top out, and have a playfield with only 1 answer - REJECT ***
		// all of these fixes TOP OUT

		var stringAnswers = new Array(2);
		for (var answer = 0; answer < 2; answer++)
		{
			stringAnswers[answer] = "";
			if (
				((answer == 0) && (mSolvedPlayfieldTurn[answer] != 100000))
				|| ((answer == 1) && (mSolvedPlayfieldTurn[answer] != -1))
			)
			{			
				stringAnswers[answer] += "," + mSolvedPlayfieldTurn[answer];
				stringAnswers[answer] += ",\"";

				var hold = "";
				for (var index = 0; index < mTileXYCount; index++)
				{
					hold = "";
					switch (mSolvedPlayfield[answer][index])
					{
						case 0:
						case 1:
						{
							hold = "" + mSolvedPlayfield[answer][index]; 
							break;
						}
						case -1:
						{
							hold = "2";
							break;
						}
						case -2:
						{
							hold = "3";
							break;
						}
						case -3:
						{
							hold = "4";
							break;
						}
						case -4:
						{
							hold = "5";
							break;
						}
						default:
						{
							console.error("LevelMemoryIntoFile Error: mSolvedPlayfield[" + answer + "] had a bad value '" + mSolvedPlayfield[answer][index] + "'");
							break;
						}
					}
					stringAnswers[answer] += hold;
				}
				stringAnswers[answer] += "\"";
			}
		}

		console.assert(
			((stringAnswers[0] != "") && (stringAnswers[1] != ""))
			|| ((stringAnswers[0] == "") && (stringAnswers[1] == ""))
			, "LevelMemoryIntoFile Error: Least '" + stringAnswers[0].length + "' and Most '" + stringAnswers[1].length + " should BOTH be in sync, but they're NOT."
		);
			
		// <LEVELSTATE>
		var levelState = -1;
		// 0 - Bad level. No least and most (for larger "solved" levels, especially bonus and snake, not possible to find a winning path)
		// 1 - Okay level. Has least and most, they're not perfect (993)
		// 2 - Perfect level. Has least and most, they're perfect (992).

		if (stringAnswers[0] == "")
		{
			// no least/most - so answer becomes PlayField (a collection of 0s and 1s only)
			stringAnswers[0] += ",0,";   // No TurnCount, make this 0 to keep format compatible with valid mSolvePlayFieldAnswer[0]
			stringAnswers[0] += "\"";
			for (var index = 0; index < mTileXYCount; index++) { stringAnswers[0] += mPlayField[index]; }
			stringAnswers[0] += "\"";
			levelState = 0;
		}
		else if ((mSolutions == 1) || (mStatePushPopped))
		{
			// only 1 solution, or least/most that was compromised by lack of memory
			levelState = 1;
		}
		else
		{
			// perfect least/most (guaranteed to exist)
			levelState = 2;
		}	
		// </LEVELSTATE>

		if (levelState > 0)
		{
			var holdFinalTile = 0;
			for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
			{
				if (mPlayFieldDivs[xyIndex].finalTile > 0) { holdFinalTile++; }
			}
			console.assert(holdFinalTile > 0), "LevelMemoryIntoFile() Error: mPlayFieldDivs[xyIndex] has no .finalTile"
		}
		
		var holdExtreme = 0; if (mWorldExtreme) { holdExtreme = 1; }
		var holdUrineState = 0; if (mUrineState == 1) { holdUrineState = 1; } // do NOT save mUrineState == 2 (or -1), because that's simply a VALID LEVEL 

		// <EXTRA>
		var stringExtra = "";
		// Tile.Extra indicated the Extra xyIndex to SAVE,
		// BUT want BEST Extras (more attached) SAVED FIRST. Hence this mess.
		let extraSpots = [];
		for (let xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
		{
			if (mPlayFieldDivs[xyIndex].extra > 0) { extraSpots.push(xyIndex); }
		}
		if (extraSpots.length > 0)
		{
			ShuffleArray(extraSpots);
			for (let edgeCount = 0; edgeCount < 4; edgeCount++)
			{
				for (let index = 0; index < extraSpots.length; index++)
				{
					let extraY = parseInt(extraSpots[index] / mTileXCount);
					let extraX = extraSpots[index] - (extraY * mTileXCount);
					if (EdgeCount(extraX, extraY) == edgeCount)
					{
						stringExtra += "," + extraSpots[index];
					}
				}
			}
		}
		if (stringExtra != "")
		{
			if (stringAnswers[1] == "") { stringAnswers[1] = ", null, null" }
			stringExtra = ", [" + stringExtra.substring(1) + "]";
		}
		// </EXTRA>

		
		var holdStateHeader = (mLevelGenerate == null) ? "INCOMPLETE" : "";

		console.log(
			holdStateHeader
			+ ", [" 
			+ "WorldType." + Object.keys(WorldType)[mWorldType]
			+ "," + holdFinalTile
			+ "," + holdExtreme
			+ ",0"   // used
			+ "," + levelState
			+ "," + mSolutions   // new 2021-12-09. not every level has this.
			
			+ "," + holdUrineState
			+ "," + mTileXCount
			+ "," + mTileYCount
			+ "," + mPlayer.left
			+ "," + mPlayer.top
			+ "   " + stringAnswers[0]   // always exists, but might be 000111 and NOT a full answer. indirectly includes mTileTotal   11/12
			+ "   " + stringAnswers[1]   // might not exist (not even a ,)   13/14
			+ "   " + stringExtra
			+ "]"
		);	
		
		/*
		Outputs:
		"[WorldType.Dense,0,0,0,2,4,0,5,5,4,4   ,8,"0052212504042043333442222"   ,,, [1,552,3]]"
		Needs:
		"[WorldType.Dense,0,0,0,2,4,0,5,5,4,4   ,8,"0052212504042043333442222"   , null, null, [1,552,3]]"
		
		JSON.stringify converts to:
		"[0,0,0,0,2,4,0,5,5,4,4,8,"0052212504042043333442222",null,null,[1,552,3]]"
		will not convert , , MUST be , null, null
		*/
}


// ---------------------------------------------------------------------------------------------------------------------
// <TALK>
// ---------------------------------------------------------------------------------------------------------------------
var mTalks = null;
var mTalkIndex = -1;
var mTalkLastDate = 0;
var mTalkLastType3000 = false;
var mTalkStates = null;

var mTalk3000Index = -1;
var mTalkCurrentTimeRemember = 0;

var mTalkTypeExtraRecursiveBreak = 0;
var mTalkRandomCountdown = 0;
var mTalkRandomFailState = 0;

var mTalkLevelCount = 0;   // Slow players need to finish 3 levels BEFORE next talk

const TalkType =
{
	light: 0
	, control: 1
	, fail: 2   // frank
	, tileInvisible: 3
	, tileExtra: 4    // special. music CANNOT add tiles, additions MUST take place BEFORE that. music CAN remove tiles
	, urine: 5   // special. music CANNOT add urine, must be set BEFORE that
	, randomFail: 6   // special. music CANNOT add randomFails.
	, turns: 7   // special. music CANNOT add turns.
	, finishTile: 8   // type:1 can be added by music. type:2 special. music CANNOT make all tiles finish tiles (before filter, a level might have 1 or 10)
	, concreteBlock: 9
}

const TalkType2 =
{
	start: 3000
	, usethehole: 3000
	, songendedearly: 3001
	, instructions: 3002
	, playerusedhole: 3003
	, bonuscountdown10: 3004
	, bonuscountdown25: 3005
	, bonuscountdown50: 3006
	, addedtilered: 3007
	, completed50: 3008
	, failfinished: 3009
}

function TalkStatesReset()
{
	mTalkStates[TalkType.light] = 1;   // 0 - lights off   1 - lights on
	mTalkStates[TalkType.control] = 1;   // 0 - controls off   1 - controls on
	mTalkStates[TalkType.fail] = 1;   // 0 - fail broken   1 - fail working
	mTalkStates[TalkType.tileInvisible] = 0;   // 0 - no tiles missing   1+ - how many are missing (if possible, can't remove tiles under stats)
	mTalkStates[TalkType.tileExtra] = 0;   // 0 - no extra   1+ - number of tiles you want missing. 1 is guaranteed, 4 means *TRY* for 4
	mTalkStates[TalkType.urine] = 0;   // 0 - normal level   1 - level transformed into a urine level
	mTalkStates[TalkType.randomFail] = 0;   // 0 - normal level   1 - easy 5x5 levels, random fails will happen (ease players in)  2 - regular/complex levels with random fails
	mTalkStates[TalkType.turns] = 0;   // 0 - normal level   1 - must be completed in least turns   2 - must be completed in most turns
	mTalkStates[TalkType.finishTile] = 0;
	mTalkStates[TalkType.concreteBlock] = 0;
}
mTalkStates = new Array();
TalkStatesReset();

var LevelType =
{
  Regular: 0
  , Tricky: 1
  , Bonus: 2
  , Boss: 3
  , MileStone: 4
  , OneHundred: 5
};
var mLevelType = LevelType.Regular;
var mLevelStageCount = 0;   // BOSS level has multiple stages

// time:0 needs to change default state for the level (start with lights off, fail not working)
// time:0 can have MULTIPLE things happen
// 		[1, "talk-001-lights-out.mp3", `[{"time":0,"type1":${TalkType.tileInvisible},"type2":2},{"time":2,"type1":${TalkType.tileInvisible},"type2":3},{"time":4,"type1":${TalkType.tileInvisible},"type2":0}]`]

// (if it cuts out) I WANTED TO HEAR MORE HAPPY HOLLOWS!!!
// 31. i see you changed the backdrop text too ... HAPPY HOLLOWS!
// 35. The BOSS levels are always so complicated. They're amazing. Sometimes they're easy though, I wish they did better procedural generation. Just pray it doesn't generate a swastika
mTalks = [
	/*
	[LevelType.Regular, 0, "talk-038-changed-boss-music.mp3"]
	, [LevelType.Regular, 0, "talk-047-gregg-imuseless.mp3"]
	, [LevelType.Regular, 0, "talk-054-failsbroken.mp3"]
	, [LevelType.Boss, 0, ""]
	, [LevelType.OneHundred, 0, ""]
	*/

	// 000 : Introduction
	[LevelType.Regular, 0, "talk-001-lights-out.mp3"
		, [{"time":0,"type1":TalkType.light,"type2":0},{"time":0,"type1":TalkType.control,"type2":0},{"time":17.3,"type1":TalkType.light,"type2":1},{"time":46.0,"type1":TalkType.control,"type2":1}]
		, [{"type1":TalkType.turns,"type2":0}]
	]		

	// 001
	, [LevelType.Regular, 0, "talk-005-first-gregg.mp3"
		, [
			{"time":25.95,"type1":TalkType.light,"type2":0},{"time":27.19,"type1":TalkType.light,"type2":1}
			, {"time":28.08,"type1":TalkType.light,"type2":0},{"time":28.34,"type1":TalkType.light,"type2":1}
			, {"time":28.64,"type1":TalkType.light,"type2":0},{"time":30.84,"type1":TalkType.light,"type2":1}
		]
	]		

	, [LevelType.Regular, 0, "talk-009-gregg-dont-touch-lights.mp3"
		, [
			{"time":4.25,"type1":TalkType.light,"type2":0},{"time":4.85,"type1":TalkType.light,"type2":1}
			, {"time":6.55,"type1":TalkType.light,"type2":0},{"time":7.3,"type1":TalkType.light,"type2":1}
			, {"time":16.0,"type1":TalkType.light,"type2":0},{"time":20.0,"type1":TalkType.light,"type2":1}
		]
	]

	, [LevelType.Regular, 0, "talk-014-more-gregg.mp3"
		, [
			{"time":8.78,"type1":TalkType.control,"type2":0},{"time":13.25,"type1":TalkType.light,"type2":0}
			, {"time":20.08,"type1":TalkType.light,"type2":1},{"time":30.65,"type1":TalkType.control,"type2":1}
		]
	]
	
	, [LevelType.Regular, 0, "talk-021-fail.mp3"]
	
	// 005
	, [LevelType.Regular, 0, "talk-025-theeaglesman.mp3"]
	
	, [LevelType.Regular, 0, "talk-029-jakereplacedhappyhollows.mp3"]

	, [LevelType.Bonus, 0, ""]

	, [LevelType.Regular, 0, "talk-034-will-player-get-bored.mp3"]

	, [LevelType.Regular, 0, "talk-038-changed-boss-music.mp3"]

	// 010
	, [LevelType.Boss, 0, ""]
	
	// 011 : Invisible Tiles
	, [LevelType.Regular, 0, "talk-041-gregg-alone.mp3"
		, [{"time":30.8,"type1":TalkType.tileInvisible,"type2":1},{"time":46.8,"type1":TalkType.tileInvisible,"type2":2},{"time":53.0,"type1":TalkType.tileInvisible,"type2":3}]
	  ]

	, [LevelType.Regular, 0, "talk-043-gregg-worried.mp3", [{"time":13.2,"type1":TalkType.tileInvisible,"type2":4}]]

	, [LevelType.Regular, 0, "talk-045-gregg-moaning.mp3"
		, [
			{"time":17.2,"type1":TalkType.light,"type2":0},{"time":19.5,"type1":TalkType.light,"type2":1}
			, {"time":24.4,"type1":TalkType.control,"type2":0},{"time":26.6,"type1":TalkType.control,"type2":1}
		]
	]

	, [LevelType.Regular, 0, "talk-049-gregg-fixed.mp3", [{"time":40.7,"type1":TalkType.tileInvisible,"type2":0}]]

	, [LevelType.MileStone, 0, ""]


	// 016 : Random Fail:Easy (introduces player)
	, [LevelType.Regular, 0, null, null, [{"type1":TalkType.randomFail,"type2":1}]]

	// 017 : Random Fail:Regular
	, [LevelType.Regular, 0, "talk-054-failsbroken.mp3", null, [{"type1":TalkType.randomFail,"type2":2}]]
	
	, [LevelType.Regular, 0, "talk-055-canitbefixed.mp3"]

	, [LevelType.Regular, 0, "talk-056-randomnumber.mp3"]

	// 020
	, [LevelType.Regular, 0, "talk-057-notthecode.mp3"]
					
	, [LevelType.Regular, 0, "talk-059-fixed.mp3"
		, [{"time":4.6,"type1":TalkType.light,"type2":0},{"time":4.6,"type1":TalkType.control,"type2":0},{"time":7.0,"type1":TalkType.light,"type2":1},{"time":7.0,"type1":TalkType.control,"type2":1}]
		, [{"type1":TalkType.randomFail,"type2":0}]
	  ]

	, [LevelType.Boss, 0, ""]

	// Added Tile:23
	, [LevelType.Regular, 0, "talk-061-jake-added-tile1.mp3", null, [{"type1":TalkType.tileExtra,"type2":1}] ]

	, [LevelType.Regular, 0, "talk-062-added-tile-red-number.mp3"]

	, [LevelType.Regular, 0, "talk-063-jake-added-tile2.mp3"]

	, [LevelType.Regular, 0, "talk-065-added-tiles-howmany.mp3", null, [{"type1":TalkType.tileExtra,"type2":4}]]
	
	, [LevelType.Regular, 0, "talk-068-gregg-removed-added-tile.mp3", [{"time":20.2,"type1":TalkType.tileExtra,"type2":0}]]

	, [LevelType.Regular, 0, "talk-069-jakethanksgregg.mp3"]

	, [LevelType.Bonus, 0, ""]	
	
	// Urine 30
	, [LevelType.Regular, 0, null, null, [{"type1":TalkType.urine,"type2":1}]]

	, [LevelType.Regular, 0, ""]

	, [LevelType.Regular, 0, ""]

	, [LevelType.Regular, 0, ""]

	, [LevelType.Regular, 0, null, null, [{"type1":TalkType.urine,"type2":0}]]

	// 35
	, [LevelType.Boss, 0, ""]
	
	// Finish Tile 36
	, [LevelType.Regular, 0, "talk-041-gregg-alone.mp3", [{"time":5,"type1":TalkType.finishTile,"type2":1},{"time":25,"type1":TalkType.finishTile,"type2":0}]]

	, [LevelType.Regular, 0, ""]

	, [LevelType.Regular, 0, "talk-041-gregg-alone.mp3", [{"time":8,"type1":TalkType.finishTile,"type2":2}]]

	, [LevelType.Regular, 0, "talk-041-gregg-alone.mp3", [{"time":5,"type1":TalkType.finishTile,"type2":0}]]


	// Concrete Block 40
	, [LevelType.Regular, 0, "talk-021-fail.mp3", [{"time":10,"type1":TalkType.concreteBlock,"type2":-999}]]   // fill ALL empty spots with visible concrete

	, [LevelType.Regular, 0, "talk-021-fail.mp3", [{"time":5,"type1":TalkType.concreteBlock,"type2":2}]]   // reduce to 2 spots

	, [LevelType.Regular, 0, "", null, [{"type1":TalkType.concreteBlock,"type2":999}]]   // fill ALL empty spots with invisible concrete

	, [LevelType.Regular, 0, "talk-021-fail.mp3", [{"time":5,"type1":TalkType.concreteBlock,"type2":0}]]   // remove all invisible concrete


	// Turns 44 Least/Most
	, [LevelType.Regular, 0, "", null, [{"type1":TalkType.turns,"type2":1}]]

	, [LevelType.Regular, 0, "", null, [{"type1":TalkType.turns,"type2":2}]]

	, [LevelType.Regular, 0, "", null, [{"type1":TalkType.turns,"type2":0}]]
	
	, [LevelType.OneHundred, 0, ""]
	
	// Frank
	, [205, 0, "talk-205-frank00regular.mp3", [{"time":0,"type1":TalkType.fail,"type2":0},{"time":34,"type1":TalkType.fail,"type2":1}]]
	, [215, 0, "talk-215-frank01tricky.mp3", [{"time":3,"type1":TalkType.fail,"type2":0},{"time":45,"type1":TalkType.fail,"type2":1}]]
	, [225, 0, "talk-225-frank02dead.mp3", [{"time":0,"type1":TalkType.fail,"type2":0}]]
	, [235, 0, "talk-235-frank03frankwakesup.mp3"]
	, [245, 0, "talk-245-frank04jakedidyousay.mp3"]
	, [255, 0, "talk-255-frank05dowejake.mp3"]
	, [265, 0, "talk-265-frank06needthem.mp3", [{"time":8,"type1":TalkType.fail,"type2":1},{"time":18,"type1":TalkType.fail,"type2":0}]]
	, [275, 0, "talk-275-frank07doneworrying.mp3", [{"time":10,"type1":TalkType.fail,"type2":1},{"time":26,"type1":TalkType.fail,"type2":0}]]
	, [285, 0, "talk-285-frank08somethinggoeswrong.mp3"]
	, [295, 0, "talk-295-frank09youdidit.mp3", [{"time":44,"type1":TalkType.fail,"type2":1}]]
	, [299, 0, "talk-299-frank10dontneedjake.mp3", [{"time":13,"type1":TalkType.fail,"type2":0},{"time":20,"type1":TalkType.fail,"type2":1}]]

	, [TalkType2.usethehole, 0, "talk-3000-usethehole.mp3"]
	, [TalkType2.usethehole, 0, "talk-3000-usethehole2-itopened.mp3"]
	, [TalkType2.usethehole, 0, "talk-3000-usethehole3-doyouthink.mp3"]
	, [TalkType2.usethehole, 0, "talk-3000-usethehole4-nevergettired.mp3"]
	, [TalkType2.usethehole, 0, "talk-3000-usethehole5-wevebeenoverthis.mp3"]
	, [TalkType2.usethehole, 0, "talk-3000-usethehole6-nevermind.mp3"]
	, [TalkType2.usethehole, 0, "talk-3000-usethehole7-gotcha.mp3"]
	
	, [TalkType2.songendedearly, 0, "talk-3001-song-ended-early1.mp3"]
	, [TalkType2.songendedearly, 0, "talk-3001-song-ended-early2.mp3"]
	, [TalkType2.songendedearly, 0, "talk-3001-song-ended-early3-playerhateshappy.mp3"]
	, [TalkType2.songendedearly, 0, "talk-3001-song-ended-early4-justjustonce.mp3"]
	
	, [TalkType2.instructions, 0, "talk-3002-instructions0.mp3"]
	, [TalkType2.instructions, 0, "talk-3002-shift.mp3"]
	, [TalkType2.instructions, 0, "talk-3002-spacebar.mp3"]
	
	, [TalkType2.playerusedhole, 0, "talk-3003-player-used-hole1.mp3"]
	, [TalkType2.playerusedhole, 0, "talk-3003-player-used-hole2.mp3"]	
	, [TalkType2.playerusedhole, 0, "talk-3003-player-used-hole3-downtheholeagain.mp3"]

	, [TalkType2.failcountdown10, 0, "talk-3004-bonuscountdown-10.mp3"]
	, [TalkType2.failcountdown25, 0, "talk-3005-bonuscountdown-25.mp3"]
	, [TalkType2.failcountdown50, 0, "talk-3006-bonuscountdown-50.mp3"]
	
	, [TalkType2.addedtilered, 0, "talk-3007-addedtile-red1-jake1.mp3"]
	, [TalkType2.addedtilered, 0, "talk-3007-addedtile-red2-frank.mp3"]
	, [TalkType2.addedtilered, 0, "talk-3007-addedtile-red3-jake2.mp3"]
	, [TalkType2.addedtilered, 0, "talk-3007-addedtile-red4-notasfun.mp3"]
	, [TalkType2.addedtilered, 0, "talk-3007-addedtile-red5-thiswasabadidea.mp3"]	

	, [TalkType2.completed50, 0, "talk-3008-50completed1.mp3"]
	, [TalkType2.completed50, 0, "talk-3008-50completed2.mp3"]
	, [TalkType2.completed50, 0, "talk-3008-50completed3.mp3"]

	, [TalkType2.failfinished, 0, "talk-3009-fail-finished1.mp3"]
	, [TalkType2.failfinished, 0, "talk-3009-fail-finished2.mp3"]
];


function TalkRestart()
{
	/*
	// debug. fill this up with a LOT to test scale
	for (var jimIndex = 0; jimIndex < 500; jimIndex++)
	{
		mTalks[3 + jimIndex] = new Array();
		mTalks[3 + jimIndex][0] = 3 + jimIndex;
		mTalks[3 + jimIndex][1] = mTalks[0][1];
		mTalks[3 + jimIndex][2] = mTalks[0][2];
	}
	console.log("HEYHEY:" + mTalks.length);
	*/

	// Improvement: holdStates NOT needed - replace with mTalkStates
	var holdStates = new Array();
	for (var index = 0; index < mTalkStates.length; index++) { holdStates[index] = mTalkStates[index]; }
	
	var holdText = null;
	var holdIndex = 0;
	for (var index = 0; index < mTalks.length; index++)
	{
		if (index < mTalkIndex)
		{
			// Happens AFTER tiles are built for the level
			if (mTalks[index][3] != null)
			{
				holdText = mTalks[index][3];
				holdIndex = 0;
				while (holdIndex < holdText.length)
				{
					holdStates[holdText[holdIndex].type1] = holdText[holdIndex].type2;
					holdIndex++;
				}
			}

			// Happens BEFORE tiles are built for the level
			if (mTalks[index][4] != null)
			{
				holdText = mTalks[index][4];
				holdIndex = 0;
				while (holdIndex < holdText.length)
				{
					holdStates[holdText[holdIndex].type1] = holdText[holdIndex].type2;
					holdIndex++;
				}
			}
		}
		else
		{
			break;
		}
	}

	for (var index = 0; index < mTalkStates.length; index++) { mTalkStates[index] = holdStates[index]; }		
	mTalkLastDate = 0;
}

function Talk3000Load()
{
	// Set mTalk3000Index
	for (mTalk3000Index = 0; mTalk3000Index < mTalks.length; mTalk3000Index++)
	{
		if (mTalks[mTalk3000Index][0] == TalkType2.start) { break; }
	}

	// Special Talks (in response to events like hole opening) must NEVER EVER REPEAT
	var hold = getCookie("talks");
	if (hold != "")
	{	
		var cookieStates = hold.split(",");
		for (var index = 0; index < cookieStates.length; index++)
		{
			mTalks[mTalk3000Index + index][1] = parseInt(cookieStates[index]);
		}
		console.log("Talk3000Load()\n" + hold);
	}
}

function Talk3000Save()
{
	console.assert(mTalk3000Index > 0, "Talk3000Save Error(): mTalk3000Index <= 0! Talk3000Load() somehow never called, or mTalk3000Index changed.");
	// This talk has been played. Ensure it NEVER plays again.
	var hold = "";
	for (var index = mTalk3000Index; index < mTalks.length; index++)
	{
		hold += mTalks[index][1] + ",";
	}
	console.log("Talk3000Save()\n" + hold.substring(0, hold.length - 1));
	setCookie("talks", hold.substring(0, hold.length - 1));
}

function TalkExists(pIndex)
{
	for (var index = 0; index < mTalks.length; index++)
	{
		if (mTalks[index][0] == pIndex) { return true; }
	}
	return false;
}

function TalkTypeRandomFailSet()
{
	mTalkRandomCountdown = 0;
	mTalkRandomFailState = 0;
	
	if ( (mTalkStates[TalkType.randomFail] > 0) && (mUseTheForceState == 0) )
	{
		var third = parseInt(mTileTotal * 0.33);
		mTalkRandomCountdown = third + parseInt(Math.random() * (third * 1.1));
	}
}

function TalkTypeConcreteBlockSet(pStateType2)
{
	/*
	0 - remove All
	
	1,2,3,4,etc. - how many "hidden" concrete blocks TOTAL you want. note: You can ask for 3, but playfield might only have 2
	999 - every tile EXCEPT hole
	
	-1,-2,-3,-4 - how many "visible" concrete blocks TOTAL you want
	-999 - every tile EXCEPT hole
	*/
	var success = false;

	mTalkStates[TalkType.concreteBlock] = pStateType2;
	// state somewhat unnecessary since it can be calculated from tiles
	// we do NOT want to mTalkStates[TalkType.concreteBlock] elsewhere, focus on the tile.concreteBlock. This will allow us to combine states. 

	var count = 0;
	for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
	{
		if (mPlayFieldDivs[xyIndex].concreteBlock != 0) { count++; }
	}
	let change = Math.abs(mTalkStates[TalkType.concreteBlock]) - count;
	/*
	Cases:
	Existing: 0   TalkType:1   Change:1     (add, leaving 1 concrete tile)
	Existing: 4   TalkType:6   Change:2     (add, leaving 6 concrete tiles)
	Existing: 4   TalkType:2   Change:-2    (subtract, leaving only 2 concrete tiles)
	Existing: 5   TalkType:0   Change:-5    (subtract, removing all concrete tiles)
	*/
		
	if (change > 0)
	{
		var emptySpots = new Array();
		var emptySpotsBad = new Array();
		
		for (var y = 0; y < mTileYCount; y++)
		{	
			for (var x = 0; x < mTileXCount; x++)
			{
				let xyIndex = y * mTileXCount + x;
				if (
					(mPlayFieldDivs[xyIndex].concreteBlock == 0)
					&& (mPlayFieldRemember[xyIndex] == 0)
					&& ((xyIndex) != mRestart.xyIndexRemember)
				)
				{
					// don't want spots disconnected from grid unless we have no choice (999)
					if (EdgeCountRemember(x, y) <= 2) { emptySpots.push(xyIndex); } else { emptySpotsBad.push(xyIndex); }
				}
			}
		}
	
		if (emptySpots.length + emptySpotsBad.length > 0)
		{
			ShuffleArray(emptySpots);
			ShuffleArray(emptySpotsBad);
			emptySpots = emptySpotsBad.concat(emptySpots);

			while ( (emptySpots.length > 0) && (change > 0) )
			{
				var xyIndex = emptySpots.pop();   // takes the LAST spot, which is connected by edge
				if (mTalkStates[TalkType.concreteBlock] < 0)
				{
					mPlayFieldDivs[xyIndex].concreteBlock = -1;
					TileSetColor(mPlayFieldDivs[xyIndex], 192, 255, 192, 1);
				}
				else
				{
					mPlayFieldDivs[xyIndex].concreteBlock = 1;
					TileSetColorTemp(mPlayFieldDivs[xyIndex], 2000 + Math.floor(Math.random() * 2000), 0, 255, 0);
				}
				change--;
				success = true;
			}
		}			
	}
	// </ADD>
	
	// <REMOVE>
	else if (change < 0)
	{
		var concreteSpots = new Array();
		for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
		{
			if (mPlayFieldDivs[xyIndex].concreteBlock != 0) { concreteSpots.push(xyIndex); }
		}
		
		if (concreteSpots.length > 0)
		{
			ShuffleArray(concreteSpots);
			
			while ( (concreteSpots.length > 0) && (change < 0) )
			{
				var xyIndex = concreteSpots.pop();
				mPlayFieldDivs[xyIndex].concreteBlock = 0;
				mPlayFieldDivs[xyIndex].transform.jimWidth = mTileSize2 * 2;
				mPlayFieldDivs[xyIndex].transform.jimHeight = mTileSize2 * 2;
				TileSetColor(mPlayFieldDivs[xyIndex], 255, 255, 0);
				change++;
				success = true;
			}
		}
	}
	// </REMOVE>
	
	if (success)
	{
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundconcreteblockalone);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundconcreteblockhit);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);		
	}
}

function TalkTypeFinishTileSet(pStateType2)
{
	// pStateType2=1   one tile. must end on this tile and CANNOT touch it enroute		
	// pStateType2=2   multiple tiles. must end on one of these and CAN eliminate enroute
	// Note: Levels (JSON or generated) can have 2 answers, hence 2 finalTiles
	// Note: Levels (JSON or generated) can have NO finalTiles because level was to ocmplicated to determine them
	// Note: SolveUpdate continues to add finalTiles 

	// ON - start with huge yellow circles
	if (pStateType2 > 0)
	{
		mTalkStates[TalkType.finishTile] = pStateType2;

		if (mTalkStates[TalkType.finishTile] == 1)
		{
			// One. The shortest/least turn route mSolvedPlayfield[0]! It's actually GOOD for Weekdays
			for (let xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
			{
				if (mSolvedPlayfield[0][xyIndex] == 1)
				{
					if (
						(mPlayField[xyIndex] > 0) 
						&& (mPlayFieldDivs[xyIndex].finalTile > 0) 
						&& (mPlayFieldDivs[xyIndex].finishTileState == 0)
					) { FinishTileAdd(xyIndex); }
				}
			}
		}
		else
		{
			// Multiple.
			let finalTiles = [];

			// More final tiles can still be added by SolveUpdate as it finds Solutions
			for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
			{
				if (
					(mPlayField[xyIndex] > 0) 
					&& (mPlayFieldDivs[xyIndex].finalTile > 0) 
					&& (mPlayFieldDivs[xyIndex].finishTileState == 0)
				)
				{ finalTiles.push(xyIndex); }
			}
			
			if (finalTiles.length > 0)
			{
				ShuffleArray(finalTiles);
				
				let total = (finalTiles.length < 5) ? finalTiles.length : 5;
				for (let index = 0; index < total; index++)
				{
					FinishTileAdd(finalTiles[index], false);
				}
				SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundfinishtile1);
			}
		}
	}

	// OFF - burn out, then fade away
	else
	{
		FinishTileRemoveAll();
		// do this at end. needs to be on for FinishTileRemoveAll(); to work 
		mTalkStates[TalkType.finishTile] = pStateType2;
	}
}


function TalkTypeExtraGenerateRecursive(pExtraIndex)
{
	console.assert(mTileTotalRemember != 0, "TalkTypeExtraGenerateRecursive Error: mTileTotalRemember must be set before calling this. Otherwise SolveUpdate will record bad Answer playfields. mTileTotalRemember == 0");
	
	for (var extraIndex = pExtraIndex; extraIndex < mTileXYCount; extraIndex++)
	{
		if (mPlayFieldDivs[extraIndex].extra > 0)
		{
			console.assert(mPlayField[extraIndex] == 0, "ExtraIndex > 0 on mPlayField! " + pExtraIndex + ":" + extraIndex);

			mPlayField[extraIndex] = 1; mTileTotal++;   // PRETEND it's part of playfield

			mState = 0;
			mState = SolveUpdateStart();
			if (mState != 1) { mState = SolveUpdate(1000 * 90); }

			if ((mState == 1) && (!mStatePushPopped))
			{
				// This tile will 100% cause failure which is what we want!
				// Need to confirm it's okay against every variation of extra checked in case it turns them into solutions (this hurts my brain)
				// (keep pretending and pretending and ensure we always get back fail)
				var hold = extraIndex;
				hold++;
				if (hold < mTileXYCount) { TalkTypeExtraGenerateRecursive(hold); }
			}
			else
			{
				// Fail. This tile might cause a solution, can't use it.
				mTalkTypeExtraRecursiveBreak = 1;
			}	
			
			mPlayField[extraIndex] = 0; mTileTotal--;   // STOP PRETENDING
			
			if (mTalkTypeExtraRecursiveBreak == 1) { break; }
		}
	}
}

function TalkTypeExtraGenerateStart()
{
	// Eventually calls SolveUpdate which mutates many things.
	// Preserve the things you care about before calling this.
	var extraCount = 0;
	var x = -1, y = -1, xyIndex = -1

	for (var index  = 0; index < mPlayFieldDivs.length; index++) { mPlayFieldDivs[index].extra = 0; }
	
	// <GET EMPTY SPOTS>
	var emptySpots = new Array();
	for (var index  = 0; index < mTileXYCount; index++)
	{
		var success = true;
		if (
			(mPlayField[index] == 1)
			|| (mPlayFieldDivs[index].extra > 0)
			|| (index == mRestart.xyIndexRemember)
			|| (mPlayFieldDivs[index].visiblePermanent != 1)
		)
		{
			success = false;
		}

		if (success)
		{
			y = parseInt(index / mTileXCount);
			x = index - (y * mTileXCount);
			if ((y >= mPlayer.top - 1) && (y <= mPlayer.top + 1) && (x >= mPlayer.left - 1) && (x <= mPlayer.left + 1)) { success = false; }
		}
		if (success) { emptySpots.push(index); }
	}
	// </GET EMPTY SPOTS>
		
	// <TRY RANDOM EMPTY SPOT>
	// add the tile and ensure it FAILS, do NOT add another solution
	let dateFailSafe = Date.now();
	var edgeCount = 0;
	for (var tries = 0; tries < 4; tries++)
	{
		ShuffleArray(emptySpots);

		for (var emptySpotIndex = 0; emptySpotIndex < emptySpots.length; emptySpotIndex++)
		{
			// console.log("Try: " + tries + "   Spot:" + emptySpots[emptySpotIndex]); 
			y = parseInt(emptySpots[emptySpotIndex] / mTileXCount);
			x = emptySpots[emptySpotIndex] - (y * mTileXCount);
		
			if (mPlayFieldDivs[y * mTileXCount + x].extra == 0)   // within this loop, extra could have been turned on
			{
				edgeCount = 0;   // is this a piece BETWEEN 2 pieces? Or is it an edge piece?
				if ( (x > 0) && (mPlayField[y * mTileXCount + (x - 1)] == 1) && (mPlayFieldDivs[y * mTileXCount + (x - 1)].extra == 0) ) { edgeCount++; }
				if ( (x < mTileXCount - 1) && (mPlayField[y * mTileXCount + (x + 1)] == 1) && (mPlayFieldDivs[y * mTileXCount + (x + 1)].extra == 0) ) { edgeCount++; }
				if ( (y > 0) && (mPlayField[(y - 1) * mTileXCount + x] == 1) && (mPlayFieldDivs[(y - 1) * mTileXCount + x].extra == 0) ) { edgeCount++; }
				if ( (y < mTileYCount - 1) && (mPlayField[(y + 1) * mTileXCount + x] == 1) && (mPlayFieldDivs[(y + 1) * mTileXCount + x].extra == 0) ) { edgeCount++; }
				if (
					( (edgeCount >= 2) && (tries <= 1) )
					|| ( (edgeCount >= 1) && (tries > 1) )
				)
				{					
					xyIndex = y * mTileXCount + x;
					mPlayFieldDivs[xyIndex].extra = 1;   // do NOT turn mPlayField[XyIndex] on. TalkTypeExtraGenerateRecursive takes care of it.
					mTalkTypeExtraRecursiveBreak = 0;
					TalkTypeExtraGenerateRecursive(0);   // touches mTileTotal and mPlayField, BUT returns them back
					if (mTalkTypeExtraRecursiveBreak == 0)
					{
						extraCount++;
					}
					else
					{
						mPlayFieldDivs[xyIndex].extra = 0;
					}
					
					if ( (extraCount == mTalkStates[TalkType.tileExtra]) || ((Date.now() - dateFailSafe) > 1000 * 180) ) { break; }
				}
			}
		}
		if (
			(extraCount == mTalkStates[TalkType.tileExtra])
			|| ((Date.now() - dateFailSafe) > 1000 * 180)
		) { break; }
	}
	// </TRY RANDOM EMPTY SPOT>

	for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
	{
		console.assert(
			(mPlayFieldDivs[xyIndex].extra == 0)
			|| ((mPlayFieldDivs[xyIndex].extra > 0) && mPlayField[xyIndex] == 0)
			, "TalkTypeExtraGenerateStart() Error: .Extra is on BUT mPlayField != 0 " + xyIndex + ":" + mPlayField[xyIndex]
		);
	}

	return extraCount;
}

function TalkTypeExtraSet(pStateType2, pStart = false)
{
	mTalkStates[TalkType.tileExtra] = pStateType2;
	let extraCount = 0;

	let change = false;
	
	// <TURN ON>
	if (pStateType2 > 0)
	{
		if ( (mLevelIndex > -1) && (mLevels[mLevelIndex][15] != null) )
		{
			let holdExtras = [];
			for (let extraIndex = 0; extraIndex < mLevels[mLevelIndex][15].length; extraIndex++)
			{
				// the first extra elements in the array are better quality (connectors) than later ones (edges)
				// if we're only choosing 1 extra, take it from the first elements
				if (extraIndex >= pStateType2 * 3) { break; } else { holdExtras.push(mLevels[mLevelIndex][15][extraIndex]); }
			}
			ShuffleArray(holdExtras);   // holdExtras has a SELECTION of Extras
		
			for (let extraIndex = 0; extraIndex < holdExtras.length; extraIndex++)
			{
				if (extraIndex >= pStateType2)
				{
					break;
				}
				else
				{
					let xyIndex = holdExtras[extraIndex];
					console.assert(mPlayField[xyIndex] == 0, "LevelFileIntoMemory Error: Extra '" + xyIndex + "' tile already exists on Playfield!");
					mPlayFieldDivs[xyIndex].extra = 1;
					mPlayField[xyIndex] = 1;
					mPlayFieldRemember[xyIndex] = 1;
					extraCount++;
					change = true;
					// Player can move onto this tile (instant fail), SolveUpdate is UNAWARE of it, will NOT increase/decrease size of playing field (too complicated to support that)
				}
			}
			if (change) { StatTopLeftRefresh(); }
		}
	}
	// </TURN ON>
	
	// <TURN OFF>
	else
	{
		for (var xyIndex  = 0; xyIndex < mTileXYCount; xyIndex++)
		{
			var tile = mPlayFieldDivs[xyIndex];
			if (tile.extra > 0)
			{
				tile.extra = 0;
				mPlayField[xyIndex] = 0;   // it might already be at zero (player walked over it), but harmless to remove
				mPlayFieldRemember[xyIndex] = 0;
				// do NOT change mTileTotal nor mPlayFieldRemember, .extra was NEVER part of it.
				
				// they shrink away...
				tile.transform.jimWidth = mTileSize2 * 2;
				tile.transform.jimHeight = mTileSize2 * 2;
				TileSetColor(tile, 255, 255, 0);
				change = true;
			}
		}
	}
	// <TURN OFF>

	if (change)
	{
		backgroundR = 255; backgroundG = 128; backgroundB = 255;
		document.body.style.backgroundColor = RGBToHex(parseInt(backgroundR), parseInt(backgroundG), parseInt(backgroundB));
		StatTopLeftRefresh();
	}
}

function TalkTypeInvisibleSet(pStateType2, pStart = false)
{
	// pStateType2 - number we want to turn off (additive)
	mTalkStates[TalkType.tileInvisible] = pStateType2;

	var missingCount = 0;
	if (pStart)
	{
		// Prevous level had invisible tiles. Make them visible again, THEN set new ones to invisible
		for (var index = 0; index < mPlayFieldDivs.length; index++)
		{
			mPlayFieldDivs[index].visibleState = 1;
			mPlayFieldDivs[index].visiblePermanent = 1;
		}
	}
	else
	{
		for (var index = 0; index < mTileXYCount; index++)
		{
			if (mPlayFieldDivs[index].visiblePermanent != 1) { missingCount++ }
		}
	}
	
	let change = false;
	let diff = mTalkStates[TalkType.tileInvisible] - missingCount;

	// <TURN ON>
	if (diff < 0)
	{

		// Make some/all visible
		for (var index = 0; index < mTileXYCount; index++)
		{
			if (mPlayFieldDivs[index].visiblePermanent != 1)
			{
				let tile = mPlayFieldDivs[index];
				TileSetColorTemp(tile, 2000, 255, 255, 0);   // come back yellow for 2 seconds
				tile.visibleState = 1;
				tile.visiblePermanent = 1;
				tile.transform.jimWidth = mTileSize2 * 2;
				tile.transform.jimHeight = mTileSize2 * 2;
				change = true;
				diff++; if (diff == 0) { break; }
			}
		}
	}
	// <TURN ON>

	else if (diff == 0)
	{
		// console.assert(1 == 0, "TalkTypeInvisibleSet() - called BUT no change in invisible tile count:" + mTalkStates[TalkType.tileInvisible]);
	}

	// <TURN OFF>
	else
	{
		if (pStart) {  }   // Talk mp3 would usually play this sound
	
		var emptySpots = new Array();
		for (var index  = 0; index < mTileXYCount; index++)
		{
			var success = true;
			if (
				(mPlayField[index] == 0)
				|| (index == mPlayer.xyIndex)
				|| (mPlayFieldDivs[index].extra != 0)
				|| (mPlayFieldDivs[index].visiblePermanent != 1)
			)
			{
				success = false;
			}

			if (success) { emptySpots.push(index); }
		}
		ShuffleArray(emptySpots);

		if (diff > emptySpots.length) { diff = emptySpots.length; }
		for (var count = 0; count < diff; count++)
		{
			if (!change) { SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundzaplong);	}
			let tile = mPlayFieldDivs[emptySpots[count]];
			TileSetColor(tile, 255, 255, 0);
			tile.visibleState = 1;
			mPlayFieldDivs[emptySpots[count]].visiblePermanent = -1;   // TilesUpdate() will flicker this tile away (and .visiblePermanent becomes 0)
			change = true;
		}
	}
	// <TURN OFF>

	if (change)
	{
		backgroundR = 128; backgroundG = 128; backgroundB = 255;
		document.body.style.backgroundColor = "RGB(" + parseInt(backgroundR) + "," + parseInt(backgroundG) + "," + parseInt(backgroundB) + ")";
		StatTopLeftRefresh();
	}
}

function TalkTypeFailSet(pStateType2, pFlash = true)
{
	mTalkStates[TalkType.fail] = pStateType2;
	if (mTalkStates[TalkType.fail] == 1)
	{
		// Turn Tiles ON
		var tile = null;
		for (var index = 0; index < mTileXYCount; index++)
		{
			if (mPlayField[index] > 0)
			{
				tile = mPlayFieldDivs[index];
				if (mUrineState > 0)
				{
					tile.colorRFinal = 255;
					tile.colorGFinal = 255;
					tile.colorBFinal = 192;
				}
				else
				{
					tile.colorRFinal = 255;
					tile.colorGFinal = 255;
					tile.colorBFinal = 255;
				}

				if (pFlash)
				{
					TileSetColorTemp(tile, 1000 + parseInt(Math.random() * 1000), 255, 255, 0);
				}
			}
		}

		if ((mMusic != null) && (mMusic.talkIndex == -1))
		{
			mMusic.playbackRate = 1;
			mMusicGain.gain.value = mMusic.rememberVolume;
		}
	}
	else
	{
		// Turn Tiles OFF
		console.log("Turn Tiles Off!");
		var tile = null;
		for (var index = 0; index < mTileXYCount; index++)
		{
			if (mPlayField[index] > 0)
			{
				tile = mPlayFieldDivs[index];
				TileSetColor(tile, 192, 192, 192, 1);

				if (pFlash)
				{
					TileSetColorTemp(tile, 1000 + parseInt(Math.random() * 4000), 255, 0, 0);
				}
			}
		}	

		if ((mMusic != null) && (mMusic.talkIndex == -1))
		{	
			mMusic.playbackRate = 0.4;
			mMusicGain.gain.value = mMusic.rememberVolume * 0.15;
		}
	}
}

function TalkTypeLightControlPlayer()
{
	if ((mTalkStates[TalkType.light] == 0) && (mTalkStates[TalkType.control] == 0))
	{
		mPlayer.div.style.filter = "invert(55%)";	

	}
	else if ((mTalkStates[TalkType.light] == 0) || (mTalkStates[TalkType.control] == 0))
	{
		mPlayer.div.style.filter = "invert(75%)";
	}
	else
	{
		mPlayer.div.style.filter = "";
	}
}

function TalkTypeLightSet(pStateType2)
{
	mTalkStates[TalkType.light] = pStateType2;
	TalkTypeLightControlPlayer();
	if (mTalkStates[TalkType.light] == 0)
	{
		mWord.style.display = "none";
		document.body.style.backgroundImage = "";
		for (var index = 0; index < mPlayback.players.length; index++)
		{
			mPlayback.players[index].div.style.opacity = 0.1;
		}
		for (var index = 0; index < mSpots.spots.length; index++)
		{
			mSpots.spots[index].div.style.opacity = 0.1;
		}
		mStatTopLeftDiv.style.display = "none";
		mStatTopRightDiv.style.display = "none";
		mStatBottomLeftDiv.style.display = "none";
		mStatBottomRightDiv.style.display = "none";
	}
	else
	{
		mWord.style.display = "";
		CurtainRefresh();
		for (var index = 0; index < mPlayback.players.length; index++)
		{
			mPlayback.players[index].div.style.opacity = 1;
		}		
		for (var index = 0; index < mSpots.spots.length; index++)
		{
			mSpots.spots[index].div.style.opacity = 1;
		}
		mStatTopLeftDiv.style.display = "";
		mStatTopRightDiv.style.display = "";
		mStatBottomLeftDiv.style.display = "";
		mStatBottomRightDiv.style.display = "";
	}
}

function TalkTypeControlSet(pStateType2)
{
	mTalkStates[TalkType.control] = pStateType2;
	TalkTypeLightControlPlayer();
	if (mTalkStates[TalkType.control] == 0)
	{
		mPlayer.transform.jimHeight *= 0.25;
		mPlayer.transform.jimWidth *= 0.25;
	}
	else
	{
		mPlayer.transform.jimHeight *= 2;
		mPlayer.transform.jimWidth *= 2;
	}
}

function TalkPlayPrivate(pIndex)
{
	console.assert(mMusic.talkIndex == -1, "TalkPlayPrivate() Error: Talk '" + pIndex + "' NEEDS to play, but would cutoff/overlap another IMPORTANT talk '" + mMusic.src + "'");

	// if we're interrupting music (final level), remember where we were
	if (mMusic.currentTime != 0)
	{
		mTalkCurrentTimeRemember = mMusic.currentTime;
		console.log("TalkPlayPrivate mTalkCurrentTimeRemember:" + mTalkCurrentTimeRemember + " mMusic.src:" + mMusic.src);
	}

	mMusic.talkIndex = pIndex;
	 
	mMusic.pause();
	mMusic.currentTime = 0;
	
	mMusic.src = mTalks[mMusic.talkIndex][2];
	mMusic.loop = false;
	mMusic.rememberVolume = 0.25;
	mMusicGain.gain.value = 0.25;

	if (mTalks[mMusic.talkIndex][3] != null)
	{
		mMusic.talkJSON = mTalks[mMusic.talkIndex][3];
		mMusic.talkJSONIndex = 0;
	}
	else
	{
		mMusic.talkJSON = "";
		mMusic.talkJSONIndex = -1;	
	}

	mMusic.play();
}

function TalkPlay3000(pID)
{
	console.assert(pID >= TalkType2.start);
	if (mWorldMode > 0) { return; }

	// If another talk is playing (or JUST finished playing), ignore this request
	if (
		(mMusic.talkIndex == -1)
		&& ( (mTalkLastDate == 0) || (Date.now() - mTalkLastDate > 1000 * 15) )   // Interjections need to happen QUICKLY after a talk, or they'll never happen
	)
	{
		for (var index = mTalk3000Index; index < mTalks.length; index++)
		{
			if ( 
				(pID == mTalks[index][0])
				&& (mTalks[index][1] == 0)
				&& (mTalks[index][2] != null)
				&& (mTalks[index][2] != "")
			)
			{
				TalkPlayPrivate(index);
				break;
			}
		}
	}
}

function TalkStop3000(pTalkLastDate = -1)
{
	if (mMusic.talkIndex >= mTalk3000Index)
	{
		mTalks[mMusic.talkIndex][1] = 1;
		Talk3000Save();	// NEVER play this Talk again
		mTalkLastType3000 = true;
		if (pTalkLastDate == -1) { mTalkLastDate = Date.now(); } else { mTalkLastDate = pTalkLastDate; }
		mMusic.talkIndex = -1;
	}
}

function TalkPlay1(pIndex)
{
	console.assert(pIndex < mTalk3000Index);
	console.assert(mMusic.talkIndex == -1, "TalkPlay1() Error: Talk '" + pIndex + "' NEEDS to play, but would cutoff/overlap another IMPORTANT talk '" + mMusic.src + "'");
	console.assert(mTalkLastDate == 0, "TalkPlay1() Error: Talk '" + pIndex + "' NEEDS to play, but timer hasn't finished from the previous talk");
	TalkPlayPrivate(pIndex);
}

function TalkStop1()
{
	// If Talk3000 (interjection) is going, stop it. This can't happen with Talk1
	if ((mMusic.talkIndex > -1) && (mMusic.talkIndex < mTalk3000Index))
	{
		// mTalks[mMusic.talkIndex][1] = 1;
		// Talk3000Save();	// NEVER play this Talk again
		mTalkLastType3000 = false;
		mTalkLastDate = Date.now();
		mMusic.talkIndex = -1;
	}
}



// ---------------------------------------------------------------------------------------------------------------------
// <STUFF>
// ---------------------------------------------------------------------------------------------------------------------

var mFranks = [
	[205, "music-frank00regular.mp3", [1, 1, 0, 34]]
	, [215, "music-frank01tricky.mp3", [1, 1, 3, 45]]
	, [225, "music-frank02dead.mp3", [1, 2, 0]]
	, [235, "music-frank03frankwakesup.mp3", null]
	, [245, "music-frank04jakedidyousay.mp3", null]
	, [255, "music-frank05dowejake.mp3", null]
	, [265, "music-frank06needthem.mp3", [2, 2, 8, 18]]
	, [275, "music-frank07doneworrying.mp3", [2, 2, 10, 26]]
	, [285, "music-frank08somethinggoeswrong.mp3", null]
	, [295, "music-frank09youdidit.mp3", [2, 1, 44]]
	, [299, "music-frank10dontneedjake.mp3", [1, 1, 13, 20]]
];

function FrankWordUpdate()
{
	/*
	WordShow("FRANK<BR>AND<BR>JAKE", "#000000", "#0000FF", 1.5, 2000 + 1500);
	SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
	console.log("FrankFinish " + Date.now());
	*/
	var total = mStatNewFrankWin + mStatNewFrankLoss + 1;

	if (mWorldRepeatCount >= 3)
	{
		mWord.innerHTML = "FRANK<BR>SAYS<BR>RELAX";
	}
	else
	{
		if (total == 201)
		{
			mWord.innerHTML = "FRANK<BR>AND<BR>JAKE";
		}
		else if (total == 202)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "JAKE'S A GUY<BR>WITH A WRENCH ...";
			}
			else
			{
				mWord.innerHTML = "... AND A DREAM";
			}		
		}
		else if (total == 203)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "FRANK'S SMART ...";
			}
			else
			{
				mWord.innerHTML = "... TOO SMART";
			}		
		}
		else if (total == 204)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "TOGETHER<BR>THEY KEEP<BR>THIS GAME RUNNING";
			}
			else
			{
				mWord.innerHTML = "OR AT LEAST<BR>TRY TO";
			}		
		}	
		else if (total == 208)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "THE ONLY THING<BR>KEEPING THIS GAME ALIVE ...";
			}
			else
			{
				mWord.innerHTML = "IS INCOMPETENT JAKE<BR>AND GIANT ASS FRANK";
			}
		}
		else if (total == 218)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "SORRY ABOUT<BR>THE SWEARS";
			}
			else
			{
				mWord.innerHTML = "TRULY<BR>FUCKING<BR>SORRY";
			}
		}
		else if (total == 227)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "FRANK'S<BR>DEAD";
			}
			else
			{
				mWord.innerHTML = "FRANK'S<BR>FUCKING<BR>DEAD";
			}
		}
		else if (total == 228)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "FUCKING<BR>FRANK'S<BR>DEAD";
			}
			else
			{
				mWord.innerHTML = "FUCKING<BR>FRANK'S<BR>FUCKING<BR>DEAD";
			}
		}
		else if (total == 229)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "FUCKING<BR>FRANK'S<BR>FUCKING<BR>FUCKING<BR>DEAD";
			}
			else
			{
				mWord.innerHTML = "FRANK'S<BR>FUCKING<BR>FUCK FUCK<BR>FUCKING FUCK<BR>FRANK DEAD";
			}
		}
		else if (total == 238)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "FRANK'S<BR>ALIVE!";
			}
			else
			{
				mWord.innerHTML = "GIANT ASS FRANK<BR>IS ALIVE!";
			}	
		}
		else if (total == 248)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "JAKE<BR>HAS TROUBLE<BR>EXPRESSING HIS FEELINGS";
			}
			else
			{
				mWord.innerHTML = "THERE'S A LITTLE JAKE<BR>IN ALL OF US";
			}	
		}
		else if (total == 258)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "FRANK'S<BR>NOT GOING<BR>TO FIX THINGS";
			}
			else
			{
				mWord.innerHTML = "CUZ<BR>FRANK'S<BR>A<BR>GIANT<BR>ASS";
			}	
		}
		else if (total == 268)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "IT >WAS<<BR>INCREDIBLY EASY<BR>TO FIX";
			}
			else
			{
				mWord.innerHTML = "WHAT<BR>A<BR>GIANT<BR>ASS";
			}	
		}
		else if (total == 278)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "PRETTY CONFIDENT<BR>FRANK MEANT TO SAY JAKE";
			}
			else
			{
				mWord.innerHTML = "NEXT TIME<BR>WE'LL USE<BR>A SCRIPT";
			}	
		}
		else if (total == 288)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "THAT";
			}
			else
			{
				mWord.innerHTML = "DID<BR>NOT<BR>SOUND<BR>GOOD";
			}	
		}
		else if (total == 296)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "CAN YOU<BR>BELIEVE<BR>JAKE HIT IT!?";
			}
			else
			{
				mWord.innerHTML = "JAKE'S<BR>THE<BR>BEST";
			}	
		}
		else if (total == 297)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "WE ARE ALMOST<BR>AT THE END<BR>OF FRANK AND JAKE";
			}
			else
			{
				mWord.innerHTML = "I'M GONNA MISS<BR>THESE TWO BUFFOONS";
			}	
		}
		else if (total == 298)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "FRANK AND JAKE<BR>ARE ALL OF US";
			}
			else
			{
				mWord.innerHTML = "BUT WHAT<BR>WAS JAKE'S WRENCH?";
			}
		}
		else if (total == 299)
		{
			if (mTileTotal > mTileTotalRemember * 0.25)
			{
				mWord.innerHTML = "SAY GOODBYE<BR>TO FRANK AND JAKE";
			}
			else
			{
				mWord.innerHTML = "TWO LOVERS<BR>WHO HAVE NOTHING<BR>IN COMMON";
			}	
		}
		else
		{
			mWord.innerHTML = "LEVEL<BR>" + total.toLocaleString();
		}
		
		
		if (mTileTotal <= 2)
		{
			mWord.innerHTML = total.toLocaleString();
		}
	}
	
	mWord.shakeRatio = 0.0;
	mWord.style.zIndex = 1;
	mWord.fontRatio = 1; 
	mWord.jimColor = "#000000";
	mWord.textShadowColor = "#0000FF66";
	mWord.jimOpacity = 1;						
}

// ---------------------------------------------------------------------------------------------------------------------
// <VARIABLES>
// ---------------------------------------------------------------------------------------------------------------------
var mWorldState = 0;   // 3 States: 0=Building (game can't start, key/mousetouch events are ignored)   1=Playing   2=Complete
var mWorldState2Action = 0;   // WorldState is 2/Complete, but what should we do? Urine introduced ambiguity
	// 0=mWorldState!=2   1=(not in use)   2=Normal Ending (success or hole)   3=Repeat 
var mWorldStateAlive = 0;   // This switches us to next level (above do NOT)

var mState = 0;   // 3 States: 0=Checking if puzzle can be solved   1=FAIL/RED (also means no solution to this level)   2=SUCCESS! Puzzle CAN be solved

var mWeekdayLevelsRemaining = -1;   // 2024-09-30 Weekday. How many levels remaining (calculated from mLevels[mLevelIndex][3])

var mLevelIndex = -1;   // 2024-07-29 REMOVE. It's NEEDLESS and MISLEADING (statDivWin + statDivLoss is REAL). When Story is moved to permanent 300 return here.
var mFinishxyIndex = -1;
var mUseTheForceStateWait = 0;

var mScoreUpdated = 0;

var mGrowCount = 0;
var mGrowDie = false;
var mGrowWordTileTotal = 0;

var mSolveUpdateColorFlag = false;

var mUrineState = 0;   // -1-we went in the hole BUT the level could be completed   0-level not in urine state   1-urinestate BUT level is impossible   2-urinestate BUT level is possible

var mUseTheForceState = 0;   // player might be asked to repeat without help. 1=we're repeating 2=we failed the repeat 3=Repeat PERFECTLY (BOSS only)

var mMilestoneRollers = null;

var mDebugMode = 0;
var mPlayback = null;
var mSpots = null;

var mWorldDiv = null;
var mWorldUpdateTitleRunning = 0;

var mSolveUpdateCount = 0;
var mSolveCrazyPlayFields = null;
var mStatePushPopped = false;
var mSolveStart = 0;

var mSolvedPlayfield = null;   // Array of two PLAYFIELDS 
var mSolvedPlayfieldTurn = null;   // Array of two NUMBERS - lowest and highest (could be calculated from above)

var mSolvedPlayfield2 = null;
var mSolvedPlayfield2Turn = 0;

var mSolutions = 0;
var mSolutionsFileRemember = 0;
var mSolveStatTitle = "";
var mSolveStatAttempt = 0;
var mSolveUpdateDate = 0;   // After player moves, wait 1 second before unleashing full recursive SolveUpdate check

var mWorldType = 0;
var mWorldExtreme = false;
var mWorldShadowType = 0;
var mWorldFlipped = false;   // playfield dynamically switches from portrait to landscape
var mWorldWidth = -1, mWorldHeight = -1;
var mWorldDeltaX = -1, mWorldDeltaY = -1;
var mWorldRepeatCount = 0;
var mWorldResetUpdateCount = 0;   // used by WorldResetUpdate() if background tiles are shown (so cleanup required)
var mWorldResetCheckFailsafe = 0;   // used by WorldResetCheck() - browser can silently run out of memory (and get stuck) if event takes to long to finish

var mWorldTypeCounter = -1;
var mWorldTypeBonusCounter = -1;
var mWorldTypeMilestoneCounter = -1;

var mHistoryPopIndex = 0, mHistoryPushIndex = 0;
var mHistoryxyIndexes = null, mHistoryCounts = null;
var mHistoryTurns = null;

var mWord = null;
var mWordCurtain = null;   // When menu displays, the curtain appears blocking everything behind It   zIndex:15
var mWordCurtainImage = null;   // When menu:about displays, shows image on top of curtain   zIndex:16
var mSensitivity = null;
var mRestart = null;

var mPlayer = null;

// NO level can be bigger than 23 x 23 (0 - 22) (on mobile 24+ is hard to see). ChangeTileCount(23, 23) is the MAX. 2^(23x23) possibilities.
// 80,000 23x23 arrays are pre-allocated.
var mTileXMax = 23, mTileYMax = 23;
var mTileXCount = 0, mTileYCount = 0, mTileXYCount = 0;
function ChangeTileCount(pTileXCount, pTileYCount) { mTileXCount = pTileXCount; mTileYCount = pTileYCount; mTileXYCount = mTileXCount * mTileYCount; }
var mTileTotal = 0;
var mTileTotalRemember = 0;

var mPlayField = null;   // initialized once at worst cast 17x17 - only 1x1 to 16x16 can be used, NMUST be sorrounded be zeroes
var mPlayFieldDivs = null;
var mAStarPlayField = null;
var mAStarxyIndexes = null;
var mPlayFieldExtraPreserve = null;

var mPlayFieldRemember = null;   // if player dies and resets, this copies relevant part of mPlayField array 
var mRememberPlayerXYIndex = -1;

var mTileSize = 0, mTileSize2 = 0;

var backgroundR = 0, backgroundG = 0, backgroundB = 0;


var mButtonCloseDiv = null;

var mStatTopLeftDiv = null;
var mStatTopRightDiv = null;
var mStatBottomLeftDiv = null;
var mStatBottomRightDiv = null;

// calculated while playing, displayed top-right
var mStatNewSolution = 0;

// Weekday (permanently saved)
var mStatNewTime = 0;
var mStatNewSteps = 0;
var mStatNewFail = 0;
var mStatNewFailRemember = -1;

// Frank's Story (permanently saved)
var mStatNewFrankWin = -1;    // Cookied. replaces mStatWinDiv Stat object
var mStatNewFrankWinRemember = -1;
var mStatNewFrankLoss = -1;   // Cookied. replaces mStatLossDiv Stat object
var mStatNewFrankLossRemember = -1;

var mTilesUpdatePlayerxyIndex = -1;

var mAudioContext = null;
var mMusic = null;
var mMusicSource = null;
var mMusicGain = null;

var mSoundBufferState = 0;
var mSoundBuffers = null;

var mSoundBufferHop = null;
var mSoundBufferGah = null;
var mSoundBufferUgh = null;
var mSoundBufferMisc = null;
var mSoundBufferTick = null;
var mSoundBufferAh = null;
var mSoundBufferSwish = null;

var SoundBufferMiscType = null;

var requestPointerLock = 0;
function lockChangeAlert() {
	// https://mdn.github.io/dom-examples/pointer-lock/
  if (document.pointerLockElement === document.body || document.mozPointerLockElement === document.body)
  {
	console.log('pointer locked');
	requestPointerLock = 1;
  }
  else
  {
    console.log('pointer unlocked');
	requestPointerLock = 0;
  }
}

function SensitivityShow()
{
	var w = parseInt(window.innerWidth), h = parseInt(window.innerHeight);

	// .exponent range: 0 - 5	
	// 2^0 = 1  * 0.2 = 0.2
	// 2^1 = 2  * 0.2 = 0.4
	// 2^2 = 4  * 0.2 = 0.8
	// 2^3 = 8  * 0.2 = 1.6
	// 2^4 = 16 * 0.2 = 3.2
	// 2^5 = 32 * 0.2 = 6.4
	
	var width = parseInt( (0.1 + mSensitivity.exponent * (0.8 / 5)) * w );   // min:0.1 max:0.9
	mSensitivity.style.width = width + "px";
	mSensitivity.style.height = parseInt(h * 0.05) + "px";
	mSensitivity.style.left = parseInt((w - width) * 0.5) + "px";
	mSensitivity.style.top = "10px";
	mSensitivity.alive = Date.now() + 4000;
	mSensitivity.style.display = "";
}

function SensitivityUpdate()
{
	if (mSensitivity.alive != 0)
	{
		if (Date.now() > mSensitivity.alive)
		{
			mSensitivity.style.display = "none";
		}
	}
}


// ---------------------------------------------------------------------------------------------------------------------
// <SOUND>
// ---------------------------------------------------------------------------------------------------------------------
function SoundBuffersStop()
{
	// Call sparingly, sounds are all short and end quickly anyway (app loses focus)
	for (var index = 0; index < mSoundBuffers.length; index++)
	{
		if (mSoundBuffers[index] != null) { mSoundBuffers[index].stop(); mSoundBuffers[index] = null; }
	}
}

/*
BROKEN NEEDS WORK/FINISHING
function SoundBufferStop(pSoundBuffer, pIndex = -1)
{
	for (var index = 0; index < mSoundBuffers.length; index++)
	{
		if ((mSoundBuffers[index] != null) && (mSoundBuffers[index].pIndex == pIndex))
		{		
			mSoundBuffers[index].stop(); mSoundBuffers[index] = null;
		}
	}
	// pSoundBuffer[pIndex].stop();
	// pSoundBuffer[pIndex] = null;
}
*/

function SoundBufferPlay(pSoundBuffer, pVolume = 1, pIndex = -1, pType = 0)
{
	/*
	pType
	1 - player tick
	2 - playback hop
	3 - playback ahhhh
	4 - playback augh
	5 - player swish
	6 - blink
	*/
	
	if (mSoundBufferState == 0) { return; }
	// *** Consider making 3 global gains to choose from (1, 0.5, 0.25, 0.125) - TEST exponential really results in a CONSISTENT difference
	// You CANNOT change .buffer of AudioBufferSourceNode (from CreateBufferSource). i.e. Can't create six and change their .buffer
	// Rather than create 30 AudioBufferSourceNode and pool those, I'm just creating and destroying - apparently AudioBufferSourceNode have little overhead

	if (mMusic.talkIndex != -1)
	{
		// Workers are talking
		pVolume *= 0.45;
	}
	else if ((mMusic.currentTime > 0) && (!mMusic.loop))
	{
		// Happy Hollows song playing
		pVolume *= 0.15;
	}

	if (pType > 0)
	{
		var count = 0;
		for (var index = 0; index < mSoundBuffers.length; index++)
		{
			if ( (mSoundBuffers[index] != null) && (mSoundBuffers[index].type == pType) ) { count++; }
		}
		if (count > 2) { return; }
	}

	var index = 0;
	for (index = 0; index < mSoundBuffers.length; index++)
	{
		if (mSoundBuffers[index] == null) { mSoundBuffers[index] = mAudioContext.createBufferSource(); break; }
	}
	// overwrite the OLDEST sound
	if (index == mSoundBuffers.length)
	{
		var overwriteIndex = 0;
		for (index = 1; index < mSoundBuffers.length; index++)
		{	
			console.assert(mSoundBuffers[index] != null);
			if (mSoundBuffers[index].time < mSoundBuffers[overwriteIndex].time) { overwriteIndex = index; }
		}
		console.assert(overwriteIndex != -1);

		index = overwriteIndex;
		mSoundBuffers[index].stop();
		mSoundBuffers[index] = null;
		mSoundBuffers[index] = mAudioContext.createBufferSource();
	}

	// <PLAY>
	console.assert(index < mSoundBuffers.length);
	{ var holdIndex = index; mSoundBuffers[index].onended = function () { mSoundBuffers[holdIndex] = null; } }

	var gainNode = mAudioContext.createGain()
	gainNode.gain.value = pVolume;
	gainNode.connect(mAudioContext.destination)

	// now instead of connecting to aCtx.destination, connect to the gainNode
	mSoundBuffers[index].connect(gainNode); // mAudioContext.destination);
	
	mSoundBuffers[index].pIndex = pIndex;
	if (pIndex == -1)
	{
		mSoundBuffers[index].buffer = pSoundBuffer[parseInt(Math.random() * pSoundBuffer.length)];
	}
	else
	{
		mSoundBuffers[index].buffer = pSoundBuffer[pIndex];		
	}

	// gives variety BUT sounds altered. variety achieved instead by multiple recordings of the same thing
	// also like "fail" sounding EXACTLY the same every time
	// if (pType == 0) { mSoundBuffers[index].playbackRate.value = 0.9 + 0.03 * Math.floor(Math.random() * 8); } else { mSoundBuffers[index].playbackRate.value = 1; }
	mSoundBuffers[index].playbackRate.value = 1;

	mSoundBuffers[index].type = pType;
	mSoundBuffers[index].time = Date.now();

	mSoundBuffers[index].loop = false;
	mSoundBuffers[index].start(0);
	// </PLAY>
}

function SoundBufferFill(pFunctionComplete, pSoundBuffer, pFileNames)
{
	// https://dobrian.github.io/cmp/topics/sample-recording-and-playback-with-web-audio-api/1.loading-and-playing-sound-files.html
	function getData(pIndex)
	{
		pSoundBuffer[pIndex] = mAudioContext.createBufferSource();

		var request = new XMLHttpRequest();
		request.open('GET', pFileNames[pIndex], true);
		request.responseType = 'arraybuffer';

		function process(buffer)
		{
			pSoundBuffer[pIndex] = buffer;
			pIndex++;
			if (pIndex < pSoundBuffer.length)
			{
				getData(pIndex);
			}
			else
			{
				if (pFunctionComplete) { pFunctionComplete(); }
			}
		}

		request.onload = function()
		{
			mAudioContext.decodeAudioData(request.response, process);
		}
		
		request.send();   // calls .onload when complete
	}
	getData(0);
}

function MusicStop()
{
	// Boss level (unlike other special music levels) gets 3 tries.
	// Fail stops music from playing - BUT preserve where it stopped so we can resume from there
	if (mMusic.talkIndex == -1)
	{
		if ((mLevelType == LevelType.Boss) && (mMusic.currentTime != 0)) { mTalkCurrentTimeRemember = mMusic.currentTime; }	
		mMusic.pause();
		mMusic.currentTime = 0;
		// mMusic.src = "";   // causes "fail" to stop playing on mobile Safari, must be a valid path
		mMusic.src = "sound-pop.mp3";
		mMusic.rememberVolume = 1;		
	}
	if (mLevelType != LevelType.Boss) { mTalkCurrentTimeRemember = 0; }
}

function MusicPlay(pSrc, pVolume = 1.0, pLoop = true)
{
	console.assert(pSrc.indexOf("talk") == -1, "MusicPlay() Error: It's trying to play a TALK!");
	console.assert(pSrc != "", "MusicPlay() Error: pSrc required!");
	
	if (
		(mMusic.talkIndex == -1)   // we don't allow Talks to override interjections
		&& (mMusic.src.indexOf(pSrc) == -1)   // music is already playing, do NOT restart
	)
	{
		mMusic.pause();
		mMusic.currentTime = 0;
		mMusic.src = pSrc; // document.getElementById(pSrc).src;
		try
		{
			if (mTalkCurrentTimeRemember != 0)
			{
				mMusic.currentTime = mTalkCurrentTimeRemember;
				SoundBufferPlay(mSoundBufferSwish, 1.0, -1, 5);
				mTalkCurrentTimeRemember = 0;
			}
		}
		catch (err) { ; }
		mMusic.loop = pLoop;
		mMusic.rememberVolume = pVolume;
		// mMusic.volume = 0; // works on Chrome desktop, but NOT on iPhone Safari			

		if ((mMusic != null) && (mMusic.talkIndex == -1))
		{
			if (mTalkStates[TalkType.fail] == 0)
			{
				mMusic.playbackRate = 0.4;
				mMusicGain.gain.value = pVolume * 0.15;
			}
			else
			{
				mMusic.playbackRate = 1;
				mMusicGain.gain.value = pVolume;
			}
		}

		mMusic.play();
	}
}


function MusicSelect()
{
	if ( (mMusic.talkIndex == -1) && (mState != -1) )
	{
		// Something must always be playing ... decide what!
		if (mWorldState == 0)
		{
			MusicPlay("music-song4-construction.mp3", 0);   // DEBUGJIM. Song >appears< to keep browser window alive when focus lost.
		}
		else if ( (mWorldMode == 1) && (mWeekdayLevelsRemaining == 1) )
		{
			let songIndex = -1;
			if (mWorldDayOfWeek < 7)
			{
				if (mWorldDayOfWeek == 0) { songIndex = 0; }
				else if ((mWorldDayOfWeek == 1) || (mWorldDayOfWeek == 4)) { songIndex = 1; }
				else if ((mWorldDayOfWeek == 2) || (mWorldDayOfWeek == 5)) { songIndex = 2; }
				else if ((mWorldDayOfWeek == 3) || (mWorldDayOfWeek == 6)) { songIndex = 3; }
			}
			else
			{
				songIndex = (mWorldDayOfWeek % 4); // Math.floor(Math.random() * 4);
			}
			switch (songIndex)
			{
			case 0: MusicPlay("music-song9-silver.mp3", 0.3, false); break;
			case 1: MusicPlay("music-song5-concordia.mp3", 0.75, false); break;
			case 2: MusicPlay("music-song1-choplifter.mp3", 0.4, false); break;
			case 3: MusicPlay("music-song0-endless.mp3", 0.3, false); break;
			}
		}
		else if (mLevelType == LevelType.OneHundred)
		{
			MusicPlay("music-song9-silver.mp3", 0.3, false);   // pLoop:False BECAUSE onEnded doesn't happen when music looped
		} 
		else if (mLevelType == LevelType.MileStone)
		{
			MusicPlay("music-song5-concordia.mp3", 0.75, false);
		} 
		else if (mLevelType == LevelType.Boss)
		{
			MusicPlay("music-song1-choplifter.mp3", 0.4, false);
		}
		else if (mLevelType == LevelType.Bonus)	
		{
			MusicPlay("music-song0-endless.mp3", 0.3, false);
		}
		else if (mUrineState != 0)
		{
			MusicPlay("music-song8-urineurout.mp3", 0.3);
		}
		else if (mUseTheForceState != 0)
		{
			MusicPlay("music-song7-246198-usetheforce.mp3", 0.15);			
		}
		else if (mLevelType == LevelType.Tricky)
		{
			MusicPlay("music-song2-nonsense.mp3", 0.4, parseInt(Math.random() * 30));
		}
		else
		{
			if (
				(mMusic.currentTime == 0)
				|| (mMusic.src.indexOf("music-song3-547545-scotland.mp3") == -1)
				|| (mMusic.src.indexOf("music-song6-345948-new-york.mp3") == -1)
			)
			{
				if (Math.random() < 0.5)
				{
					MusicPlay("music-song3-547545-scotland.mp3", 0.4, parseInt(Math.random() * 30));
				}
				else
				{
					MusicPlay("music-song6-345948-new-york.mp3", 0.4, parseInt(Math.random() * 30));					
				}
			}
			else
			{
				console.log("MusicSelect: ALREADY PLAYING!");
			}
		}			
	}
}

function SoundBufferFillStart()
{
	mSoundBufferState = 0;
	SoundBufferFillMisc();
}

function SoundBufferFillMisc()
{
	var fileNames = [
		"sound-thanks.mp3", "sound-blah.mp3", "sound-fail.mp3", "sound-hole.mp3", "sound-pop.mp3", "sound-serena-ugh.mp3"
		, "sound-bonus.mp3", "sound-boss.mp3", "sound-milestone.mp3", "sound-bonus-bye.mp3", "sound-milestone-begone.mp3"
		, "sound-outstanding1.mp3", "sound-outstanding2.mp3", "sound-outstanding3.mp3", "sound-outstanding4.mp3"
		, "sound-congrats1.mp3", "sound-congrats2.mp3"
		, "sound-applause-20479.mp3", "sound-applause-150953.mp3", "sound-applause-335107.mp3"
		, "sound-congrats-confused.mp3"
		, "sound-dignityretained.mp3"
		, "sound-milestoned.mp3"
		, "sound-bossed.mp3"
		, "sound-bonussed.mp3"
		, "sound-whew1.mp3", "sound-whew2.mp3", "sound-whew3.mp3"
		, "sound-yourstreak.mp3", "sound-150968laughingaudience.mp3"
		, "sound-thud.mp3", "sound-considerthehole.mp3", "sound-considerthehole-closing.mp3"
		, "sound-letthegamebegin.mp3", "sound-usetheforce.mp3", "sound-failmaybe.mp3"
		, "sound-swishbig.mp3"
		, "sound-blink0.mp3", "sound-blink1.mp3"
		, "sound-100hundred.mp3", "sound-100hundreded.mp3"
		, "sound-zap-short.mp3", "sound-zap-long.mp3"
		, "sound-blip.mp3"
		, "sound-100hundred-no.mp3"
		, "sound-cow.mp3"
		, "sound-angry-mob.mp3"
		, "sound-thatsone.mp3", "sound-thatstwo.mp3", "sound-enough.mp3"
		, "sound-concreteblock-hit.mp3", "sound-concreteblock-alone.mp3"
		, "sound-pump.mp3"
		, "sound-unleashed.mp3"
		, "sound-gavel.mp3"
		, "sound-youblewit.mp3"
		, "sound-youcanalwaysgoback-title.mp3"
		, "sound-finishtile1-641837.mp3"
		, "sound-finishtile2-641837.mp3"		
	];

	SoundBufferMiscType = {
		soundthanks: 0, soundblah: 1, soundfail: 2, soundhole: 3, soundpop: 4, soundserenaugh: 5
		, soundbonus: 6, soundboss: 7, soundmilestone: 8, soundbonusbye: 9, soundmilestonebegone: 10
		, soundoutstanding1: 11, soundoutstanding2: 12, soundoutstanding3: 13, soundoutstanding4: 14
		, soundcongratulations1: 15, soundcongratulations2: 16
		, soundapplausescream: 17, soundapplausenormal: 18, soundapplauseweak: 19
		, soundcongratulationsconfused: 20
		, sounddignityretained: 21
		, soundmilestoned: 22
		, soundbossed: 23, soundbonussed: 24
		, soundwhew1: 25, soundwhew2: 26, soundwhew3: 27
		, soundyourstreak: 28, soundlaughing: 29
		, soundthud: 30
		, soundconsiderthehole: 31,  soundconsidertheholeclosing: 32
		, soundletthegamebegin: 33, soundusetheforce: 34, soundfailmaybe: 35
		, soundswishbig: 36
		, soundblink0: 37, soundblink1: 38
		, sound100hundred: 39, sound100hundreded: 40
		, soundzapshort: 41, soundzaplong: 42
		, soundblip: 43
		, sound100hundredno: 44
		, soundcow: 45
		, soundangrymob: 46
		, soundthatsone: 47, soundthatstwo: 48, soundenough:49
		, soundconcreteblockhit:50, soundconcreteblockalone:51
		, soundpump: 52
		, soundunleashed: 53
		, soundgavel: 54
		, soundyoublewit: 55
		, soundyoucanalwaysgobacktitle: 56
		, soundfinishtile1: 57
		, soundfinishtile2: 58		
	};
	mSoundBufferMisc = new Array(fileNames.length);
	SoundBufferFill(SoundBufferFillGah, mSoundBufferMisc, fileNames);	
}

function SoundBufferFillGah()
{
	mSoundBufferGah = new Array(4);
	var fileNames = new Array(); for (var index = 0; index < mSoundBufferGah.length; index++) { fileNames.push("sound-gah" + index + ".mp3"); }
	SoundBufferFill(SoundBufferFillHop, mSoundBufferGah, fileNames);
}

function SoundBufferFillHop()
{
	mSoundBufferHop = new Array(9);
	var fileNames = new Array(); for (var index = 0; index < mSoundBufferHop.length; index++) { fileNames.push("sound-hop" + index + ".mp3"); }
	SoundBufferFill(SoundBufferFillUgh, mSoundBufferHop, fileNames);
}

function SoundBufferFillUgh()
{
	mSoundBufferUgh = new Array(3);
	var fileNames = new Array(); for (var index = 0; index < mSoundBufferUgh.length; index++) { fileNames.push("sound-ugh" + index + ".mp3"); }	
	SoundBufferFill(SoundBufferFillTick, mSoundBufferUgh, fileNames);
}

function SoundBufferFillTick()
{
	mSoundBufferTick = new Array(5);
	var fileNames = new Array(); for (var index = 0; index < mSoundBufferTick.length; index++) { fileNames.push("sound-tick" + index + ".mp3"); }
	SoundBufferFill(SoundBufferFillAh, mSoundBufferTick, fileNames);
}

function SoundBufferFillAh()
{
	mSoundBufferAh = new Array(5);
	var fileNames = new Array(); for (var index = 0; index < mSoundBufferAh.length; index++) { fileNames.push("sound-ah" + index + ".mp3"); }
	SoundBufferFill(SoundBufferFillSwish, mSoundBufferAh, fileNames);
}

function SoundBufferFillSwish()
{
	mSoundBufferSwish = new Array(6);
	var fileNames = new Array(); for (var index = 0; index < mSoundBufferSwish.length; index++) { fileNames.push("sound-swish" + index + ".mp3"); }
	SoundBufferFill(SoundBufferFillFinish, mSoundBufferSwish, fileNames);
}

function SoundBufferFillFinish()
{
	mSoundBufferState = 1;
}
// </SOUND>

// ---------------------------------------------------------------------------------------------------------------------
// <SPOTS>
// player shadows!
// ---------------------------------------------------------------------------------------------------------------------
function Spots()
{
this.spots = null;

this.spotDivide = 60;
this.spotHistory = new Array(mTileXMax * mTileYMax * this.spotDivide);
this.spotHistoryIndex = 0;

this.Load = function()
{
	this.spots = new Array(30);

	this.spotHistoryIndex = 0;	
	for (var index = 0; index < this.spotHistory.length; index++)
	{
		this.spotHistory[index] = new Object();
		this.spotHistory[index].x = 0;
		this.spotHistory[index].y = 0;
	}
	
	for (var index = 0; index < this.spots.length; index++)
	{	
		// console.log("index" + index + ":" + parseInt((index / (this.spots.length - 1.0)) * 100.0));
		this.index = index;
		this.spots[index] = new Object();		
		this.spots[index].div = document.createElement("div");
		this.spots[index].div.style.cssText = 
			"position:absolute; left:-100px; top:-100px; width:20px; Height:20px; z-index:3; visibility:hidden;"
			+ "";
			// + "filter: invert(100%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(" + parseInt((1.0 - (index / (this.spots.length - 1.0))) * 40.0) + "%) contrast(100%);";

		mWorldDiv.appendChild(this.spots[index].div);
		this.spots[index].div.innerHTML = ""
			+ "<IMG Src='myface-00-shadow.png'"
				+ " Style='position:absolute; left:0px; top:0px; width:100%; height:100%;"
					+ " opacity:" + (0.05 + (parseInt( (index / (this.spots.length - 1.0)) * 15) / 100.0)) + ";"
				+ "'"
			+ ">";

		this.spots[index].transform = new Transform(this.spots[index].div);		
		this.spots[index].spotHistoryIndex = 0;
		this.spots[index].speedRatio = 0.4 - (1.0 - (index / (this.spots.length - 1))) * 0.3;   // (lower drags) 0.2 - 0.75 (higher never shows)
		// this.spots[index].speedRatio *= 0.5;
		this.spots[index].sizeRatio = 1.0; // 0.9 + (index / (this.spots.length - 1)) * 0.1;
	}
}

this.Finish = function(pX, pY)
{	
	this.spotHistoryIndex = 0;	
	for (var index = 0; index < this.spots.length; index++)
	{
		this.spots[index].spotHistoryIndex = 0;
		this.spots[index].div.style.visibility = "hidden";
		this.spotHistory[index].x = pX;
		this.spotHistory[index].y = pY;
	}
}

this.Update = function()
{		
	for (var index = 0; index < this.spots.length; index++)
	{
		if (this.spots[index].spotHistoryIndex != this.spotHistoryIndex)
		{
			if (this.spotHistoryIndex >= this.spots[index].spotHistoryIndex)
			{
				this.spots[index].spotHistoryIndex += (this.spotHistoryIndex - this.spots[index].spotHistoryIndex) * this.spots[index].speedRatio;
			}
			else
			{
				this.spots[index].spotHistoryIndex += (this.spotHistoryIndex + this.spotHistory.length - this.spots[index].spotHistoryIndex) * this.spots[index].speedRatio;
			}
			
			if (this.spots[index].spotHistoryIndex >= this.spotHistory.length) { this.spots[index].spotHistoryIndex -= this.spotHistory.length; }
			
			if (Math.abs(this.spotHistoryIndex - this.spots[index].spotHistoryIndex) < 0.5)
			{
				this.spots[index].spotHistoryIndex = this.spotHistoryIndex;
				this.spots[index].div.style.visibility = "hidden";
			}

			this.spots[index].transform.LerpChange(
				this.spotHistory[parseInt(this.spots[index].spotHistoryIndex)].x
				, this.spotHistory[parseInt(this.spots[index].spotHistoryIndex)].y
				, 1
				, mTileSize2 * 1.1 * this.spots[index].sizeRatio
				, mTileSize2 * 1.1 * this.spots[index].sizeRatio
				, 1
			);		
		}
	}
}

this.Add = function(pX, pY)
{
	var x = this.spotHistory[this.spotHistoryIndex].x, y = this.spotHistory[this.spotHistoryIndex].y;
	
	for (var index = 0; index < this.spotDivide; index++)
	{
		this.spotHistoryIndex = (this.spotHistoryIndex + 1) % this.spotHistory.length;
		this.spotHistory[this.spotHistoryIndex].x = x + (pX - x) * ((index + 1) / this.spotDivide);
		this.spotHistory[this.spotHistoryIndex].y = y + (pY - y) * ((index + 1) / this.spotDivide);	
	}

	for (var index = 0; index < this.spots.length; index++)
	{
		this.spots[index].div.style.visibility = "";
	}
}

}


// ---------------------------------------------------------------------------------------------------------------------
// <PLAYBACK> <PLAYERS>
// ---------------------------------------------------------------------------------------------------------------------
function Playback()
{
this.players = null;
this.playerCurrent = -1;
this.freezeTime = 0;

this.Refresh = function()
{
	/*
	if (mTileSize < 60)
	{
		for (var index = 0; index < this.players.length; index++)
		{
			this.players[index].div.style.boxShadow = "none"; // 1px 1px #000000";
			this.players[index].div.style.border = "1px solid black";
			this.players[index].div.style.borderRadius = "0px";
		}
	}
	else
	{
		for (var index = 0; index < this.players.length; index++)
		{
			this.players[index].div.style.boxShadow = "2px 2px #666666";
			this.players[index].div.style.border = "1px solid black";
			this.players[index].div.style.borderRadius = "3px";
		}
	}
	*/
}

this.Load = function()
{
	this.players = new Array(40);   // 2 MINIMUM. 1 dedicated to recording player movement
	this.playerCurrent = -1;	
	
	for (var index = 0; index < this.players.length; index++)
	{
		this.players[index] = new Object();		
		this.players[index].div = document.createElement("div");
		this.players[index].div.style.cssText = "";
		mWorldDiv.appendChild(this.players[index].div);
		this.players[index].div.innerHTML = ""
			+ "<IMG Src='myface-01-normal.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>"
			+ "<IMG Src='myface-01-normal-blink.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>"
			+ "<IMG Src='myface-02-fail.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>"
			+ "<IMG Src='myface-02-fail-blink.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>"
			+ "<IMG Src='myface-05-pink-normal.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>"
			+ "<IMG Src='myface-05-pink-normal-blink.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>"
			+ "<IMG Src='myface-06-pink-fail.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>"
			+ "<IMG Src='myface-06-pink-fail-blink.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>"
			+ "";

		this.players[index].transform = new Transform(this.players[index].div);		

		this.players[index].keys = new Array(mTileXMax * mTileYMax);
		this.players[index].keysShift = new Array(mTileXMax * mTileYMax);
		
		this.players[index].ResetPlayer = function()
		{
			this.transform.LerpChange(-1000, -1000, 1, 10, 10, 1);
			this.keyCount = 0;

			this.x = -1;
			this.y = -1;	
			this.xyIndex = -1;		
			this.xyIndexOld = -1;		

			this.keyIndex = -1;
			this.state = 0;
			this.speed = 0.05;
			this.delta = 0;
			this.wait = 0;
			
			this.blinkState = 0;
			this.blinkCounter = 0;
			this.repeat = 0;
			
			this.type = 0;
			this.solveIndex = 0;
			this.sizeRatio = 0.0;
		}

		this.players[index].FaceChange = function(pIndex)
		{
			if (this.type > 0) { pIndex += 4; }
			this.div.children[pIndex].style.visibility = "";
		
			for (var index = 0; index < this.div.children.length; index++)
			{
				if ( (index != pIndex) && (this.div.children[index].style.visibility != "hidden") )
				{
					this.div.children[index].style.visibility = "hidden";
				}
			}
		}		
	}
}

this.Reset = function()
{
	this.playerCurrent = -1;

	for (var index = 0; index < this.players.length; index++)
	{
		this.players[index].ResetPlayer();
	}
	this.Add();
}

this.Add = function(pNext = true)
{
	if (pNext) { this.playerCurrent = (this.playerCurrent + 1) % this.players.length; }
	this.players[this.playerCurrent].ResetPlayer();   // might overwrite existing

	if ( (mUseTheForceState != 3)  && (((mWorldRepeatCount + 1) % 4) == 0))   // 4 failures launches a pink solution
	{
		var solveIndex = -1;
		if ( (mSolvedPlayfieldTurn[0] == 100000) && (mSolvedPlayfieldTurn[1] == -1) )
		{
			solveIndex = 2;   // no solution, randomly wander
		}
		else if ((mSolvedPlayfieldTurn[0] != 100000) && (mSolvedPlayfieldTurn[1] != -1))
		{
			if (mTalkStates[TalkType.turns] == 1)
			{
				solveIndex = 0;   // least turns route
			}
			else if (mTalkStates[TalkType.turns] == 2)
			{
				solveIndex = 1;   // most turns route
			}
			else
			{
				solveIndex = parseInt(Math.random() * 2);
			}
		}
		else
		{
			solveIndex = 0;   // first is always filled out
		}
		
		// playback is ready to begin recording. turn it into a pink and setup next recording
		this.players[this.playerCurrent].type = 1;
		this.players[this.playerCurrent].solveIndex = solveIndex;
		this.playerCurrent = (this.playerCurrent + 1) % this.players.length;
		this.players[this.playerCurrent].ResetPlayer();   // might overwrite existing
	}

	// launch the ancient ones
	var count = 0;
	var index = (this.playerCurrent + 1) % this.players.length;
	while (index != this.playerCurrent)
	{	
		var player = this.players[index];
		if ( (player.keyCount > 0) || (player.type == 1) )
		{	
			count++;
			player.FaceChange(0);
			
			// player.div.style.backgroundImage= "url('myface-400-neutral.png')";
			var y = parseInt(mRememberPlayerXYIndex / mTileXCount);
			var x = mRememberPlayerXYIndex - (y * mTileXCount);			
			player.x = x;
			player.y = y;
			player.xyIndex = mRememberPlayerXYIndex; 
			player.xyIndexOld = player.xyIndex;
			
			player.keyIndex = -1;
			player.state = 1;   // we're alive
			player.speed += 0.02;   // old ones get faster and faster (they're "known")
			if (player.speed > 0.95) { player.speed = 0.95; }
			player.delta = 0;
			player.wait = count;

			player.keyOld = 0;
			player.div.style.cssText = "position:absolute; left:-100px; top:-100px; width:20px; Height:20px; z-index:3;";
			// https://codepen.io/sosuke/pen/Pjoqqp
			if (player.type == 1)
			{
				/*
				if (player.solveIndex == 0)
				{
					player.div.style.cssText += "filter: invert(15%) sepia(86%) saturate(4107%) hue-rotate(292deg);";
				}
				else if (player.solveIndex == 1)
				{
					player.div.style.cssText += "filter: invert(15%) sepia(86%) saturate(3000%) hue-rotate(166deg);";
				}
				else if (player.solveIndex == 2)
				{
					player.div.style.cssText += "filter: invert(73%) sepia(41%) saturate(581%) hue-rotate(26deg);";
				}
				*/
			}

			player.sizeRatio = 1.0; if (player.type == 1) { player.sizeRatio = 1.5; }

			player.transform.LerpChange(
				mPlayFieldDivs[player.xyIndex].newLeft, mPlayFieldDivs[player.xyIndex].newTop, 1
				, mTileSize2 * 0.4 * player.sizeRatio, mTileSize2 * 0.4 * player.sizeRatio, 1
			);			
	
			player.div.style.zIndex = 4;
		}
		index = (index + 1) % this.players.length;
	}
}

this.Record = function(pKey, pShift)
{
	this.players[this.playerCurrent].keys[this.players[this.playerCurrent].keyCount] = pKey;	
	this.players[this.playerCurrent].keysShift[this.players[this.playerCurrent].keyCount] = pShift;
	this.players[this.playerCurrent].keyCount++;
}

this.MatchCurrent = function()
{
	// Does this run match a previous run?
	// Playback characters contain ALL info about a previous run, so dare to compare!
	var repeat = 0;
	for (var index = 0; index < this.players.length; index++)
	{
		if ( (index != this.playerCurrent) && (this.players[this.playerCurrent].keyCount == this.players[index].keyCount) && (this.players[index].type == 0) )
		{
			var success2 = true;
			for (var index2 = 0; index2 < this.players[this.playerCurrent].keyCount; index2++)
			{
				if (this.players[this.playerCurrent].keys[index2] != this.players[index].keys[index2]) { success2 = false; break; }
			}
			if (success2)
			{
				this.players[index].repeat++;
				repeat = this.players[index].repeat;
				break;
			}
		}
	}
	return repeat;
}

this.RemovePlayer = function(pPlayer)
{
	if (mPlayFieldDivs[pPlayer.xyIndexOld].transform.jimWidth < mTileSize2 * 0.9)
	{
		// hopped onto an EMPTY square, fall away
		pPlayer.FaceChange(2);
		var volume = 0.2; if (mState == 1) { volume = 0.1; }
		SoundBufferPlay(mSoundBufferAh, volume, -1, 3);
		pPlayer.state = 3;
	}
	else
	{
		// mPlayer likely ZIPPED over this yellow guy, mushing him
		var volume = 1; if (mState == 1) { volume = 0.5; }
		SoundBufferPlay(mSoundBufferUgh, volume, -1, 4);		
		pPlayer.transform.LerpChange(-1000, -1000, 1, 10, 10, 1);
		pPlayer.x = -1;
		pPlayer.y = -1;
		pPlayer.xyIndex = -1;
		pPlayer.state = 0;
	}
}

this.Update = function()
{
	if (this.freezeTime != 0)
	{
		if (Date.now() > this.freezeTime) { this.freezeTime = 0; }
	}
	else
	{
		for (var index = 0; index < this.players.length; index++)
		{	
			var player = this.players[index];
			if (player.state != 0)
			{
				if (
					((player.xyIndex == mPlayer.xyIndex) && (player.xyIndex != mRememberPlayerXYIndex))
					&& ((player.state == 1) || (player.state == 2))
				)
				{
					this.RemovePlayer(player);
				}
				
				// <BLINK>
				if ((player.state == 1) || (player.state == 2))
				{
					player.blinkCounter--;
					if (player.blinkCounter < 0)
					{
						if (player.blinkState == 0)
						{						
							if (player.state == 1)
							{
								player.FaceChange(1);
							}
							else
							{
								var id = SoundBufferMiscType.soundblink0; if (Math.round() < 0.5) { id = SoundBufferMiscType.soundblink1; } 
								SoundBufferPlay(mSoundBufferMisc, 0.015, id, 6);
								player.FaceChange(3);
							}							
							
							player.blinkState = 1;
							player.blinkCounter = 8 + parseInt(Math.random() * 4);
						}
						else
						{
							if (player.state == 1)
							{
								player.FaceChange(0);							
							}
							else
							{
								player.FaceChange(2);							
							}

							player.blinkState = 0;
							if (Math.random() < 0.1)
							{
								player.blinkCounter = 8 + parseInt(Math.random() * 4);
							}
							else
							{
								player.blinkCounter = 90 + parseInt(Math.random() * 20);
								// player.blinkCounter = 180 + parseInt(Math.random() * 40);
							}
						}
					}				
				}
				// </BLINK>
		
				switch (player.state)
				{
					case 1:
					{					
						if (player.wait > 0)
						{
							player.wait--;
							if (mPlayField[player.xyIndexOld] == 0) { this.RemovePlayer(player); }
						}
						else
						{						
							var speed = player.speed;
							
							// <MOVE>
							if (player.xyIndexOld == player.xyIndex)
							{
								var key = -1;
								var keyShift = false;

								if (player.type == 0)
								{
									player.keyIndex++;
									key = player.keys[player.keyIndex];
									keyShift = player.keysShift[player.keyIndex];
								}
								else
								{
									// <PINK>
									if (player.solveIndex == 2)
									{
										if (false)
										// if ( (Math.random() < 0.1) && (player.xyIndex != mPlayer.xyIndex) )
										{
											// higher speed means less wait time.
											var ratio = 1.0 - (player.speed / (0.05 + 0.02 * (this.players.length * 0.5)));
											if (ratio < 0.1) { ratio = 0.1; }
											player.wait = (100 + parseInt(Math.random() * 50)) * (0.1 + ratio * 0.9);
										}
										else
										{
											var failSafe = 20;
											key = -1;
											do
											{
												var hold = parseInt(Math.random() * 4);
												if (hold == 0) { key = 37; } else if (hold == 1) { key = 39; } else if (hold == 2) { key = 38; } else if (hold == 3) { key = 40; }
												if ( (key == 37) && ((player.keyOld == 39) || (player.x <= 0) || (mPlayField[player.y * mTileXCount + player.x - 1] == 0) || (player.y * mTileXCount + player.x - 1 == mPlayer.xyIndex)) )  // left arrow or w
												{
													key = -1;
												}
												else if ( (key == 39) && ((player.keyOld == 37) || (player.x >= mTileXCount - 1) || (mPlayField[player.y * mTileXCount + player.x + 1] == 0) || (player.y * mTileXCount + player.x + 1 == mPlayer.xyIndex)) )   // right arrow or d
												{
													key = -1;
												}
												else if ( (key == 38) && ((player.keyOld == 40) || (player.y <= 0) || (mPlayField[(player.y - 1) * mTileXCount + player.x] == 0) || ((player.y - 1) * mTileXCount + player.x == mPlayer.xyIndex)) )   // up arrow or w
												{
													key = -1;
												}
												else if ( (key == 40) && ((player.keyOld == 38) || (player.y >= mTileYCount - 1) || (mPlayField[(player.y + 1) * mTileXCount + player.x] == 0) || ((player.y + 1) * mTileXCount + player.x == mPlayer.xyIndex)) )   // down arrow or s
												{
													key = -1;
												}
												failSafe--;												
											} while ((key == -1) && (failSafe > 0))
											// if player managed to trap the drunkard, give him a shocked expression
											if (key == -1)
											{
												player.div.style.zIndex = 3;
												if (mState != 1) { SoundBufferPlay(mSoundBufferGah, 0.1); }
												player.state = 2;												
											}
										}
									}
									else
									{
										var hold = mSolvedPlayfield[player.solveIndex][player.xyIndex];
										if (hold == -1) { key = 37; } else if (hold == -2) { key = 39; } else if (hold == -3) { key = 38; } else if (hold == -4) { key = 40; } else { console.error("Playback.Update() Error: Unexpected playfield value :" + hold); }
										if ((player.solveIndex == 0) && (player.keyOld == key)) { keyShift = true; } else { keyShift = false; }
									}
									// </PINK>
								}
								
								if ( (key != -1) && (player.state == 1) )
								{
									// sometimes recordings "forget", it's only human
									if (false)
									// if ( (key != player.keyOld) && (Math.random() < 0.005) )
									{
										if (key == 37) { key = 39; } else if (key == 39) { key = 37; } else if (key == 38) { key = 40; } else if (key == 40) { key = 38; }
										/*
										if ((key == 37) || (key == 39))
										{
											if (Math.random() < 0.5) { key = 38; } else { key = 40; }
										}
										else
										{
											if (Math.random() < 0.5) { key = 37; } else { key = 39; }
										}
										*/
									}
									player.keyOld = key;
									
									var dirX = 0, dirY = 0;
									if ( (key == 37) && (player.x > 0) )  // left arrow or w
									{
										dirX = -1;
										player.transform.jimRotate = 270; if (mWorldFlipped) { player.transform.jimRotate = 0; }
										RotateDiv(player.div, player.transform.jimRotate);
									}
									else if ( (key == 39) && (player.x < mTileXCount - 1) )   // right arrow or d
									{
										dirX = 1;
										player.transform.jimRotate = 90; if (mWorldFlipped) { player.transform.jimRotate = 180; }
										RotateDiv(player.div, player.transform.jimRotate);
									}
									else if ( (key == 38) && (player.y > 0) )   // up arrow or w
									{
										dirY = -1;
										player.transform.jimRotate = 0; if (mWorldFlipped) { player.transform.jimRotate = 270; }
										RotateDiv(player.div, player.transform.jimRotate); 
									}
									else if ( (key == 40) && (player.y < mTileYCount - 1) )   // down arrow or s
									{
										dirY = 1;
										player.transform.jimRotate = 180; if (mWorldFlipped) { player.transform.jimRotate = 90; }
										RotateDiv(player.div, player.transform.jimRotate); 
									}
									// BOOS has 3 levels: mLevelStageCount == 1 goes in reverse
									if (mLevelStageCount == 1) { RotateDiv(player.div, ((player.transform.jimRotate + 180) % 360) ); }

									// console.assert( ((dirX != 0) || (dirY != 0)), "Playback.Update(): Recorded a keystroke that didn't move.");

									if ( (dirX != 0) || (dirY != 0) )
									{
										if (((player.y + dirY) * mTileXCount + (player.x + dirX)) == mPlayer.xyIndex)
										{
											if (player.type == 0) { player.keyIndex--; }
											player.keyOld = 0;
										}
										else
										{
											if (mPlayFieldDivs[player.xyIndex].finishTileState == 0)
											{
												// Pink leaves pink trails
												if (player.type > 0)
												{
													TileSetColor(mPlayFieldDivs[player.xyIndex], 255, 100, 255, 2);
													TileSetColorTemp(mPlayFieldDivs[player.xyIndex], 750, 255, 100, 255);
												}
												// Regular leaves yellow (considering black)
												else
												{
													TileSetColor(mPlayFieldDivs[player.xyIndex], 255, 255, 100, 2);
													TileSetColorTemp(mPlayFieldDivs[player.xyIndex], 750, 255, 255, 100);
												}
											}

											player.x += dirX;
											player.y += dirY;
											player.xyIndex = player.y * mTileXCount + player.x;
											if (keyShift) { speed = 1; }
											
										}
									}
								}
							}
							// </MOVE>

							if (player.state == 1)
							{
								if (player.xyIndexOld == player.xyIndex)
								{	
									// we didn't move! mPlayer is blocking us from moving, do we still have tile underneath us?
									if (mPlayField[player.xyIndexOld] == 0)
									{
										this.RemovePlayer(player);
									}
									else
									{
										if ( (player.type > 0) && (player.solveIndex == 2) )
										{
											// higher speed means less wait time.
											var ratio = 1.0 - (player.speed / (0.05 + 0.02 * (this.players.length * 0.5)));
											if (ratio < 0.1) { ratio = 0.1; }
											player.wait = (100 + parseInt(Math.random() * 50)) * (0.1 + ratio * 0.9);
										}
										else
										{
											player.wait = 250 + parseInt(Math.random() * 100);   // wait politely (but awkwardly) before moving again
										}
										player.keyOld = 0;
									}
								}
								else
								{
									console.assert(player.xyIndexOld != player.xyIndex, "Playback.Update(): player.xyIndexOld == player.xyIndex DESPITE key being processed.");
									console.assert(speed != 0, "Playback.Update() Error: speed = 0, playback player won't move");
									var size = -1;
									player.delta += speed;
									if (player.delta >= 1)
									{
										player.delta = 0;
										if (speed != 1) { player.wait = 3; } else { player.wait = 1; }

										player.xyIndexOld = player.xyIndex;
										size = mTileSize2 * 0.5 * player.sizeRatio;
										player.transform.LerpChange(mPlayFieldDivs[player.xyIndexOld].newLeft, mPlayFieldDivs[player.xyIndexOld].newTop, 1, size, size, 1);

										if (mState != 1) {
											if (mPlayFieldDivs[player.xyIndexOld].visiblePermanent == 0) { SoundBufferPlay(mSoundBufferMisc, 0.25, SoundBufferMiscType.soundzapshort); }
											SoundBufferPlay(mSoundBufferHop, 0.1, -1, 2);
										}
						
										if (mPlayField[player.xyIndexOld] == 0)
										{
											this.RemovePlayer(player);
										}
										// <STOP>
										else if (
											( (player.type == 0) && (player.keyIndex + 1 == player.keyCount) )
											|| ( (player.type == 1) && (player.solveIndex <= 1) && (mSolvedPlayfield[player.solveIndex][player.xyIndexOld] == 1) )
										)
										{
											player.FaceChange(2);
											
											// If multiple players end up on this spot, GROW it.
											// var width = mTileSize2 * 0.3;
											for (var c = 0; c < this.players.length; c++)
											{
												if (
													(c != index)
													&& (player.xyIndex == this.players[c].xyIndex)
													&& (this.players[c].state == 2)
												)
												{
													var anotherPlayer = this.players[c];
													var sizeIncreaseRatio = 1.3; if (player.type == 1) { sizeIncreaseRatio = 1.04; } 
													anotherPlayer.transform.LerpChange(
														mPlayFieldDivs[anotherPlayer.xyIndex].newLeft, mPlayFieldDivs[anotherPlayer.xyIndex].newTop, 1
														, anotherPlayer.transform.jimWidth * sizeIncreaseRatio, anotherPlayer.transform.jimWidth * sizeIncreaseRatio, 1
													);

													anotherPlayer.transform.jimRotate += (-20 + parseInt(Math.random() * 41));
													RotateDiv(anotherPlayer.div, anotherPlayer.transform.jimRotate);
												}
											}										

											player.transform.jimRotate += (-20 + parseInt(Math.random() * 41));
											RotateDiv(player.div, player.transform.jimRotate);

											player.div.style.zIndex = 3;
											if (mState != 1) { SoundBufferPlay(mSoundBufferGah, 0.1); }
											player.state = 2;
										}
										// </STOP>
									}
									else
									{
										size = mTileSize2 * 0.6 * player.sizeRatio + Math.sin(player.delta * Math.PI) * mTileSize2 * 0.4 * player.sizeRatio;   // (1.0 + ((player.sizeRatio - 1.0) * 0.5));
										player.transform.LerpChange(
											mPlayFieldDivs[player.xyIndexOld].newLeft + (mPlayFieldDivs[player.xyIndex].newLeft - mPlayFieldDivs[player.xyIndexOld].newLeft) * player.delta
											, mPlayFieldDivs[player.xyIndexOld].newTop + (mPlayFieldDivs[player.xyIndex].newTop - mPlayFieldDivs[player.xyIndexOld].newTop) * player.delta
											, 1
											, size
											, size
											, 1
										);
									}
								}
							}
						}
						break;
					}
					case 2:
					{					
						// end
						if (mPlayField[player.xyIndexOld] == 0)
						{
							this.RemovePlayer(player);
						}
						else
						{
							player.transform.LerpChange(mPlayFieldDivs[player.xyIndex].newLeft, mPlayFieldDivs[player.xyIndex].newTop, 0.05);
						}						
						break;
					}
					case 3:
					{
						// fall
						player.transform.LerpChange(player.transform.jimLeft, player.transform.jimTop, 0.05, 1, 1, 0.05);
						if (player.transform.jimWidth < 2)
						{
							player.transform.LerpChange(-1000, -1000, 1, 10, 10, 1);
							player.x = -1;
							player.y = -1;
							player.xyIndex = -1;
							player.state = 0;
						}
						break;
					}
				}
			}
		}
	}
}

}


// ---------------------------------------------------------------------------------------------------------------------
// <MISC>
// ---------------------------------------------------------------------------------------------------------------------
function TileAdd()
{
	var emptySpots = new Array(mTileXYCount);
	for (var index  = 0; index < mTileXYCount; index++)
	{
		if (
			(mPlayField[index] == 0)
			&& (mPlayFieldDivs[index].extra == 0)
			&& (index != mRestart.xyIndexRemember)
		)
		{
			emptySpots.push(index)
		}
	}
	console.assert(emptySpots.length > 0, "TileAdd() Error: Could NOT find a tile to remove.");

	ShuffleArray(emptySpots);
	mPlayField[emptySpots[0]] = 1;
	mTileTotal++;
}

function TileRemove()
{
	var emptySpots = new Array(mTileXYCount);
	var x = -1, y = -1;
	for (var index  = 0; index < mTileXYCount; index++)
	{
		y = parseInt(index / mTileXCount);
		x = index - (y * mTileXCount);
	
		if (
			(mPlayField[index] == 1)
			&& (mPlayFieldDivs[index].extra == 0)
			&& (index != mRestart.xyIndexRemember)
			&& (index != mPlayer.xyIndex)
			&& (EdgeCount(x, y) < 2)
			// && visualState
			&& ( (x == 0) || (mPlayField[y * mTileXCount + (x - 1)] == 0) || (EdgeCount(x - 1, y) < 3) )
			&& ( (x == mTileXCount - 1) || (mPlayField[y * mTileXCount + (x + 1)] == 0) || (EdgeCount(x + 1, y) < 3) ) 
			&& ( (y == 0) || (mPlayField[(y - 1) * mTileXCount + x] == 0) || (EdgeCount(x, y - 1) < 3) ) 
			&& ( (y == mTileYCount - 1) || (mPlayField[(y + 1) * mTileXCount + x] == 0) || (EdgeCount(x, y + 1) < 3) )			
		)
		{
			emptySpots.push(index);
		}
	}
	console.assert(emptySpots.length > 0, "TileRemove() Error: Could NOT find a tile to remove.");
	
	ShuffleArray(emptySpots);
	mPlayField[emptySpots[0]] = 0;
	mTileTotal--;
}

function GrowTiles()
{
	var x = -1, y = -1;
	
	var halfTileXYCount = -1;
	if (mWorldMode > 0)
	{
		halfTileXYCount = (mWorldEvening > 0) ? 28 : 9;
	}
	else if (mLevelType == LevelType.Bonus)
	{
		halfTileXYCount = 40;
	}
	else if (mLevelType == LevelType.MileStone)
	{
		halfTileXYCount = 28;
	}
	else if (mLevelType == LevelType.OneHundred)
	{
		halfTileXYCount = 18;	
	}
	// failsafe
	if (halfTileXYCount > Math.floor(mTileTotalRemember * 0.75)) { halfTileXYCount = Math.floor(mTileTotalRemember * 0.75); }
	
	do
	{
		x = mPlayer.left;
		y = mPlayer.top;

		mTileTotal = 0;
		for (var index = 0; index < mTileXYCount; index++)
		{
			mPlayField[index] = 0;
			mPlayFieldDivs[index].extra = 0;
		}
		mTileTotal++;
		mPlayField[y * mTileXCount + x] = 1;	
		
		// Taken from WorldResetSnake() 		
		var dirX = 0, dirY = 0;
		if (Math.random() < 0.5) 
		{
			dirX = -1 + parseInt(Math.random() * 2) * 2;
			dirY = 0;
		}
		else
		{
			dirX = 0;
			dirY = -1 + parseInt(Math.random() * 2) * 2;
		}
		var change = false;
		var blocked = 0;
		var chance = 0.5;
		do
		{
			if (mTileTotal > halfTileXYCount) // mTileXCount * mTileYCount * 0.75)
			{
				// not too dense
				blocked = 100;				
			}
			else
			{
				if ( (!change) && (Math.random() < chance) ) { change = true; } 
				if (change)
				{
					if (dirX == 0) 
					{
						dirX = -1 + parseInt(Math.random() * 2) * 2;
						dirY = 0;
					}
					else
					{
						dirX = 0;
						dirY = -1 + parseInt(Math.random() * 2) * 2;
					}
					change = false;
					chance = 0.5; if (Math.random() < 0.25) { chance = 0.3; }
				}

				if (
					(x + dirX >= 0) && (x + dirX < mTileXCount) && (y + dirY >= 0) && (y + dirY < mTileYCount) 
					&& (mPlayField[(y + dirY) * mTileXCount + (x + dirX)] == 0)
					&& (((y + dirY) * mTileXCount + (x + dirX)) != mRestart.xyIndexRemember)
				)
				{
					x += dirX; y += dirY;
					mTileTotal++;
					console.assert(mPlayField[y * mTileXCount + x] == 0);
					mPlayField[y * mTileXCount + x] = 1;
					blocked = 0;
				}
				else
				{
					change = true;
					blocked++;
				}
			}
		}
		while (blocked < 99)
	}
	while (mTileTotal < halfTileXYCount)
	
	// no sound, just ominous. maybe gregg going BOINK!
	backgroundR = 0; backgroundG = 255; backgroundB = 255;
	document.body.style.backgroundColor = RGBToHex(parseInt(backgroundR), parseInt(backgroundG), parseInt(backgroundB));			

	TilesWhite();	
}

// -------------------------------------------------------------------------------------------------------------------------
// RESTART
// -------------------------------------------------------------------------------------------------------------------------
function RestartInitialize()
{
	mRestart.newLeft = -1000; mRestart.newTop = -1000;
	mRestart.xyIndexRemember = -1;
	mRestart.xyIndex = -1;
	mRestart.div.style.backgroundColor = "#000000";
	mRestart.penalty = 0;
}

function RestartAttach()
{
	// Attach restart to a Tile that is NOT an END tile or Final Tile (otherwise player can't get to hole)
	// Might connect to Extra tiles BUT that's fine
	mRestart.newLeft = -1000; mRestart.newTop = -1000;
	var success = false;
	var x = -1, y = -1;
	do
	{
		x = parseInt(Math.random() * mTileXCount);
		y = parseInt(Math.random() * mTileYCount);
		
		success = false;
		if (
			(mPlayField[y * mTileXCount + x] == 0)
			&& (mPlayFieldDivs[y * mTileXCount + x].extra == 0)
		)
		{
			if ( (x > 0) && (mPlayField[y * mTileXCount + (x - 1)] == 1) && (EdgeCount(x - 1, y) < 3)) { success = true; }
			if ( (x < mTileXCount - 1) && (mPlayField[y * mTileXCount + (x + 1)] == 1) && (EdgeCount(x + 1, y) < 3) ) { success = true; }
			if ( (y > 0) && (mPlayField[(y - 1) * mTileXCount + x] == 1) && (EdgeCount(x, y - 1) < 3) ) { success = true; }
			if ( (y < mTileYCount - 1) && (mPlayField[(y + 1) * mTileXCount + x] == 1) && (EdgeCount(x, y + 1) < 3) ) { success = true; }

			if (success)
			{
				mPlayFieldDivs[y * mTileXCount + x].concreteBlock = 0;
				RestartPosition(y * mTileXCount + x);
			}
		}
	} while (!success);
	mRestart.xyIndex = -1;   // starts hidden (otherwise noise goes off)
}

function RestartPosition(pXYIndexRemember)
{
	mRestart.xyIndexRemember = pXYIndexRemember;

	let y = parseInt(mRestart.xyIndexRemember / mTileXCount);
	let x = mRestart.xyIndexRemember - (y * mTileXCount);
	if (mWorldFlipped) {
		let hold = x;
		x = y;
		y = hold;
	}

	mRestart.newLeft = parseInt(mWorldDeltaX + x * mTileSize + mTileSize * 0.5);
	mRestart.newTop = parseInt(mWorldDeltaY + y * mTileSize + mTileSize * 0.5);
}

function RestartUpdate()
{	
	// might switch to event driven, but like the hole taking care of itself

	// <HOLE HIDE>
	if (	
		(mRestart.xyIndexRemember != mPlayer.xyIndex)
		&&
		(
			// Never shows on Weekdays
			(mWorldMode == 1)

			// If the hole has been cutoff from the playfield, shrink back to oblivion	
			||
			(			
				( ((mRestart.xyIndexRemember % mTileXCount) == 0) || (mPlayField[mRestart.xyIndexRemember - 1] == 0) )
				&& ( ((mRestart.xyIndexRemember % mTileXCount) == mTileXCount - 1) || (mPlayField[mRestart.xyIndexRemember + 1] == 0) )		
				&& ( (mRestart.xyIndexRemember - mTileXCount < 0) || (mPlayField[mRestart.xyIndexRemember - mTileXCount] == 0) )
				&& ( (mRestart.xyIndexRemember + mTileXCount >= mTileXYCount) || (mPlayField[mRestart.xyIndexRemember + mTileXCount] == 0) )
			)

			// added 2025-07-27 but NOT tested with ALL TALKS!
			// Player needs to die 3 times before the hole shows (and magestically announces itself)
			|| ((mWorldRepeatCount < 3) && (mUrineState == 0))

			// special states
			||
			(
				(mUseTheForceState != 3)   // only happens on Boss-Step3 - player gets more than 3 tries due difficulty of "wrong way"
				&&
				(
					(mWorldState == 0)
					|| ( (mUrineState == 0) && ((mUseTheForceState != 0) || (mGrowCount > 0) || (mScoreUpdated == 0)) )
				)
			)
		)
	)	
	{
		if (mRestart.xyIndex != -1)
		{
			mRestart.xyIndex = -1;   // Prevents player from entering hole
			var volume = 0.25; if (mState == 1) { volume *= 0.25; }
			if (mWorldState != 0) { SoundBufferPlay(mSoundBufferMisc, volume, SoundBufferMiscType.soundconsidertheholeclosing); }
		}

		if (mRestart.transform.jimWidth >= 2)
		{
			mRestart.transform.LerpChange(mRestart.newLeft, mRestart.newTop, 0.05, 1, 1, 0.025);
			if (mRestart.transform.jimWidth < 2)
			{
				mRestart.div.style.left = "-1000px";
				mRestart.div.style.top = "-1000px";
			}
		}
	}
	// </HOLE HIDE>

	// <HOLE SHOW>
	else
	{
		if ( (mRestart.xyIndex == -1) && (mWorldRepeatCount == 3) && (mUrineState == 0) )
		{
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundconsiderthehole);
			if ((mRestart.penalty % 3) == 0) { TalkPlay3000(TalkType2.usethehole); }
		}

		mRestart.xyIndex = mRestart.xyIndexRemember;   // Player can enter hole
		var holeSize = parseInt(mTileSize2 * 0.8);
		mRestart.transform.LerpChange(mRestart.newLeft, mRestart.newTop, 0.05, holeSize, holeSize, 0.05);
		
		var hold = mWorldRepeatCount - 1;
		var deltaX = parseInt(-hold * 0.5 + Math.random() * hold);
		var deltaY = parseInt(-hold * 0.5 + Math.random() * hold);
		mRestart.div.style.left = parseInt(mRestart.transform.jimLeft - mRestart.transform.jimWidth * 0.5) + deltaX;
		mRestart.div.style.top = parseInt(mRestart.transform.jimTop - mRestart.transform.jimHeight * 0.5) + deltaY;
	}
	// </HOLE SHOW>
}

function BackgroundUpdate()
{	
	let r = 0, g = 0, b = 0;
	let lerp = 0;

	/*
	if (mWorldState == 0)
	{
		r = parseInt((25.0 / 100.0) * 255); g = parseInt((25.0 / 100.0) * 255); b = parseInt((36.0 / 100.0) * 255);
		lerp = 1;
	}
	*/
	
	if (mWorldUpdateTitleRunning == 1)
	{
		r = 64; g = 64; b = 96;
		lerp = 0.05;
	}
	
	else if (mGrowCount > 0)
	{
		r = 32; g = 32; b = 128;
		lerp = 0.05;	
	}
	
	else if (mUseTheForceState > 0)
	{
		if (mState == 1)
		{
			r = parseInt((83.0 / 100.0) * 255); g = parseInt((22.0 / 100.0) * 255); b = parseInt((22.0 / 100.0) * 255);
			lerp = 1;
		}
		else if (mWorldState == 2)
		{
			r = 0; g = 255; b = 255;
			lerp = 1;
		}
		else
		{
			r = 255; g = 208; b = 122;
			lerp = 0.1;			
		}
	}
	else if (mWorldMode == 1)
	{
		r = 64; g = 64; b = 96;
		lerp = 0.05;

		if ((mState == 1) && (mWorldState >= 1))
		{
			// failed: red
			r = parseInt((83.0 / 100.0) * 255); g = parseInt((22.0 / 100.0) * 255); b = parseInt((22.0 / 100.0) * 255);
			lerp = 1;
		}
	}
	else
	{		
		// I USED to turn the world gray after the hole arrived, made world look bad.
		r = 64; g = 64; b = 96;
		lerp = 0.05;
	
		if (mTalkStates[TalkType.turns] > 0)
		{
			if ( (mWorldState == 2)	&& (mState != 1) )
			{
				r = 255; g = 255; b = 255;
				lerp = 0.025;		
			}
			else if (mState == 1)
			{
				// too many turns / not enough turns
				r = 255; g = 0; b = 0;
				lerp = 0.025;
			}
		}
		else if (mTalkStates[TalkType.light] == 0)
		{
			r = 64; g = 64; b = 92;
			lerp = 1;	
		}
		else if (mLevelType == LevelType.Boss)
		{
			if ((mState == 1) && (mWorldState >= 1))
			{
				r = parseInt((83.0 / 100.0) * 255); g = parseInt((22.0 / 100.0) * 255); b = parseInt((22.0 / 100.0) * 255);
				// r = 255; g = 0; b = 0;
				lerp = 1;
			}
			else
			{
				r = 72; g = 68; b = 64;
				lerp = 0.05;		
			}
			/*
			else if (mLevelStageCount == 2)
			{
				r = 233; g = 197; b = 160;
				r = parseInt(r * 0.4); g = parseInt(g * 0.4); b = parseInt(b * 0.4);
				lerp = 0.05;		
			}
			else if (mLevelStageCount == 1)
			{
				r = 233; g = 197; b = 160;
				r = parseInt(r * 0.4); g = parseInt(g * 0.4); b = parseInt(b * 0.4);
				lerp = 0.05;		
			}
			else
			{
				r = 233; g = 197; b = 160;
				r = parseInt(r * 0.4); g = parseInt(g * 0.4); b = parseInt(b * 0.4);
				lerp = 0.05;		
			}	
			*/
		}
		else if (mLevelType == LevelType.OneHundred)
		{
			r = 64; g = 64; b = 64;
			// r = 128; g = 64; b = 128;
			lerp = 0.05;	
		}
		else if (mUrineState > 0)
		{
			if (mState == 1)
			{
				r = 255; g = 136; b = 0;
				lerp = 1;		
			}
			else
			{
				r = 110; g = 110; b = 40;
				lerp = 0.1;
			}
		}
		/*
		else if ( (mWorldState == 2) && (mState == 1) )
		{
			// due to fail, may have already been red (bleed to white)
			r = parseInt((25.0 / 100.0) * 255); g = parseInt((38.0 / 100.0) * 255); b = parseInt((64.0 / 100.0) * 255);
			// r = 255; g = 255; b = 255;
			lerp = 0.025;
		}
		*/
		else if ((mState == 1) && (mWorldState >= 1))
		{
			// failed: red
			r = parseInt((83.0 / 100.0) * 255); g = parseInt((22.0 / 100.0) * 255); b = parseInt((22.0 / 100.0) * 255);
			lerp = 1;
		}
		/*
		else if (mWorldFreezeTime > 0)
		{
			// level starts with this
			r = parseInt((25.0 / 100.0) * 255); g = parseInt((38.0 / 100.0) * 255); b = parseInt((64.0 / 100.0) * 255);
			lerp = 1;
		}
		*/
	}
	

	if ((backgroundR != r) || (backgroundG != g) || (backgroundB != b))
	{
		if (lerp == 1)
		{
			backgroundR = r;
			backgroundG = g;
			backgroundB = b;		
		}
		else
		{
			backgroundR += ((r - backgroundR) * lerp); if (Math.abs(backgroundR - r) < 1) { backgroundR = r; }  
			backgroundG += ((g - backgroundG) * lerp); if (Math.abs(backgroundG - g) < 1) { backgroundG = g; }
			backgroundB += ((b - backgroundB) * lerp); if (Math.abs(backgroundB - b) < 1) { backgroundB = b; }
		}
		document.body.style.backgroundColor = "rgb(" + parseInt(backgroundR) + "," + parseInt(backgroundG) + "," + parseInt(backgroundB) + ")";
		// document.body.style.backgroundColor = RGBToHex(parseInt(backgroundR), parseInt(backgroundG), parseInt(backgroundB));
	}	
}

var PreserveInnerHTML = "", PreserveColor = "", PreserveTextShadowColor = "", PreserveFontRatio = 0, PreserveAlive = 0, PreserveShakeRatio = 0.0;
function WordShowResize()
{
	WordShow(PreserveInnerHTML, PreserveColor, PreserveTextShadowColor, PreserveFontRatio, PreserveAlive, PreserveShakeRatio);
}

function WordShow(pInnerHTML, pColor = "", pTextShadowColor = "", pFontRatio = 0, pDEADEADAlive = 0, pShakeRatio = 0.0)
{
	PreserveInnerHTML = pInnerHTML; PreserveColor = pColor; PreserveTextShadowColor = pTextShadowColor; PreserveFontRatio = pFontRatio; PreserveAlive = pDEADEADAlive; PreserveShakeRatio = pShakeRatio;

	mWord.style.zIndex = 20;
	mWord.jimOpacity = 1;
	mWord.innerHTML = pInnerHTML;
 
	if (pColor == "") { mWord.jimColor = "#1F0068"; } else { mWord.jimColor = pColor; }
	if (pTextShadowColor == "") { mWord.textShadowColor = "#000000"; } else { mWord.textShadowColor = pTextShadowColor; }

	if (pFontRatio == 0) { mWord.fontRatio = 1; } else { mWord.fontRatio = pFontRatio; }
	mWord.aliveRemember = Date.now();   // starts flying in (make it 0 to put immediately in background)
	mWord.shakeRatio = pShakeRatio;
		
	WordPosition();
}

function WordPosition()
{
	var w = parseInt(window.innerWidth), h = parseInt(window.innerHeight);
	mWord.screenWidth = w;
	mWord.screenHeight = h;

	// <FONT SIZE>
	var fontRatio = -1;
	var size = GetTextSize(mWord.innerHTML, (200) + "px", (200 * 0.85) + "px");
	if (size.width > size.height)
	{
		fontRatio = (w * 0.9) / size.width;
		if (size.height * fontRatio > (h * 0.9)) { fontRatio = (h * 0.9) / size.height; }			
	}
	else
	{
		fontRatio = (h * 0.9) / size.height;
		if (size.width * fontRatio > w) { fontRatio = (w * 0.9) / size.width; }			
	}
	
	mWord.fontSizeMain = 200 * fontRatio * mWord.fontRatio;
	mWord.style.fontSize = parseInt(mWord.fontSizeMain) + "px";
	mWord.style.lineHeight = parseInt(mWord.fontSizeMain * 0.85) + "px";		
	mWord.size = GetTextSize(mWord.innerHTML, mWord.style.fontSize, mWord.style.lineHeight);

	var textShadowColor = "";
	var textShadowSize = -1;
	
	/*
	if (mWord.aliveRemember == 0)
	{
		console.log("MWOARD:" + mWord.textShadowColor);
		var holdOld = hexToRgb(StyleRGBToHex(document.body.style.backgroundColor));
		var holdNew = hexToRgb(mWord.textShadowColor);
		// var holdOld = hexToRgb(mWord.textShadowColor);   // hexToRgb(StyleRGBToHex(document.body.style.backgroundColor));
		// var holdNew = [0, 0, 0]; //  hexToRgb(mWord.textShadowColor);
		
		holdOld[0] = holdOld[0] + ((holdNew[0] - holdOld[0]) * 0.4);
		holdOld[1] = holdOld[1] + ((holdNew[1] - holdOld[1]) * 0.4);
		holdOld[2] = holdOld[2] + ((holdNew[2] - holdOld[2]) * 0.4);

		textShadowColor = RGBToHex(holdOld[0], holdOld[1], holdOld[2]);
		console.log("textShadowColor:" + textShadowColor);
	}
	else
	{
		textShadowColor = mWord.textShadowColor;
	}
	*/
	
	textShadowColor = mWord.textShadowColor;

	textShadowSize = parseInt(mWord.fontSizeMain * 0.04 + 1);
	mWord.style.textShadow = textShadowSize + "px " + textShadowSize + "px " + "0px " + textShadowColor + "66";

	textShadowSize = parseInt(mWord.fontSizeMain * 0.04 * 0.7 + 1);
	if (textShadowSize < 2) { textShadowSize = 2; }
	mWord.innerHTML = mWord.innerHTML.replace(/textShadow75/g, "text-shadow:" + textShadowSize + "px " + textShadowSize + "px " + "0px " + textShadowColor + "66");

	textShadowSize = parseInt(mWord.fontSizeMain * 0.04 * 0.4 + 1);
	if (textShadowSize < 2) { textShadowSize = 2; }
	mWord.innerHTML = mWord.innerHTML.replace(/textShadow50/g, "text-shadow:" + textShadowSize + "px " + textShadowSize + "px " + "0px " + textShadowColor + "66");

	textShadowSize = parseInt(mWord.fontSizeMain * 0.04 * 0.2 + 1);
	if (textShadowSize < 2) { textShadowSize = 2; }
	mWord.innerHTML = mWord.innerHTML.replace(/textShadow25/g, "text-shadow:" + textShadowSize + "px " + textShadowSize + "px " + "0px " + textShadowColor + "66");
	// </FONT SIZE>
		
	// <POSITION>
	var hold = -1;
	hold = parseInt((w - mWord.size.width) * 0.5);
	if (mWord.offsetLeft != hold) { mWord.style.left = hold + "px"; }
	hold = parseInt((h - mWord.size.height) * 0.5);
	if (mWord.offsetTop != hold) { mWord.style.top = hold + "px"; }		
}

function WordUpdateCountdown(pNumber)
{
	switch (pNumber)
	{
	case 1:
	{
		mWord.innerHTML = ""
			+ "ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;<BR>"
			+ "NE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;O<BR>"
			+ "E&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ON<BR>"
			+ "&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE&nbsp;ONE<BR>"
			+ "";
		mWord.innerHTML = mWord.innerHTML.repeat(7);
		mWord.fontRatio = 4.0; 
		mWord.shakeRatio = 0.01;
		break;
	}
	case 2:
	{
		mWord.innerHTML = ""
			+ "TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;<BR>"
			+ "WO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;O<BR>"
			+ "O&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;ON<BR>"
			+ "&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO&nbsp;TWO<BR>"
			+ "";
		mWord.innerHTML = mWord.innerHTML.repeat(4);
		mWord.fontRatio = 8.0; 
		mWord.shakeRatio = 0;
		break;	
	}
	case 3:
	{
		mWord.innerHTML = ""
			+ "THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;<BR>"
			+ "HREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;<BR>"
			+ "REE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;<BR>"
			+ "EE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;<BR>"
			+ "E&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;<BR>"
			+ "&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;THREE&nbsp;<BR>"
			+ "";
		mWord.innerHTML = mWord.innerHTML.repeat(2);
		mWord.fontRatio = 16.0;
		mWord.shakeRatio = 0;
		break;
	}
	}

	mWord.style.zIndex = 1;
	mWord.jimColor = "#FFFFFF";
	mWord.textShadowColor = "#000000";
	mWord.jimOpacity = 0.5;
	WordPosition();
}

function WordUpdateGrow()
{
	mGrowWordTileTotal += 0.1;

	mWord.innerHTML = mGrowCount + "";
	mWord.shakeRatio = 0;
	mWord.style.zIndex = 1;
	mWord.fontRatio = 0.25 * (1.0 + mGrowWordTileTotal * 0.12);

	mWord.jimColor = "#000000";
	mWord.textShadowColor = "#FFFFFF";
	
	/*
	if ((mGrowWordTileTotal % 2) == 0)
	{
		mWord.jimColor = "#FF00FF";
		mWord.textShadowColor = "#FFFFFF";
	}
	else
	{
		mWord.jimColor = "#FFFFFF";
		mWord.textShadowColor = "#FF00FF";
	}
	*/
	let hold = mGrowWordTileTotal * 0.005; if (hold > 1.0) { hold = 1.0; }
	// var hold = 0.25 + mGrowWordTileTotal * 0.025; if (hold > 1.0) { hold = 1.0; }
	mWord.jimOpacity = hold;
	WordPosition();
}

function WordUpdateBoss()
{
	if ((mState != 1) && (mWorldState == 1))
	//	&& ((mLevelStageCount <= 1) || (mTileTotal > 25)) )
	{
		if (mLevelStageCount == 2)
		{	
			// maybe make this like Grow
			mBossWordCounter++;
			if (mBossWordCounter > 60 * 2)
			{
				var holdHTML = "";
				for (var count = 0; count < 4; count++)
				{
					if (count != 0) { holdHTML += "<BR>"; }
					holdHTML += "BSOBSSOBSOBSSO".substr(parseInt(Math.random() * 7), 7);
				}				
				mWord.innerHTML = holdHTML; // "BSOBSSO<BR>OSBSBOS<BR>SOBBSSO<BR>BBOSSOS";
				mWord.shakeRatio = 0.0;
				mWord.style.zIndex = 1;
				mWord.fontRatio = 1;
				mWord.jimColor = "#FFFFFF";
				mWord.textShadowColor = "#000000";
				mWord.jimOpacity = 0.25;
				WordPosition();
				mBossWordCounter = 0;					
			}			
		}
		else if (mLevelStageCount == 1)
		{
			let innerHTML = "";
			if (mTileTotal <= 2)
			{
				innerHTML = "OF COURSE<BR>WE WOULD.";
			}
			else if (mTileTotal <= Math.floor(mTileTotalRemember * 0.5))
			{
				innerHTML = "WOULD WE<BR>DO THAT AGAIN?";
			}
			else
			{
				innerHTML = "BOSS<BR>BOSS<BR>BOSS";
			}						

			if (innerHTML != mWord.innerHTML)
			{
				mWord.innerHTML = innerHTML;
				mWord.shakeRatio = 0.0;
				mWord.style.zIndex = 1;
				mWord.fontRatio = 1;
				mWord.jimColor = "#FFFFFF";
				mWord.textShadowColor = "#000000";
				mWord.jimOpacity = 0.25;
				WordPosition();
			}
		}
		else
		{
			let innerHTML = "";
			if (mTileTotal <= 2)
			{
				innerHTML = "YOU'RE<BR>REALLY NOT.";
			}					
			else if (mTileTotal <= Math.floor(mTileTotalRemember * 0.5))
			{
				innerHTML = "YOU'RE NOT<BR>GOING TO LIKE<BR>WHAT'S COMING.";
			}
			else
			{
				innerHTML = "BO<BR>SS";
			}							

			if (innerHTML != mWord.innerHTML)
			{
				mWord.innerHTML = innerHTML;
				mWord.shakeRatio = 0.0;
				mWord.style.zIndex = 1;
				mWord.fontRatio = 1;
				mWord.jimColor = "#FFFFFF";
				mWord.textShadowColor = "#000000";
				mWord.jimOpacity = 0.25;
				WordPosition();
			}
		}			
	}
}

function WordUpdateUseTheForce()
{
	if ((mState != 1) && (mWorldState == 1))
	{
		let innerHTML = "";

		// <USE THE FORCE>
		if (mUseTheForceState == 2)
		{
			if (mTileTotal <= 2)
			{
				innerHTML = "SHOOT<BR>HAN<BR>CAN'T";
			}
			else if (mTileTotal <= Math.floor(mTileTotalRemember * 0.5))
			{
				innerHTML = "forgotten<BR>all will be";
			}
			else
			{
				innerHTML = "midichlorians<BR>you have";
			}
		}
		// <USE THE FORCE>

		// <NOTHING WILL CHANGE>
		else
		{
			if (mTileTotal <= 2)
			{
				innerHTML = "NOTHING";
			}
			else if (mTileTotal <= Math.floor(mTileTotalRemember * 0.5))
			{
				innerHTML = "should you succeed<BR>nothing will change";
			}
			else
			{
				innerHTML = "repeat what you did<BR>without help";
			}					
		}
		// </NOTHING WILL CHANGE>

		if (innerHTML != mWord.innerHTML)
		{
			mWord.innerHTML = innerHTML;
			mWord.shakeRatio = 0.0;
			mWord.style.zIndex = 1;
			mWord.fontRatio = 1;
			mWord.jimColor = "#FFFFFF";
			mWord.textShadowColor = "#000000";
			mWord.jimOpacity = 0.25;
			WordPosition();
		}
	}
}

function WordUpdateBackgroundWeekday()
{
	if ((mGrowCount > 0) && (mState != 1))
	{
		WordUpdateGrow();
	}

	else if (mWord.tileTotal != mTileTotal)
	{
		mWord.tileTotal = mTileTotal;

		if (mState == 1)
		{
			mWord.innerHTML = "";
			mWord.shakeRatio = 0;
			mWord.style.zIndex = 1;
			mWord.fontRatio = 1;
			mWord.jimColor = "#FFFFFF";
			mWord.textShadowColor = "#00FFFF";
			mWord.jimOpacity = 1;
			WordPosition();
		}
		
		else if (mUseTheForceState > 0)
		{
			WordUpdateUseTheForce();
		}	

		else if ((mWeekdayLevelsRemaining == 1) && (mTileTotal <= 25) )
		{
			if (mTileTotal == 2)
			{
				switch (mWorldDayOfWeek)
				{
					case 0: { mWord.innerHTML = "HAPPY<BR>HOLLOWS<BR>SUNDAY<BR>LOVING"; break; }
					case 1: { mWord.innerHTML = "HAPPY<BR>HOLLOWS<BR>KILLING<BR>MONDAYS"; break; }
					case 2: { mWord.innerHTML = "HAPPY<BR>HOLLOWS<BR>TOTALLY<BR>TUESDAY"; break; }
					case 3: { mWord.innerHTML = "HAPPY<BR>HOLLOWS<BR>WEDNESDAY<BR>HUMPING"; break; }
					case 4: { mWord.innerHTML = "HAPPY<BR>HOLLOWS<BR>THURTTING<BR>THURSDAYS"; break; }
					case 5: { mWord.innerHTML = "HAPPY<BR>HOLLOWS<BR>FREAKING<BR>FRIDAYS"; break; }
					case 6: { mWord.innerHTML = "HAPPY<BR>HOLLOWS<BR>SIZZLING<BR>SATURDAY"; break; }
				}
				mWord.shakeRatio = 0.01;
				mWord.style.zIndex = 1;
				mWord.fontRatio = 1;
				mWord.jimColor = "#FFFFFF";
				mWord.textShadowColor = "#00FFFF";
				mWord.jimOpacity = 1;
				WordPosition();
			}
			else
			{
				let innerHTML = "";
				if (mWorldDayOfWeek == 0)
				{
					innerHTML = "Artist: The Happy Hollows<BR>Song: Silver<BR>Album: Spells<BR>2009";
				} 
				else if ( (mWorldDayOfWeek == 1) || (mWorldDayOfWeek == 4) )
				{
					innerHTML = "Artist: The Happy Hollows<BR>Song: Concordia<BR>Album: Concordia<BR>2017";
				} 
				else if ( (mWorldDayOfWeek == 2) || (mWorldDayOfWeek == 5) )
				{
					innerHTML = "Artist: The Happy Hollows<BR>Song: Chop Lifter<BR>Album: Amethyst<BR>2013";
				}
				else if ( (mWorldDayOfWeek == 3) || (mWorldDayOfWeek == 6) )
				{
					innerHTML = "Artist: The Happy Hollows<BR>Song: Endless<BR>Album: Amethyst<BR>2013";
				}

				if (mWord.innerHTML != innerHTML)
				{
					mWord.innerHTML = innerHTML;
					mWord.shakeRatio = 0.0;
					mWord.style.zIndex = 1;
					mWord.fontRatio = 1;
					mWord.jimColor = "#FFFFFF";
					mWord.textShadowColor = "#000000";
					mWord.jimOpacity = 0.25;
					WordPosition();
				}
			}			
		}
		
		else if (mTileTotal <= 4)
		{
			WordUpdateCountdown(mTileTotal - 1)
		}
		
		else
		{
			mWord.innerHTML = (mTileTotal - 1) + "";
			mWord.shakeRatio = 0.0;
			mWord.style.zIndex = 1;
			mWord.fontRatio = 1; 
			mWord.jimColor = "#FFFFFF";
			mWord.textShadowColor = "#000000";
			mWord.jimOpacity = 0.25;
			WordPosition();				
		}	
	}
}

function WordUpdateBackground()
{
	/*
	if (mState == 0)
	{
		mWord.innerHTML = "THINKING...";
		mWord.shakeRatio = 0.0;
		mWord.style.zIndex = 1;
		mWord.fontRatio = 1; 
		mWord.jimColor = "#FFFFFF";
		mWord.textShadowColor = "#000000";
		mWord.jimOpacity = 0.25;
		WordPosition();				
	}
	*/

	if (mWorldState == 0)
	{
		if (mWorldResetUpdateCount >= 50)
		{
			var s = "Creating " + (mLevelGenerateCount + 1);
			s += "<BR>" + Object.keys(WorldType)[mWorldType]; 
	
			var seconds = parseInt((Date.now() - mSolveStart) / 1000);
			var minutes = parseInt(seconds / 60);
			seconds -= minutes * 60;

			s += "<BR>";
			if (minutes > 0) { s += minutes + "m, "; }			
			if (seconds != 1) { s += seconds + " seconds"; } else { s += seconds + " second"; }

			s += ""
				+ "<BR>Attempt " + (mSolveStatAttempt + 1).toLocaleString()
				+ "<BR>Solutions:" + mSolutions
				+ "<BR>" + mTileXCount + "x" + mTileYCount;

			if ( (mState != 1) && (mSolveUpdateCount > 0) && (mSolutions == 0) )
			{
				s += "<BR>Solving " + mSolveUpdateCount;
			}
			else
			{
				s += "<BR>&nbsp;";
			}
			
			mWord.innerHTML = s;

			mWord.shakeRatio = 0.0;
			mWord.style.zIndex = 4;
			mWord.fontRatio = 0.8;
			mWord.jimColor = "#FFFFFF"; // "#000000";
			mWord.textShadowColor = "#000000";
			mWord.jimOpacity = 1;   // otherwise tiles underneath show		
			
			WordPosition();
		}
	}
	
	// <FAIL>
	else if ( (mState == 1) || (mPlayer.xyIndex == mRestart.xyIndexRemember) )
	{
		if (mWord.innerHTML != "")
		{
			mWord.innerHTML = "";
			mWord.shakeRatio = 0.0;
			mWord.style.zIndex = 1;
			mWord.fontRatio = 1;
			mWord.jimColor = "#FFFFFF";
			mWord.textShadowColor = "#000000";
			mWord.jimOpacity = 0.25;
			WordPosition();
		}
	}
	// </FAIL>
	
	// <TURNS>
	else if (mTalkStates[TalkType.turns] > 0)
	{
		var holdTurnTotal = mSolvedPlayfieldTurn[0]; if (mTalkStates[TalkType.turns] == 2) { holdTurnTotal = mSolvedPlayfieldTurn[1]; }
		if (mPlayer.turns == holdTurnTotal)
		{
			mWord.innerHTML = "<DIV Style='font-size:50%;line-height:100%;textShadow50;'>" + holdTurnTotal + "</DIV>";
			mWord.shakeRatio = 0.01;
			mWord.style.zIndex = 1;
			mWord.fontRatio = 1;
			mWord.jimColor = "#FFFF00";
			mWord.textShadowColor = "#FFFFFF";
			mWord.jimOpacity = 1;
			WordPosition();
		}
		else
		{
			if (mTalkStates[TalkType.turns] == 2)
			{
				mWord.innerHTML = "<DIV Style='font-size:50%;line-height:100%;textShadow50;'>MOST<BR>" + mPlayer.turns + " / " + mSolvedPlayfieldTurn[1] + "</DIV>";
			}
			else
			{
				mWord.innerHTML = "<DIV Style='font-size:50%;line-height:100%;textShadow50;'>LEAST<BR>" + mPlayer.turns + " / " + mSolvedPlayfieldTurn[0] + "</DIV>";
			}
			mWord.shakeRatio = 0.0;
			mWord.style.zIndex = 1;
			mWord.fontRatio = 1;
			mWord.jimColor = "#FFFFFF";
			mWord.textShadowColor = "#00FFFF";
			mWord.jimOpacity = 1;
			WordPosition();
		}
	}
	// </TURNS>

	// <BOSS>
	// switches back to Happy Hollows ending
	else if ((mLevelType == LevelType.Boss) && (mState != 1))
	{
		WordUpdateBoss();
	}
	
	else if ((mGrowCount > 0) && (mState != 1))
	{
		WordUpdateGrow();
	}
	
	else if (mTileTotal != mWord.tileTotal)
	{
		mWord.tileTotal = mTileTotal;
		var total = mStatNewFrankLoss + mStatNewFrankWin + 1;
	
		if (
			(mWorldLevelCount <= 1)
			&& ((mLevelType == LevelType.Regular) || (mLevelType == LevelType.Tricky))
		)
		{
			if (mTileTotal <= 2)
			{
				mWord.innerHTML = "IT'S A<BR>GOODIE";
				mWord.shakeRatio = 0.05;
			}
			else
			{
				mWord.innerHTML = "FRANK'S<BR>STORY";
				mWord.shakeRatio = 0.0;
			}
			mWord.style.zIndex = 1;
			mWord.fontRatio = 1;
			mWord.jimColor = "#FFFFFF";
			mWord.textShadowColor = "#000000";
			mWord.jimOpacity = 0.25;
			WordPosition();						
		}

		// <BONUS> BONUD
		else if ( (mLevelType != LevelType.Regular) && (mLevelType != LevelType.Tricky) )
		{
			if (mTileTotal <= 2)
			{
				switch (mLevelType)
				{
					case LevelType.Bonus: { mWord.innerHTML = "HAPPY<BR>HOLLOWS<BR>4EVAH"; break; }
					case LevelType.Boss: { mWord.innerHTML = "HAPPY<BR>HOLLOWS<BR>IS BOSS"; break; }
					case LevelType.MileStone: { mWord.innerHTML = "HAPPY<BR>HOLLOWS<BR>ARE LEGENDS"; break; }
					case LevelType.OneHundred: { mWord.innerHTML = "HAPPY<BR>FREAKING<BR>HOLLOWS"; break; }
				}
				mWord.shakeRatio = 0.01;
				mWord.style.zIndex = 1;
				mWord.fontRatio = 1;
				mWord.jimColor = "#FFFFFF";
				mWord.textShadowColor = "#00FFFF";
				mWord.jimOpacity = 1;
				WordPosition();
			}
			else if (mTileTotal <= 25)
			{
				let innerHTML = "";
				switch (mLevelType)
				{
					case LevelType.Bonus: { innerHTML = "Artist: The Happy Hollows<BR>Song: Endless<BR>Album: Amethyst<BR>2013"; break; }
					case LevelType.Boss: { innerHTML = "Artist: The Happy Hollows<BR>Song: Chop Lifter<BR>Album: Amethyst<BR>2013"; break; }
					case LevelType.MileStone: { innerHTML = "Artist: The Happy Hollows<BR>Song: Concordia<BR>Album: Concordia<BR>2017"; break; }
					case LevelType.OneHundred: { innerHTML = "Artist: The Happy Hollows<BR>Song: Silver<BR>Album: Spells<BR>2009"; break; }
				}
				
				if (mWord.innerHTML != innerHTML)
				{
					mWord.innerHTML = innerHTML;
					if (mLevelType == LevelType.OneHundred)
					{
						mWord.shakeRatio = 0.0;
						mWord.style.zIndex = 1;
						mWord.fontRatio = 1;
						mWord.jimColor = "#FFFFFF";
						mWord.textShadowColor = "#00FFFF";
						mWord.jimOpacity = 1;
					}
					else
					{
						mWord.shakeRatio = 0.0;
						mWord.style.zIndex = 1;
						mWord.fontRatio = 1;
						mWord.jimColor = "#FFFFFF";
						mWord.textShadowColor = "#000000";
						mWord.jimOpacity = 0.25;
					}
					WordPosition();
				}
			}
			else
			{
				switch (mLevelType)
				{
					case LevelType.Bonus: { mWord.innerHTML = "BON<BR>US"; break; }
					case LevelType.Boss: { mWord.innerHTML = "BO<BR>SS"; break; }
					case LevelType.MileStone: { mWord.innerHTML = "MILE<BR>STONE"; break; }
					case LevelType.OneHundred: { mWord.innerHTML = total.toLocaleString(); break; }
				}					
				if (mLevelType == LevelType.OneHundred)
				{
					mWord.shakeRatio = 0.0;
					mWord.style.zIndex = 1;
					mWord.fontRatio = 1;
					mWord.jimColor = "#FFFFFF";
					mWord.textShadowColor = "#00FF00";
					mWord.jimOpacity = 1;
				}
				else
				{
					mWord.shakeRatio = 0.0;
					mWord.style.zIndex = 1;
					mWord.fontRatio = 1;
					mWord.jimColor = "#FFFFFF";
					mWord.textShadowColor = "#000000";
					mWord.jimOpacity = 0.25;
				}
				WordPosition();
			}
		}
		// </BONUS> BONUD

		// <URINESTATE>			
		else if (mUrineState != 0)
		{
			if (mUrineState > 0)
			{
				if (mTileTotal <= 2)
				{
					mWord.innerHTML = "I REGRET<BR>NOTHING";
					mWord.shakeRatio = 0.005;
					mWord.style.zIndex = 1;
					mWord.fontRatio = 1;
					mWord.jimColor = "#FFFFFF";
					mWord.textShadowColor = "#FF0000";
					mWord.jimOpacity = 1;
					WordPosition();
				}
				else if (mTileTotal <= parseInt(mTileTotalRemember * 0.4))
				{
					mWord.innerHTML = "CONFESSION<BR>it was me";;
					mWord.shakeRatio = 0.0;
					mWord.style.zIndex = 1;
					mWord.fontRatio = 1;
					mWord.jimColor = "#FFFF00";
					mWord.textShadowColor = "#FF0000";
					mWord.jimOpacity = 0.25;
					WordPosition();
				}
				else
				{
					mWord.innerHTML = "URINE";
					mWord.shakeRatio = 0.0;
					mWord.style.zIndex = 1;
					mWord.fontRatio = 1;
					mWord.jimColor = "#FFFF00";
					mWord.textShadowColor = "#FF0000";
					mWord.jimOpacity = 0.25;
					WordPosition();
				}
			}
			else if (mUrineState < 0)
			{
				if (mTileTotal <= 2)
				{
					mWord.innerHTML = "SEE?";
					mWord.shakeRatio = 0.01;
					mWord.style.zIndex = 1;
					mWord.fontRatio = 1.4;
					mWord.jimColor = "#FFFF00";
					mWord.textShadowColor = "#00FF00";
					mWord.jimOpacity = 1;			
					WordPosition();						
				}
				else if (mTileTotal <= parseInt(mTileTotalRemember * 0.4))
				{
					mWord.innerHTML = "SEE!";
					mWord.shakeRatio = 0.0;
					mWord.style.zIndex = 1;
					mWord.fontRatio = 1;
					mWord.jimColor = "#00FF00";
					mWord.textShadowColor = "#FFFF00";
					mWord.jimOpacity = 1;			
					WordPosition();						
				}
				else
				{
					mWord.innerHTML = "YOU'LL<BR>SEE.";
					mWord.shakeRatio = 0.0;
					mWord.style.zIndex = 1;
					mWord.fontRatio = 1;
					mWord.jimColor = "#FFFF00";
					mWord.textShadowColor = "#FF0000";
					mWord.jimOpacity = 0.25;
					WordPosition();
				}
			}
		}
		// </URINESTATE>
		
		// <USETHEFORCE>
		else if (mUseTheForceState > 0)
		{
			WordUpdateUseTheForce();
		}
		// </USETHEFORCE>
		
		else if (mTileTotal <= 4)
		{
			WordUpdateCountdown(mTileTotal - 1)
		}
		
		else
		{
			mWord.innerHTML = (mTileTotal - 1) + "";
			mWord.shakeRatio = 0.0;
			mWord.style.zIndex = 1;
			mWord.fontRatio = 1; 
			mWord.jimColor = "#FFFFFF";
			mWord.textShadowColor = "#000000";
			mWord.jimOpacity = 0.25;
			WordPosition();				
		}	
	}
	
	// SVG Background Idea
	// mWord.jimColor = document.body.style.backgroundColor;
	// mWord.jimOpacity = 1.0;
}

var mBossWordCounter = 0;
function WordUpdate()
{
	var w = parseInt(window.innerWidth), h = parseInt(window.innerHeight);

	if ((mWord.aliveRemember != 0) && ((Date.now() - mWord.aliveRemember) > 3000))
	{
		mWord.aliveRemember = 0; mWord.tileTotal = -1;
	}

	if (mWord.shakeRatio > 0.0)
	{
		var shakeAngle = 0;
		do
		{
			shakeAngle = Math.PI * 2 * Math.random();
			var diff = Math.abs(shakeAngle - mWord.shakeRatioAngleOld);
			if (diff > Math.PI) { diff = Math.PI * 2 - diff; }
		}
		while (diff < Math.PI * 0.5)
		mWord.shakeRatioAngleOld = shakeAngle;
	}

	// <BACKGROUND>
	if (mWord.aliveRemember == 0)
	{	
		if (mWorldUpdateTitleRunning == 0)    // ONLY applies to the Title Screen "You Can Always Go Back"
		{
			if (mWorldMode > 0) { WordUpdateBackgroundWeekday(); } else { WordUpdateBackground(); }
		}
	}
	// </BACKGROUND>	
	else
	// <FOREGROUND/SHRINKING>
	{
		mWord.jimOpacity = 1;
		mWord.jimOpacityFinal = mWord.jimOpacity;		
		mWord.jimColor = "#FFFF60";
		mWord.textShadowColor = "#000000";
			
		if (mWord.shakeRatio == 0.0)
		{
			var fontRatio = -1;
			var size = GetTextSize(mWord.innerHTML, (200) + "px", (200 * 0.85) + "px");
			if (size.width > size.height)
			{
				fontRatio = w / size.width;
				if (size.height * fontRatio > h) { fontRatio = h / size.height; }			
			}
			else
			{
				fontRatio = h / size.height;
				if (size.width * fontRatio > w) { fontRatio = w / size.width; }			
			}
			
			let ratio = (Date.now() - mWord.aliveRemember);
			if (ratio > 1600) { ratio = 1600; }
			ratio = 1.0 - (ratio / 2500.0);
			mWord.fontSizeMain = ratio * (200.0 * fontRatio * mWord.fontRatio);
		
			// mWord.fontSizeMain = 200 * fontRatio * mWord.fontRatio
			// console.log(mWord.fontSizeMain + "!!!");
			mWord.style.fontSize = parseInt(mWord.fontSizeMain) + "px";
			mWord.style.lineHeight = parseInt(mWord.fontSizeMain * 0.85) + "px";		
			mWord.size = GetTextSize(mWord.innerHTML, mWord.style.fontSize, mWord.style.lineHeight);

			mWord.style.left = parseInt((w - mWord.size.width) * 0.5) + "px";
			mWord.style.top = parseInt((h - mWord.size.height) * 0.5) + "px";

			var textShadowSize = parseInt(mWord.fontSizeMain * 0.05 + 1);
			mWord.style.textShadow = textShadowSize + "px " + textShadowSize + "px " + "0px " + mWord.textShadowColor + "66";   // adding the alpha for shadow
		}
	}
	// </FOREGROUND/SHRINKING>

	if (mWord.shakeRatio > 0.0)
	{
		mWord.style.left = parseInt((w - mWord.size.width) * 0.5 + Math.cos(shakeAngle) * (mWord.fontSizeMain * mWord.shakeRatio)) + "px";
		mWord.style.top = parseInt((h - mWord.size.height) * 0.5 + Math.sin(shakeAngle) * (mWord.fontSizeMain * mWord.shakeRatio)) + "px";	
	}
	
	if ( (mWord.screenWidth != w) || (mWord.screenHeight != h) ) { WordPosition(); }


	if (mWord.jimOpacity == 1.0)
	{
		if (mWord.style.color != mWord.jimColor)
		{
			mWord.style.color = mWord.jimColor;
			mWord.jimOpacityFinal = mWord.jimOpacity;
		}
	}
	else
	{
		if (
			(document.body.style.backgroundColor != documentBodyStyleBackgroundColor)
			|| (mWord.jimOpacityFinal != mWord.jimOpacity)
		)
		{
			var holdOld = hexToRgb(StyleRGBToHex(document.body.style.backgroundColor));
			var holdNew = hexToRgb(mWord.jimColor);
			
			holdOld[0] = holdOld[0] + ((holdNew[0] - holdOld[0]) * mWord.jimOpacity);
			holdOld[1] = holdOld[1] + ((holdNew[1] - holdOld[1]) * mWord.jimOpacity);
			holdOld[2] = holdOld[2] + ((holdNew[2] - holdOld[2]) * mWord.jimOpacity);
		
			mWord.style.color = RGBToHex(holdOld[0], holdOld[1], holdOld[2]);

			documentBodyStyleBackgroundColor = document.body.style.backgroundColor;
			mWord.jimOpacityFinal = mWord.jimOpacity;
		}
	}
}

// https://bost.ocks.org/mike/shuffle/
function ShuffleArray(array) {
  var m = array.length, t, i;

  // While there remain elements to shuffle…
  while (m) {

    // Pick a remaining element…
    i = Math.floor(Math.random() * m--);

    // And swap it with the current element.
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}


// ---------------------------------------------------------------------------------------------------------------------
// <TILES>
// ---------------------------------------------------------------------------------------------------------------------
function TilesWhite()
{	
	// doesn't touch State of tiles, JUST the colour
	// do this for hidden tiles
	// do this for tiles taht aren't part of playfield (because they might get added)
	var tile = null;
	for (var index = 0; index < mPlayFieldDivs.length; index++)
	{
		tile = mPlayFieldDivs[index];
		if (mUrineState > 0)
		{
			TileSetColor(tile, 255, 255, 192, 1);
		}
		else if (mTalkStates[TalkType.fail] == 0)
		{
			TileSetColor(tile, 192, 192, 192, 1);
		}
		// player touched visible concrete and now it remeains green (even during fail state)
		// mercy may also being granted
		else if (
			(tile.concreteBlock == 2)
			|| ((tile.concreteBlock > 0) && (mWorldRepeatCount >= 6))
		)
		{
			TileSetColor(tile, 0, 255, 0, 1);
		}		
		// Extra: grant mercy
		else if ((tile.extra > 0) && (mWorldRepeatCount >= 6))
		{
			TileSetColor(tile, 255, 0, 0, 1);
		}
		// Fail. Instant White.
		else if (mState == 1)
		{
			TileSetColor(tile, 255, 255, 255);
		}
		// Concrete. Visible
		else if (tile.concreteBlock < 0)
		{
			TileSetColor(tile, 192, 255, 192, 1);
		}
		// Default. Fade into White
		else
		{
			TileSetColor(tile, 255, 255, 255, 1);			
		}
	}	
}

function TileSetColorTemp(pTile, pMilliseconds, pR, pG, pB)
{
	// Smoothly transitions to this color (temporary), then smoothly returns to colorRFinal,colorGFinal,colorBFinal
	pTile.colorTempTime = mWorldFrameCounter + pMilliseconds / 16;
	// pTile.colorTempTime = Date.now() + pMilliseconds;   // SolveUpdate uses 400. ascend to and hold Temp color for ANOTHER half second
	pTile.colorRTemp = pR;
	pTile.colorGTemp = pG;
	pTile.colorBTemp = pB;
}

function TileSetColor(pTile, pR, pG, pB, pType = 0, pClearTemp = 1)
{
	/*
	pType
	0 - Change BOTH "color" and "colorFinal" (instantly and permanently changes color)
	1 - Change "colorFinal". "color" will work its way toward new permanent "colorFinal" 
	2 - Change "color" - "color" returns to "colorFinal"
	*/

	if (pClearTemp == 1)
	{
		pTile.colorTempTime = 0;
		pTile.colorRTemp = -1; pTile.colorGTemp = -1; pTile.colorBTemp = -1;
	}
	
	if ((pType == 0) || (pType == 1))
	{
		pTile.colorRFinal = pR; pTile.colorGFinal = pG; pTile.colorBFinal = pB;
	}
	if ((pType == 0) || (pType == 2))
	{
		pTile.colorR = pR; pTile.colorG = pG; pTile.colorB = pB;
	}
}


var countTest = 0;
function TilesUpdate()
{
	/*
	Tiles take care of themselves. Think of all tiles as feathers on ONE beast, that SURVIVES between LEVELS.
	EACH tile is a finite state machine, and there are MANY states.
	i.e. Player.Update does NOT change tiles, tiles respond to player
	i.e. Browser Resize explains the new tile placement, BUT TilesUpdate actually places the tiles

	All VisualState changes take place HERE
	0. DEAD. NOT part of this level. NOT MOVING
	1. DYING - either shrinking to 0 or heading toward -100, -100 (enroute to DEAD). 1. Level transition made it NOT part of level OR 2. player remnoved  AFTER failing
	2. Part of this level - UNTOUCHED. Moving only to stay part of the grid.
	3. Part of this level - TOUCHED	
	*/
	countTest = (countTest + 1) % 2;
	
	mCanvasMainContext.clearRect(0, 0, mCanvasMain.width, mCanvasMain.height);

	var tile = null, tileT = null;
	for (var xyIndex = 0; xyIndex < mPlayFieldDivs.length; xyIndex++)
	{	
		tile = mPlayFieldDivs[xyIndex];
		tileT = tile.transform;

		// <TALKSTATE>
		if (tile.visiblePermanent < 0)
		{
			tile.visibleState = countTest;
			tile.visiblePermanent += ((1.0 / 60.0) / 1.5);   // starts at -1 
			if (tile.visiblePermanent >= 0) { tile.visiblePermanent = 0; tile.visibleState = 0; }
		}		
		// </TALKSTATE>
		
		// <TILE UNTOUCHED>
		if ( (mPlayField[xyIndex] > 0) || (mPlayFieldDivs[xyIndex].concreteBlock != 0) )
		{
			switch (tile.visualState)
			{
			case 0:
			{
				// *** 2024-08-29 THIS NEVER HAPPENS ***
				// First time alive! Grow into the space (but don't move)
				tileT.LerpChangeTile(tile.newLeft, tile.newTop, 1, 1, 1, 1);
				tile.visualState = 2;
				break;
			}
			case 1:
			{
				// Was shrinking to top left, return to space
				tile.visualState = 2;
				break;
			}
			case 2:
			{				
				// MAIN. ALL TILES BECOME THIS VISUALSTATE.
				if ( (tile.finishTileState != 0) && (mState != 1) )
				{
					if (tile.finishTileState == 1)
					{
						if ((mWorldFrameCounter % 60) == 0)
						{
							TileSetColor(tile, 255, 255, 0, 1);   // final colour is yellow
							TileSetColor(tile, 0, 0, 0, 2);   // instant blak gradually returning to colorFinal (only set "color", don't touch "colorFinal").
							let ratio = 1.2;  // 1.25 does overlap (which looks terrible) 0.25 also good // (Math.random() < 0.5) ? 1.25 : 0.25;
							if (tileT.jimWidth < mTileSize * ratio)
							{
								tileT.jimWidth = mTileSize * ratio;
								tileT.jimHeight = mTileSize * ratio;
							}
						}
					}
					else if (tile.finishTileState == 2)
					{
						TileSetColor(tile, 0, 255, 255, 1);   // gradual return to permanent gray (only set "colorFinal", don't touch "color")
					}
				}
				
				/*
				else if (xyIndex == mPlayer.xyIndex)
				{
					if ( (tile.colorRFinal != 128) || (tile.colorGFinal != 128) || (tile.colorBFinal != 128) )
					{
						TileSetColor(tile, 128, 128, 128, 0);   // instant permanent gray
					}
					TileSetColor(tile, 255, 0, 0, 0);   // instant permanent gray
				}
				*/

				// <POSITION>
				if ((tileT.jimWidth != mTileSize2) || (tileT.jimLeft != tile.newLeft) || (tileT.jimTop != tile.newTop))
				{
					if (
						(tileT.jimWidth >= mTileSize2 - 1) && (tileT.jimWidth <= mTileSize2 + 1)
						&& (tileT.jimLeft >= tile.newLeft - 1) && (tileT.jimLeft <= tile.newLeft + 1)
						&& (tileT.jimTop >= tile.newTop - 1) && (tileT.jimTop <= tile.newTop + 1)
					)
					{
						tileT.LerpChangeTile(tile.newLeft, tile.newTop, 1, mTileSize2, mTileSize2, 1);
					}
					else
					{
						tileT.LerpChangeTile(tile.newLeft, tile.newTop, 0.05, mTileSize2, mTileSize2, 0.05);
					}
				}
				// </POSITION>

				/*
				// debug
				if (tile.extra > 0)
				{
					tile.colorRFinal = 0; tile.colorGFinal = 255; tile.colorBFinal = 255;
					// tile.div.style.backgroundColor = RGBToHex(tile.colorRFinal, tile.colorGFinal, tile.colorBFinal);
				}
				*/				
				break;
			}
			case 3:
			{
				// I shrunk to nothing, now it's time to come back
				tileT.LerpChangeTile(tile.newLeft, tile.newTop, 1);
				tile.visualState = 2;
				break;
			}
			}
		}
		// </TILE UNTOUCHED>
		
		// <TILE DEAD>
		else if (xyIndex >= mTileXYCount)
		{
			// Tile NOT part of this level. Shrink away to nothing, then 0
			switch (tile.visualState)
			{
			case 0:
			{
				// MAIN. ALL TILES BECOME THIS VISUALSTATE.
				break;
			}
			case 1:
			{
				tile.visualState = 3;
				break;
			}
			case 2:
			{
				tile.visualState = 3;
				break;			
			}
			case 3:
			{
				// Shrink until it can be COMPLETELY REMOVED FROM THOUGHT
				tileT.LerpChangeTile(tileT.jimLeft, tileT.jimTop, 0.05, 1, 1, 0.025);
				if (tileT.jimWidth < 2)
				{
					tileT.LerpChangeTile(-1000, -1000, 1, 1, 1, 1);
					tile.visualState = 0;
				}
				break;
			}			
			}
		}
		// </TILE DEAD>
		
		// <TILE TOUCHED>
		else
		{
			switch (tile.visualState)
			{
			case 0:
			{
				break;
			}
			case 1:
			{
				/*
				// Fail. Shrink to top left corner (tile touched after FAILURE mState = 1). IT MAY RETURN so do NOT make visualState = 0
				if (tileT.jimLeft > -mTileSize * 0.9)
				{
					tileT.LerpChangeTile(-mTileSize, -mTileSize, 0.025, 1, 1, 0.025);
				}
				*/
				/*
				if ((tileT.jimLeft != tile.finalLeft) || (tileT.jimTop != tile.finalTop))
				{
					if (Math.abs(tileT.jimLeft - tile.finalLeft)
					tileT.LerpChangeTile(tile.finalLeft, tile.finalTop, 0.025, 1, 1, 0.025);
				}
				*/
				if (tileT.jimWidth > 0.1)
				{
					tileT.LerpChangeTile(tile.finalLeft, tile.finalTop, 0.025, 1, 1, 0.01);
				}
				break;
			}
			case 2:
			{				
				tile.colorRFinal = 255; tile.colorGFinal = 255; tile.colorBFinal = 255;
				tile.colorRTemp = tile.colorRFinal; tile.colorGTemp = tile.colorGFinal; tile.colorBTemp = tile.colorBFinal;
				tile.colorTempTime = 0;

				if (mState == 1)
				{
					tile.visualState = 1; 
					let angleRadians = Math.atan2(tile.transform.jimTop - mWorldHeight * 0.5, tile.transform.jimLeft - mWorldWidth * 0.5);
					let length = Math.pow(Math.pow(mWorldHeight * 0.5 - tile.transform.jimTop, 2) + Math.pow(mWorldWidth * 0.5 - tile.transform.jimLeft, 2), 0.5);
					tile.finalLeft = tile.transform.jimLeft + Math.cos(angleRadians) * (mWorldWidth * 0.3 + length * 0.18);
					tile.finalTop = tile.transform.jimTop + Math.sin(angleRadians) * (mWorldHeight * 0.3 +  length * 0.18);	
				}
				else
				{
					tile.visualState = 3;
				}
				break;			
			}
			case 3:
			{
				// Success. Shrink away (tile successfully stepped on). IT MAY RETURN so do NOT make visualState = 0
 				if (tileT.jimWidth < 2)
				{
					if (tileT.jimLeft > -1000)
					{
						tileT.LerpChangeTile(-1000, -1000, 1, 1, 1, 1);
					}
				}
				else
				{				
					tileT.LerpChangeTile(tileT.jimLeft, tileT.jimTop, 0.05, 1, 1, 0.025);
				}
				break;
			}	
			case 4:
			{
				// Hole / restart. Hole sucks in all tiles
 				if (tileT.jimWidth < 2)
				{
					if (tileT.jimLeft > -1000)
					{
						tileT.LerpChangeTile(-1000, -1000, 1, 1, 1, 1);
					}
				}
				else
				{					
					let speed = 0.05 + ((tile.index % 4) * 0.25) * 0.05;
					tileT.LerpChangeTile(mRestart.newLeft, mRestart.newTop, speed, 1, 1, 0.06);
				}
				break;
			}			
			}
		}
		// </TILE TOUCHED>		
	}

	// <CANVAS REPLACEMENT>
	// 2024-09-02 Replaced DIVS with CANVAS
	
	// <DRAW LIGHTS OUT>
	if (mTalkStates[TalkType.light] == 0)
	{
		mCanvasMainContext.strokeStyle = "";
		mCanvasMainContext.fillStyle = "rgb(" + 50 + "," + 50 + "," + parseInt(50.0 * (96.0 / 64.0)) + ")";

		for (var xyIndex = 0; xyIndex < mPlayFieldDivs.length; xyIndex++)
		{
			tile = mPlayFieldDivs[xyIndex];

			if (tile.visibleState == 1)
			{
				tileT = tile.transform;

				mCanvasMainContext.beginPath();	

				mCanvasMainContext.ellipse(
					parseInt(tileT.jimLeft)
					, parseInt(tileT.jimTop)
					, parseInt(tileT.jimWidth * 0.5)
					, parseInt(tileT.jimHeight * 0.5)
					, 0, 0, 2 * Math.PI
				);

				mCanvasMainContext.fill();
			}
		}
	}
	// </DRAW LIGHTS OUT>

	else
	{
		let holdStrokeStyle = mCanvasMainContext.strokeStyle;
	
		if (mWorldWidth > 500)
		{
			// <DRAW SHADOW>
			// drains mobile, effect not noticeable on those tiny screens
			mCanvasMainContext.strokeStyle = "#FFFFFF60"; // rgb(255, 255, 255, 128)";
			// mCanvasMainContext.fillStyle = "rgb(32, 32, " + parseInt(32.0 * (96.0 / 64.0)) + ")";		

			for (var xyIndex = 0; xyIndex < mPlayFieldDivs.length; xyIndex++)
			{
				tile = mPlayFieldDivs[xyIndex];			
				if (tile.visibleState == 1)
				{
					tileT = tile.transform;

					mCanvasMainContext.beginPath();	

					mCanvasMainContext.ellipse(
						parseInt(tileT.jimLeft + tileT.jimWidth * 0.075)
						, parseInt(tileT.jimTop + tileT.jimHeight * 0.075)
						, parseInt(tileT.jimWidth * 0.5)
						, parseInt(tileT.jimHeight * 0.5)
						, 0, 0, 2 * Math.PI
					);
					let holdLineWidth = tileT.jimWidth * 0.15;
					if (holdLineWidth < 1) { holdLineWidth = 1; }
					mCanvasMainContext.lineWidth = holdLineWidth;
					mCanvasMainContext.stroke();
					// mCanvasMainContext.fill();
				}
			}
			// </DRAW SHADOW>
		}

		mCanvasMainContext.strokeStyle = holdStrokeStyle;
		// mCanvasMainContext.strokeStyle = "rgb(" + 0 + "," + 0 + "," + 0 + ")";
				
		// <DRAW>
		let holdInt = -1;
		let holdColorRFinal = -1;
		let holdColorGFinal = -1;
		let holdColorBFinal = -1;
		for (var xyIndex = 0; xyIndex < mPlayFieldDivs.length; xyIndex++)
		{
			tile = mPlayFieldDivs[xyIndex];
			if (tile.visibleState == 1)
			{
				tileT = tile.transform;

				holdColorRFinal = tile.colorRFinal;
				holdColorGFinal = tile.colorGFinal;
				holdColorBFinal = tile.colorBFinal;			
				if (tile.colorTempTime > 0)
				{
					if (mWorldFrameCounter > tile.colorTempTime)
					// if (Date.now() > tile.colorTempTime)
					{
						tile.colorTempTime = 0;
					}
					else			
					{
						holdColorRFinal = tile.colorRTemp;
						holdColorGFinal = tile.colorGTemp;
						holdColorBFinal = tile.colorBTemp;		
					}
				}

				// 2 key decisions (tested)
				// . uses mWorldFrameCounter and NOT Date.now() + deltaTime (drastic colour changes are NEVER good, even if it's proper)
				// . linear (not exponential) ascend and descend towards the colour (matched original CSS timer delay, drastic colour changes are NEVER good)
				const speed = 9;   // slowly fade in and out (not too flashy, but enough to reach within 400 milliseconds)

				if (tile.colorR != holdColorRFinal)
				{
					if (tile.colorR < holdColorRFinal)
					{
						tile.colorR += speed; if (tile.colorR > holdColorRFinal) { tile.colorR = holdColorRFinal; }
					}
					else
					{
						tile.colorR -= speed; if (tile.colorR < holdColorRFinal) { tile.colorR = holdColorRFinal; }
					}
				}

				if (tile.colorG != holdColorGFinal)
				{
					if (tile.colorG < holdColorGFinal)
					{
						tile.colorG += speed; if (tile.colorG > holdColorGFinal) { tile.colorG = holdColorGFinal; }
					}
					else
					{
						tile.colorG -= speed; if (tile.colorG < holdColorGFinal) { tile.colorG = holdColorGFinal; }
					}
				}

				if (tile.colorB != holdColorBFinal)
				{
					if (tile.colorB < holdColorBFinal)
					{
						tile.colorB += speed; if (tile.colorB > holdColorBFinal) { tile.colorB = holdColorBFinal; }
					}
					else
					{
						tile.colorB -= speed; if (tile.colorB < holdColorBFinal) { tile.colorB = holdColorBFinal; }
					}
				}

				// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas
				// https://web.dev/articles/canvas-performance
				mCanvasMainContext.beginPath();

				// ellipse applies to BOTH stroke and fill, doing one for each requires sepearte BeginPath likely defeating the purpose
				// ellipse strokes / fills from center. subpixels were happending (border overlap aliasing) regardless of parseInt, so removed
				mCanvasMainContext.ellipse(
					tileT.jimLeft
					, tileT.jimTop
					, tileT.jimWidth * 0.5
					, tileT.jimHeight * 0.5
					, 0, 0, 2 * Math.PI
				);

				let holdLineWidth = tileT.jimWidth * 0.1;
				if (holdLineWidth < 1) { holdLineWidth = 1; }
				mCanvasMainContext.lineWidth = holdLineWidth;
				mCanvasMainContext.stroke();

				// Debug
				// if (tile.extra > 0) { tile.colorR = 255; tile.colorG = 0; tile.colorB = 0; }
				// if (tile.finalTile > 0) { tile.colorR = 0; tile.colorG = 255; tile.colorB = 0; }
				
				mCanvasMainContext.fillStyle = "rgb(" + parseInt(tile.colorR) + "," + parseInt(tile.colorG) + "," + parseInt(tile.colorB) + ")";
				mCanvasMainContext.fill();   // overlaps half the stroke. fixes for that overdraw required more computation and BeginPath removal

				/*
				// ABANDONED OPTIMIZATION 2024-09-04 Might Revisit. Did NOT appear to make much difference but did NOT test thoroughly.
				// Note: SolveUpdate impacts performance so much, drawing optimization makes little difference.
				mCanvasMainContext.beginPath();
				let holdLineWidth = tileT.jimWidth * 0.05;
				if (holdLineWidth < 1) { holdLineWidth = 1; }
				mCanvasMainContext.lineWidth = holdLineWidth;

				holdInt = parseInt(tileT.jimWidth * 0.5);
				mCanvasMainContext.ellipse(
					parseInt(tileT.jimLeft)
					, parseInt(tileT.jimTop)
					, holdInt
					, holdInt
					, 0, 0, 2 * Math.PI
				);
				mCanvasMainContext.stroke();

				mCanvasMainContext.beginPath();
				mCanvasMainContext.fillStyle = "rgb(" + parseInt(tile.colorR) + "," + parseInt(tile.colorG) + "," + parseInt(tile.colorB) + ")";

				holdInt = parseInt(tileT.jimWidth * 0.5 - holdLineWidth * 0.9);
				if (holdInt > 0)
				{
					mCanvasMainContext.ellipse(
						parseInt(tileT.jimLeft)
						, parseInt(tileT.jimTop)
						, holdInt
						, holdInt
						, 0, 0, 2 * Math.PI
					);
					mCanvasMainContext.fill();  // overlaps half the stroke (fixing that would require another .ellipse call)
				}
				*/
			}
		}
		
		// <FINISH TILES>
		// overlap above
		if (mTalkStates[TalkType.finishTile] > 0)
		{
			// Draw outside: a black "border" ALL of them share (not stroke)
			for (var xyIndex = 0; xyIndex < mPlayFieldDivs.length; xyIndex++)
			{
				tile = mPlayFieldDivs[xyIndex];
				tileT = mPlayFieldDivs[xyIndex].transform;
				if (tile.finishTileState > 0)
				{
					mCanvasMainContext.beginPath();
					let holdLineWidth = tileT.jimWidth * 0.05;
					if (holdLineWidth < 1) { holdLineWidth = 1; }
					mCanvasMainContext.ellipse(
						tileT.jimLeft
						, tileT.jimTop
						, tileT.jimWidth * 0.5 + holdLineWidth
						, tileT.jimHeight * 0.5 + holdLineWidth
						, 0, 0, 2 * Math.PI
					);

					mCanvasMainContext.fillStyle = "rgb(0, 0, 0)";
					mCanvasMainContext.fill();   // overlaps half the stroke. fixes for that overdraw required more computation and BeginPath removal
				}
			}
			
			// Draw inside
			for (var xyIndex = 0; xyIndex < mPlayFieldDivs.length; xyIndex++)
			{
				tile = mPlayFieldDivs[xyIndex];
				tileT = mPlayFieldDivs[xyIndex].transform;
				if (tile.finishTileState > 0)
				{
					mCanvasMainContext.beginPath();
					mCanvasMainContext.ellipse(
						tileT.jimLeft
						, tileT.jimTop
						, tileT.jimWidth * 0.5
						, tileT.jimHeight * 0.5
						, 0, 0, 2 * Math.PI
					);
					mCanvasMainContext.fillStyle = "rgb(" + parseInt(tile.colorR) + "," + parseInt(tile.colorG) + "," + parseInt(tile.colorB) + ")";
					mCanvasMainContext.fill();   // overlaps half the stroke. fixes for that overdraw required more computation and BeginPath removal
				}
			}
		}
		// </FINISH TILES>

		// </DRAW>
	}
	// </CANVAS REPLACEMENT>

	mCanvasMainContext.strokeStyle = "rgb(32, 32, " + parseInt(32.0 * (96.0 / 64.0)) + ")";		

	// <BOSS>
	if (
		(mLevelType == LevelType.Boss)
		|| ( (mWorldMode > 0) && (mTileTotalRemember > 180) && (mWeekdayLevelsRemaining != 1) && ((mWeekdayLevelsRemaining % 2) == 1) )
	)
	{
		if (mState != 1)
		{
			mSolveUpdateColorFlag = false;
			mCanvasMainContext.strokeStyle = "rgb(128, 0, 0)";
		
			for (var index = 0; index < mMilestoneRollers.length; index++)
			{
				if (mMilestoneRollers[index].xyIndex == -1)
				{
					mMilestoneRollers[index].xyIndex = (mTileYCount - 1) * mTileXCount + parseInt(Math.random() * mTileXCount);
					mMilestoneRollers[index].speed = 0.1 + Math.random() * 0.1;
					if (mLevelStageCount == 1) { mMilestoneRollers[index].speed *= 1.5; } else if (mLevelStageCount == 2) { mMilestoneRollers[index].speed *= 2.5; } 
					mMilestoneRollers[index].speedCount = 0;
					mMilestoneRollers[index].colorR = 255;
					mMilestoneRollers[index].colorG = 128;
					mMilestoneRollers[index].colorB = 0;
				}

				mMilestoneRollers[index].speedCount += mMilestoneRollers[index].speed;
				if (mMilestoneRollers[index].speedCount > 1)
				{
					mMilestoneRollers[index].speedCount -= 1;
					if (mMilestoneRollers[index].speedCount > 1 * 0.2) { mMilestoneRollers[index].speedCount = 0; }
					
					mMilestoneRollers[index].xyIndex -= mTileXCount;
					if (mMilestoneRollers[index].xyIndex < 0)
					{
						mMilestoneRollers[index].xyIndex = (mTileYCount - 1) * mTileXCount + parseInt(Math.random() * mTileXCount);
						mMilestoneRollers[index].speed = 0.1 + Math.random() * 0.1;
						if (mLevelStageCount == 1) { mMilestoneRollers[index].speed *= 1.5; } else if (mLevelStageCount == 2) { mMilestoneRollers[index].speed *= 2.5; } 
					}

					if(
						(mPlayField[mMilestoneRollers[index].xyIndex] > 0)
						&& (mMilestoneRollers[index].xyIndex != mPlayer.xyIndex)
						&& (mPlayFieldDivs[mMilestoneRollers[index].xyIndex].finishTileState == 0)
					)
					{
						TileSetColorTemp(mPlayFieldDivs[mMilestoneRollers[index].xyIndex], 400, mMilestoneRollers[index].colorR, mMilestoneRollers[index].colorG, mMilestoneRollers[index].colorB);
					}
				}
			}
		}
	}
	// </BOSS>
	
	else if (
		(mState != 1)
		&& (mUseTheForceState == 0)
		&& (mUrineState <= 0)
		&& (mWorldState != 2)
		&& (mScoreUpdated == 0)
		&& (mTalkStates[TalkType.fail] != 0)
	)
	{	
		var hold = mTileTotalRemember * 0.5; if (hold < 10) { hold = 10; }

		// <ONEHUNDRED>
		if (mLevelType == LevelType.OneHundred)
		{
			mCanvasMainContext.strokeStyle = "rgb(128, 255, 128)";
		
			for (var index = 0; index < mMilestoneRollers.length; index++)
			{
				if (mMilestoneRollers[index].xyIndex == -1)
				{
					mMilestoneRollers[index].xyIndex = parseInt(Math.random() * mTileXYCount);
					mMilestoneRollers[index].xyIndex = mTileYCount * mTileXCount + parseInt(Math.random() * mTileXCount);
					mMilestoneRollers[index].speed = 0.2 + parseInt(Math.random() * 2) * 0.01;
					mMilestoneRollers[index].speedCount = 0;
					mMilestoneRollers[index].colorR = 0;
					mMilestoneRollers[index].colorG = 0;
					mMilestoneRollers[index].colorB = 0;

					if ((index % 2) == 0)
					{
						mMilestoneRollers[index].dirX = -1 + parseInt(Math.random() * 2) * 2;
						mMilestoneRollers[index].dirY = 0;
					}
					else
					{
						mMilestoneRollers[index].dirX = 0;
						mMilestoneRollers[index].dirY = -1 + parseInt(Math.random() * 2) * 2;
					}

					mMilestoneRollers[index].dirX = 0;
					mMilestoneRollers[index].dirY = -1;
				}

				mMilestoneRollers[index].speedCount += mMilestoneRollers[index].speed;
				if (mMilestoneRollers[index].speedCount >= 1.0)
				{
					mMilestoneRollers[index].speedCount -= 1.0;

					mMilestoneRollers[index].xyIndex += mMilestoneRollers[index].dirX;					
					mMilestoneRollers[index].xyIndex += (mTileXCount * mMilestoneRollers[index].dirY);

					/*
					if (mMilestoneRollers[index].xyIndex < 0)
					{ mMilestoneRollers[index].xyIndex += mTileXYCount; }
					else if (mMilestoneRollers[index].xyIndex >= mTileXYCount)
					{ mMilestoneRollers[index].xyIndex -= mTileXYCount; }
					*/
					
					if (mMilestoneRollers[index].xyIndex < 0)
					{
						mMilestoneRollers[index].xyIndex = mTileYCount * mTileXCount + parseInt(Math.random() * mTileXCount);
					}
					
					/*
					if (mMilestoneRollers[index].xyIndex < 0)
					{
						if (mTileTotal <= parseInt(hold * 1.5))
						{
							mMilestoneRollers[index].colorR = 128;
							mMilestoneRollers[index].colorG = 255;
							mMilestoneRollers[index].colorB = 255;
							mMilestoneRollers[index].speed = 1; if (Math.random() < 0.5) { mMilestoneRollers[index].speed = 0.5; }
						}
						else
						{
							mMilestoneRollers[index].speed = 0.2 + parseInt(Math.random() * 3) * 0.1;
						}
						mMilestoneRollers[index].xyIndex = (mTileYCount - 1) * mTileXCount + parseInt(Math.random() * mTileXCount);
					}
					*/

					if (
						(mPlayField[mMilestoneRollers[index].xyIndex] > 0)
						&& (mMilestoneRollers[index].xyIndex != mPlayer.xyIndex)
						&& (mPlayFieldDivs[mMilestoneRollers[index].xyIndex].finishTileState == 0)
					)
					{
						TileSetColorTemp(mPlayFieldDivs[mMilestoneRollers[index].xyIndex], 600, mMilestoneRollers[index].colorR, mMilestoneRollers[index].colorG, mMilestoneRollers[index].colorB);
					}
				}
			}
		}
		// </ONEHUNDRED>

		/*
		// <PINK HALFWAY>
		else if ( (mTileTotal < hold) && (mGrowCount == 0) )
		{
			var tile = null;
			for (var index = 0; index < mTileXYCount; index++)
			{
				if ( (mPlayField[index] > 0) && (index != mPlayer.xyIndex) )
				{
					tile = mPlayFieldDivs[index];
					if ( (Math.random() < 0.05) && (tile.finishTileState == 0) )
					{
						if (tile.colorGFinal != 255)
						{
							tile.colorRFinal = 255;
							tile.colorGFinal = 255;
							tile.colorBFinal = 255;
						}
						else
						{
							tile.colorRFinal = 255;
							tile.colorGFinal = 128;
							tile.colorBFinal = 255;
						}
						tile.div.style.backgroundColor = RGBToHex(tile.colorRFinal, tile.colorGFinal, tile.colorBFinal);
					}
				}
			}	
		}
		// </PINK HALFWAY>
		*/

		// <WEEKDAY LAST LEVEL BUBBLING>
		else if ( (mWorldMode == 1) && (mWeekdayLevelsRemaining == 1) && (mGrowCount == 0) )
		{
			mSolveUpdateColorFlag = false;
			
			let count = 20;   // like keeping lots of white ones
			let xyIndex = -1;
			let tile = null;
			while (count > 0)
			{
				xyIndex = parseInt(Math.random() * mPlayFieldDivs.length);
				if (mPlayField[xyIndex] > 0)
				{
					tile = mPlayFieldDivs[xyIndex];
					if (
						(tile.colorTempTime == 0)
						&& ((tile.colorR == tile.colorRFinal) && (tile.colorG == tile.colorGFinal) && (tile.colorB == tile.colorBFinal))
					)
					{
						tileT = tile.transform;
						
						let ratio = (Math.random() < 0.5) ? 0.5 : 1.2;
						tileT.jimWidth = mTileSize * ratio;
						tileT.jimHeight = mTileSize * ratio;


						tile.colorTempTime = 0;
						tile.colorR = parseInt(Math.random() * 128);
						tile.colorG = parseInt(Math.random() * 128);
						tile.colorB = parseInt(Math.random() * 128);

						/*
						// code reference
						// instantly change colour then hold it for 1 second before fading back to colorFinal
						tile.colorR = parseInt(Math.random() * 128);
						tile.colorG = parseInt(Math.random() * 128);
						tile.colorB = parseInt(Math.random() * 128);
						TileSetColorTemp(tile, 500, tile.colorR, tile.colorG, tile.colorB);
						*/
					}
				}
				count--;
			}
		}
		// </WEEKDAY LAST LEVEL BUBBLING>
		
		// <MILESTONE>
		else if ( 
			(mLevelType == LevelType.MileStone)
			|| ( (mWorldMode > 0) && (mTileTotalRemember > 180) && (mWeekdayLevelsRemaining != 1) && ((mWeekdayLevelsRemaining % 2) == 0) )
		)
		{
			mSolveUpdateColorFlag = false;
			mCanvasMainContext.strokeStyle = "rgb(255, 255, 255)";
		
			for (var index = 0; index < mMilestoneRollers.length; index++)
			{
				if (mMilestoneRollers[index].xyIndex == -1)
				{
					mMilestoneRollers[index].xyIndex = parseInt(index * (mTileXYCount / mMilestoneRollers.length));
					mMilestoneRollers[index].speed = 0.5; // 0.2 + Math.random() * 0.2;
					mMilestoneRollers[index].speedCount = 0;
					if (Math.random() < 0.5)
					{
						mMilestoneRollers[index].colorR = 128;
						mMilestoneRollers[index].colorG = 255;
						mMilestoneRollers[index].colorB = 128;
					}
					else
					{
						mMilestoneRollers[index].colorR = 128;
						mMilestoneRollers[index].colorG = 255;
						mMilestoneRollers[index].colorB = 255;
					}
				}
			
				mMilestoneRollers[index].speedCount += mMilestoneRollers[index].speed;
				if (mMilestoneRollers[index].speedCount > 1)
				{
					mMilestoneRollers[index].speedCount -= 1;
					mMilestoneRollers[index].xyIndex--;
					if (mMilestoneRollers[index].xyIndex < 0) { mMilestoneRollers[index].xyIndex = mTileXYCount - 1; }

					if (
						(mPlayField[mMilestoneRollers[index].xyIndex] > 0)
						&& (mMilestoneRollers[index].xyIndex != mPlayer.xyIndex)
						&& (mPlayFieldDivs[mMilestoneRollers[index].xyIndex].finishTileState == 0)
					)
					{
						TileSetColorTemp(mPlayFieldDivs[mMilestoneRollers[index].xyIndex], 400, mMilestoneRollers[index].colorR, mMilestoneRollers[index].colorG, mMilestoneRollers[index].colorB);
					}
				}
			}
		}
		// </MILESTONE>
		
		// <BONUS>
		else if ( (mLevelType == LevelType.Bonus) || (mGrowCount > 0) )
		{
			mCanvasMainContext.strokeStyle = "rgb(255, 255, 0)";
		
			var holdTotal = parseInt(mTileXYCount * 0.075); if (holdTotal > mMilestoneRollers.length) { holdTotal = mMilestoneRollers.length; }
			for (var index = 0; index < holdTotal; index++)
			{
				if (mMilestoneRollers[index].xyIndex == -1)
				{
					mMilestoneRollers[index].xyIndex = parseInt(Math.random() * mTileXYCount);
					if ((index % 2) == 0)
					{
						mMilestoneRollers[index].colorR = 255;
						mMilestoneRollers[index].colorG = 255;
						mMilestoneRollers[index].colorB = 128;
					}
					else
					{
						mMilestoneRollers[index].colorR = 128;
						mMilestoneRollers[index].colorG = 255;
						mMilestoneRollers[index].colorB = 255;
					}					
				}
			
				var newDir = -1;
				mMilestoneRollers[index].speedCount += 1;
				if (mMilestoneRollers[index].speedCount > 1)
				{
					mMilestoneRollers[index].speedCount -= 1;
					
					if (mMilestoneRollers[index].dir == 0)
					{
						mMilestoneRollers[index].xyIndex += mTileXCount;
						if (mMilestoneRollers[index].xyIndex >= mTileXYCount)
						{
							if (Math.random() < 0.5)
							{
								mMilestoneRollers[index].colorR = 255;
								mMilestoneRollers[index].colorG = 255;
								mMilestoneRollers[index].colorB = 128;
							}
							else
							{
								mMilestoneRollers[index].colorR = 128;
								mMilestoneRollers[index].colorG = 255;
								mMilestoneRollers[index].colorB = 255;
							}					
							mMilestoneRollers[index].xyIndex -= mTileXYCount;
						}
						mMilestoneRollers[index].dir = 1;
					}
					else
					{
						mMilestoneRollers[index].xyIndex--;
						if (mMilestoneRollers[index].xyIndex < 0)
						{
							if (Math.random() < 0.5)
							{
								mMilestoneRollers[index].colorR = 255;
								mMilestoneRollers[index].colorG = 255;
								mMilestoneRollers[index].colorB = 128;
							}
							else
							{
								mMilestoneRollers[index].colorR = 128;
								mMilestoneRollers[index].colorG = 255;
								mMilestoneRollers[index].colorB = 255;
							}											
							mMilestoneRollers[index].xyIndex += mTileXYCount;
						}					
						mMilestoneRollers[index].dir = 0;
					}
					
					if (mMilestoneRollers[index].xyIndex != mPlayer.xyIndex)
					{
						var tile = mPlayFieldDivs[mMilestoneRollers[index].xyIndex];
						if (tile.finishTileState == 0)
						{
							TileSetColorTemp(tile, 400, mMilestoneRollers[index].colorR, mMilestoneRollers[index].colorG, mMilestoneRollers[index].colorB);
						}
					}
				}
			}
		}
		// </BONUS>
	}
}

function Tile()
{
	this.index = -1;   // when onload creates tile, assign it a unique id (rarely use this)

	this.div = { }; // new Object(); // document.createElement("div");
	this.div.style =  { };
	this.div.tile = true;
	// this.div.style.cssText = "display:none; position:absolute; transition:background-color 1s; background-color:#ffffff; left:-1000px; top:-1000px; width:10px; Height:10px; z-index:2;";
	// mWorldDiv.appendChild(this.div);
	this.transform = new Transform(this.div);

	this.newLeft = 0;   // unsure why this hasn't evolved into xyIndex
	this.newTop = 0;
	
	this.visualState = 0;   // 0=unused/offscreen 1=onscreen, untouched 2=onscreen, touched 3=onscreen, touched badly
	this.solved = 0;   // During SolveUpdate this is incremented to indicate tile was touched during search
	
	this.colorRFinal = 255;	// Tiles always return to this color. Might always be white.
	this.colorGFinal = 255;
	this.colorBFinal = 255;

	this.colorTempTime = 0;   // Milliseconds to hold Temp color (then revert to -1, -1, -1)
	this.colorRTemp = -1;   // Adjustable colors for Thinking, Bonus, Boss, Milestone and OneHundred
	this.colorGTemp = -1;
	this.colorBTemp = -1;

	// current colour - counters leading up to colorRFinal (formerly DIV colour)
	this.colorR = 0.0;
	this.colorG = 0.0;
	this.colorB = 0.0;
	
	this.finalTile = 0;   // mostly aesthetic, indicates this is the final tile of a solution (possibly multiple)
	this.visiblePermanent = 1;   // Talk can set this to remove tile
	this.visibleState = 1;   // replaced div.style.visibility. defaults to ON. controlled by this.visiblePermanent (previous line)
	this.extra = 0;   // Talk can add extra tiles!
	this.finishTileState = 0;   // 1-rotate and pulse, must end here 2-player already ended here (gray)
	this.concreteBlock = 0;   // 0-not concrete   -1-visible concrete   1-invisible concrete   2-touchedbyplayer

	this.Reset = function(pAll = true)
	{
		if (pAll)
		{
			this.newLeft = 0;   // unsure why this hasn't evolved into xyIndex
			this.newTop = 0;
			
			this.visualState = 0;   // 0=unused/offscreen 1=onscreen, untouched 2=onscreen, touched 3=onscreen, touched badly
			this.solved = 0;
			
			this.colorRFinal = 255;	// adjustable colors for Bonus, Boss, Milestone and OneHundred
			this.colorGFinal = 255;
			this.colorBFinal = 255;
		}

		this.finalTile = 0;
		this.visiblePermanent = 1;   // Talk can set this to remove tile
		this.visibleState = 1;
		this.extra = 0;   // Talk can add extra tiles!
		this.finishTileState = 0;   // 1-rotate and pulse, must end here 2-player already ended here (gray)
		this.concreteBlock = 0;
	}
	
	// Helper methods used ONLY by WorldResetShift. Essentially clones the important values
	this.ShiftSave = function(pObject)
	{
		// Saves settings to a rando
		pObject.finalTile = this.finalTile;
		pObject.visiblePermanent = this.visiblePermanent;
		pObject.visibleState = this.visibleState;
		pObject.extra = this.extra;
		pObject.finishTileState = this.finishTileState;
		pObject.concreteBlock = this.concreteBlock;
	}

	this.ShiftLoad = function(pObject)
	{
		// Loads settings from some rando (presumably same random we ShiftSaved to)
		this.finalTile = pObject.finalTile;
		this.visiblePermanent = pObject.visiblePermanent;
		this.visibleState = pObject.visibleState;
		this.extra = pObject.extra;
		this.finishTileState = pObject.finishTileState;
		this.concreteBlock = pObject.concreteBlock;
	}
	
}


// ---------------------------------------------------------------------------------------------------------------------
// <MISC>
// ---------------------------------------------------------------------------------------------------------------------

/**
* Convert a three or six digit hexcode to srgb
* @param {string} hex - The hexcode
* @return {number[]} The srgb tuple
*/
function hexToRgb(hex) {
// If 3 digit hexcode then double each digit 6 digit
const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
hex = hex.replace(shorthandRegex, function(m, r, g, b) {
  return r + r + g + g + b + b;
});
// Use built-in base16 parser to convert to rgb
const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
// Cant use map since first element of result is the whole matched string
// Do not need to add 0 since parseInt converts -0 to 0
return result ?
  [parseInt(result[1], 16), parseInt(result[2], 16),
	parseInt(result[3], 16)] :
  null;
}

// https://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
// Version 4.0
const pSBC=(p,c0,c1,l)=>{
    let r,g,b,P,f,t,h,i=parseInt,m=Math.round,a=typeof(c1)=="string";
    if(typeof(p)!="number"||p<-1||p>1||typeof(c0)!="string"||(c0[0]!='r'&&c0[0]!='#')||(c1&&!a))return null;
    if(!this.pSBCr)this.pSBCr=(d)=>{
        let n=d.length,x={};
        if(n>9){
            [r,g,b,a]=d=d.split(","),n=d.length;
            if(n<3||n>4)return null;
            x.r=i(r[3]=="a"?r.slice(5):r.slice(4)),x.g=i(g),x.b=i(b),x.a=a?parseFloat(a):-1
        }else{
            if(n==8||n==6||n<4)return null;
            if(n<6)d="#"+d[1]+d[1]+d[2]+d[2]+d[3]+d[3]+(n>4?d[4]+d[4]:"");
            d=i(d.slice(1),16);
            if(n==9||n==5)x.r=d>>24&255,x.g=d>>16&255,x.b=d>>8&255,x.a=m((d&255)/0.255)/1000;
            else x.r=d>>16,x.g=d>>8&255,x.b=d&255,x.a=-1
        }return x};
    h=c0.length>9,h=a?c1.length>9?true:c1=="c"?!h:false:h,f=this.pSBCr(c0),P=p<0,t=c1&&c1!="c"?this.pSBCr(c1):P?{r:0,g:0,b:0,a:-1}:{r:255,g:255,b:255,a:-1},p=P?p*-1:p,P=1-p;
    if(!f||!t)return null;
    if(l)r=m(P*f.r+p*t.r),g=m(P*f.g+p*t.g),b=m(P*f.b+p*t.b);
    else r=m((P*f.r**2+p*t.r**2)**0.5),g=m((P*f.g**2+p*t.g**2)**0.5),b=m((P*f.b**2+p*t.b**2)**0.5);
    a=f.a,t=t.a,f=a>=0||t>=0,a=f?a<0?t:t<0?a:a*P+t*p:0;
    if(h)return"rgb"+(f?"a(":"(")+r+","+g+","+b+(f?","+m(a*1000)/1000:"")+")";
    else return"#"+(4294967296+r*16777216+g*65536+b*256+(f?m(a*255):0)).toString(16).slice(1,f?undefined:-2)
}

// https://stackoverflow.com/questions/1740700/how-to-get-hex-color-value-rather-than-rgb-value
function StyleRGBToHex(rgb) {
    rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
    function hex(x) {
        return ("0" + parseInt(x).toString(16)).slice(-2);
    }
    return "#" + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]);
}

function RGBToHex(r,g,b){
    var bin = r << 16 | g << 8 | b;
    return "#" + (function(h){
        return new Array(7-h.length).join("0")+h
    })(bin.toString(16).toUpperCase());
}

function RotateDiv(pDiv, pDegree)
{
    pDiv.style.webkitTransform = "rotate(" + pDegree + "deg)";
    pDiv.style.mozTransform = "rotate(" + pDegree + "deg)"; 
    pDiv.style.msTransform = "rotate(" + pDegree + "deg)"; 
    pDiv.style.oTransform = "rotate(" + pDegree + "deg)";
    pDiv.style.transform = "rotate(" + pDegree + "deg)";
	pDiv.jimRotate = (parseFloat(pDegree) * Math.PI) / 180.0;
}

// https://www.w3schools.com/js/js_cookies.asp
function setCookie(cname, cvalue, exdays = 365 * 20) {
  var d = new Date();
  d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
  var expires = "expires="+d.toUTCString();
  document.cookie = cname + "3" + "=" + cvalue + ";" + expires + ";path=/";
}

function getCookie(cname, pDefault = "") {
  var name = cname + "3" + "=";
  var ca = document.cookie.split(';');
  for(var i = 0; i < ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) == ' ') {
      c = c.substring(1);
    }
    if (c.indexOf(name) == 0) {
      return c.substring(name.length, c.length);
    }
  }
  return pDefault;
}

function WorldCountersLoad()
{	
	mWorldTypeCounter = -1;
	if (getCookie("WorldTypeCounter") != "") { mWorldTypeCounter = parseInt(getCookie("WorldTypeCounter")); }
	mWorldTypeBonusCounter = -1;
	if (getCookie("WorldTypeBonusCounter") != "") { mWorldTypeBonusCounter = parseInt(getCookie("WorldTypeBonusCounter")); }
	mWorldTypeMilestoneCounter = -1;
	if (getCookie("WorldTypeMilestoneCounter") != "") { mWorldTypeMilestoneCounter = parseInt(getCookie("WorldTypeMilestoneCounter")); }	
}

function WorldCountersSave()
{
	setCookie("WorldTypeCounter", mWorldTypeCounter);
	setCookie("WorldTypeBonusCounter", mWorldTypeBonusCounter);
	setCookie("WorldTypeMilestoneCounter", mWorldTypeMilestoneCounter);	
}

function Transform(pParentDiv)
{
	// these are float versions of the CSS properties, so I can nicely lerp them
	// just VISUAL properties, you cannot use jimLeft/jimTop to determine what tile item is on
	// these properties would usually be provided by inheritance, but javascript makes that hard
	// i'm providing it via encapsulation. i.e. every tile has Transform
	this.parentDiv = pParentDiv;
	
	this.jimLeft = 0;
	this.jimTop = 0;
	this.jimWidth = 0;
	this.jimHeight = 0;
	this.jimRotate = 0;
	
	this.LerpChangeTile = function(
		pDestLeft, pDestTop, pPercentageLeft
		, pDestWidth = -1, pDestHeight = -1, pPercentageWidth = -1	
	)
	{
		// ensure a perfect lerp (1) absolutely 100% matches (doesn't just get near)
		// outside routines WILL BE COMPARING FLOATS, so must be perfect
		if (pDestWidth > -1)
		{
			if (pPercentageWidth == 1)
			{
				this.jimWidth = pDestWidth; this.jimHeight = pDestHeight;
			}
			else
			{
				this.jimWidth += (pDestWidth - this.jimWidth) * pPercentageWidth;
				this.jimHeight += (pDestHeight - this.jimHeight) * pPercentageWidth;
			}			
		}
		
		if (pPercentageLeft == 1)
		{
			this.jimLeft = pDestLeft; this.jimTop = pDestTop;
		}
		else
		{
			this.jimLeft += (pDestLeft - this.jimLeft) * pPercentageLeft;
			this.jimTop += (pDestTop - this.jimTop) * pPercentageLeft;
		}
	}
	
	this.LerpChange = function(
		pDestLeft, pDestTop, pPercentageLeft
		, pDestWidth = -1, pDestHeight = -1, pPercentageWidth = -1	
	)
	{
		// ensure a perfect lerp (1) absolutely 100% matches (doesn't just get near)
		// outside routines WILL BE COMPARING FLOATS, so must be perfect
		if (pDestWidth > -1)
		{
			if (pPercentageWidth == 1)
			{
				this.jimWidth = pDestWidth; this.jimHeight = pDestHeight;
			}
			else
			{
				this.jimWidth += (pDestWidth - this.jimWidth) * pPercentageWidth;
				this.jimHeight += (pDestHeight - this.jimHeight) * pPercentageWidth;
			}			
			this.parentDiv.style.width = parseInt(this.jimWidth);
			this.parentDiv.style.height = parseInt(this.jimHeight);
		}
		
		if (pPercentageLeft == 1)
		{
			this.jimLeft = pDestLeft; this.jimTop = pDestTop;
		}
		else
		{
			this.jimLeft += (pDestLeft - this.jimLeft) * pPercentageLeft;
			this.jimTop += (pDestTop - this.jimTop) * pPercentageLeft;
		}
		this.parentDiv.style.left = parseInt(this.jimLeft - this.jimWidth * 0.5);
		this.parentDiv.style.top = parseInt(this.jimTop - this.jimHeight * 0.5);

		// 2024 debug debugjim
		if (this.parentDiv.tile == true)
		{
			console.assert(false, "TILE using LerpChange - needs LerpChangeTile");
		}
	}		
}
// </MISC>


// ---------------------------------------------------------------------------------------------------------------------
// <SOLVING>
// ---------------------------------------------------------------------------------------------------------------------
function AStarTotal(pxyIndex, pPlayField)
{
	console.assert(pPlayField[pxyIndex] == 1, "Initial pPlayField[pxyIndex] == 0!");
	
	var historyPopIndex = 0, historyPushIndex = 0;
	// mAStarPlayField = pPlayField.slice(0, mTileXYCount);
	for (var index = 0; index < mTileXYCount; index++) { mAStarPlayField[index] = pPlayField[index]; };
	mAStarPlayField[pxyIndex] = 0;
	mAStarxyIndexes[historyPushIndex] = pxyIndex;
	historyPushIndex++;	
	
	var xyIndex = -1;
	while (historyPopIndex != historyPushIndex)
	{
		xyIndex = mAStarxyIndexes[historyPopIndex];
		console.assert(mAStarPlayField[xyIndex] == 0, "mAStarPlayField[xyIndex] == 0!");

		if ( ((xyIndex % mTileXCount) > 0) && (mAStarPlayField[xyIndex - 1] > 0) )
		{
			mAStarPlayField[xyIndex - 1] = 0;
			mAStarxyIndexes[historyPushIndex]= xyIndex - 1;
			historyPushIndex++;
		}		

		if ( ((xyIndex % mTileXCount) < mTileXCount - 1) && (mAStarPlayField[xyIndex + 1] > 0) )
		{
			mAStarPlayField[xyIndex + 1] = 0;
			mAStarxyIndexes[historyPushIndex] = xyIndex + 1;
			historyPushIndex++;
		}
		
		if ( (xyIndex - mTileXCount >= 0) && (mAStarPlayField[xyIndex - mTileXCount] > 0) )
		{
			mAStarPlayField[xyIndex - mTileXCount] = 0;
			mAStarxyIndexes[historyPushIndex] = xyIndex - mTileXCount;
			historyPushIndex++;
		}			

		if ( (xyIndex + mTileXCount < mTileXYCount) && (mAStarPlayField[xyIndex + mTileXCount] > 0) )
		{
			// must remove immediately, otherwise first "if" could reprocess
			mAStarPlayField[xyIndex + mTileXCount] = 0;
			mAStarxyIndexes[historyPushIndex] = xyIndex + mTileXCount;
			historyPushIndex++;
		}
		
		historyPopIndex++;
	}
	
	console.assert(historyPushIndex <= mTileXYCount, "AStarTotal searching has gone beyond bounds. historyPushIndex:" + historyPushIndex + " mTileXYCount:" + mTileXYCount);

	return historyPushIndex;
}

function AStarPlayerBridgePoint()
{
	// Is the tile a bridge between 2 worlds? So if it's the player it's impossible. You do NOT want TRUE returned.
	// i.e. XXPXX - can never be finished
	// We don't >really< need this (since SolveUpdate can also do this), BUT it's a QUICK CHECK to remove needless possibilities (also used by Urine)

	// Hard-coded to mPlayField (no choice, and no need for otherwise)
	// mTileXCount and mTileTotal MUST be calculated
	// mPlayer MUST be calculated
	
	var bridgePoint = false;
	
	var attemptX = -1, attemptY = -1;
	var count = 0;
	for (var x = -1; x <= 1; x++)
	{
		for (var y = -1; y <= 1; y++)
		{
			if (
				(!((x == 0) && (y == 0)))
				&& (mPlayer.left + x >= 0) && (mPlayer.left + x < mTileXCount)
				&& (mPlayer.top + y >= 0) && (mPlayer.top + y < mTileYCount)
			)
			{
				if (mPlayField[(mPlayer.top + y) * mTileXCount + (mPlayer.left + x)] > 0)
				{
					if (attemptY == -1)
					{
						attemptY = mPlayer.top + y; attemptX = mPlayer.left + x;
					}
					count++;
				}
			}
		}
	}
	console.assert((attemptX != -1) && (attemptY != -1), "BridgePoint(): Error: No connectors around this point!"); 

	if (count > 1)
	{
		mPlayField[mPlayer.top * mTileXCount + mPlayer.left] = 0; // remove player, can I still travel to all the pieces?
		if (AStarTotal(attemptY * mTileXCount + attemptX, mPlayField) != mTileTotal - 1) { bridgePoint = true; }
		// console.log("BRIDGE! " + attemptX + "x" + attemptY + " " + AStarTotal(attemptY * mTileXCount + attemptX, mPlayField));
		mPlayField[mPlayer.top * mTileXCount + mPlayer.left] = 1;
	}
	return bridgePoint;
	/*
	console.log("!!! attemptY:" + attemptY + " attemptX:" + attemptX);	
	mPlayField[mPlayer.top * mTileXCount + mPlayer.left] = 0; mTileTotal--;
	console.log("HEYMAN2: " + AStarTotal(attemptY * mTileXCount + attemptX, mPlayField));
	mPlayField[mPlayer.top * mTileXCount + mPlayer.left] = 1; mTileTotal++;
	*/
}


function EdgeCount(x, y)
{
	console.assert(y * mTileXCount + x < mTileXYCount);
	
	var counter = 0;
	if ( (x - 1 < 0) || (mPlayField[y * mTileXCount + (x - 1)] == 0) ) { counter++; }
	if ( (x + 1 >= mTileXCount) || (mPlayField[y * mTileXCount + (x + 1)] == 0) ) { counter++; }
	if ( (y - 1 < 0) || (mPlayField[(y - 1) * mTileXCount + x] == 0) ) { counter++; }
	if ( (y + 1 >= mTileYCount) || (mPlayField[(y + 1) * mTileXCount + x] == 0) ) { counter++; }
	return counter;
}

function EdgeCountRemember(x, y)
{
	console.assert(y * mTileXCount + x < mTileXYCount);
	
	var counter = 0;
	if ( (x - 1 < 0) || (mPlayFieldRemember[y * mTileXCount + (x - 1)] == 0) ) { counter++; }
	if ( (x + 1 >= mTileXCount) || (mPlayFieldRemember[y * mTileXCount + (x + 1)] == 0) ) { counter++; }
	if ( (y - 1 < 0) || (mPlayFieldRemember[(y - 1) * mTileXCount + x] == 0) ) { counter++; }
	if ( (y + 1 >= mTileYCount) || (mPlayFieldRemember[(y + 1) * mTileXCount + x] == 0) ) { counter++; }
	return counter;
}

function SolveExaminePlayfield(pSolvePlayerX, pSolvePlayerY)
{
	/*
	pSolvePlayerX, pSolvePlayerY does NOT count towards 1 Edge, because player is ON it.
	Pass in -1, -1 if you want to count ALL edges.
	
	Returns:
	0 = Impossible
	1 = Success. 1 Edge.
	2 = Success. 0 Edges.
	*/

	var instantFail = false;
	var counter = 0;
	var edgeCounter = 0;
	
	var x = 0, y = 0;
	while ((x < mTileXCount) && (!instantFail))
	{
		y = 0;
		while ((y < mTileYCount) && (!instantFail))
		{		
			if (mPlayField[y * mTileXCount + x] > 0)
			{	
				counter = 0;
				if ( (x - 1 < 0) || (mPlayField[y * mTileXCount + (x - 1)] == 0) ) { counter++; }
				if ( (x + 1 >= mTileXCount) || (mPlayField[y * mTileXCount + (x + 1)] == 0) ) { counter++; }
				if ( (y - 1 < 0) || (mPlayField[(y - 1) * mTileXCount + x] == 0) ) { counter++; }
				if ( (y + 1 >= mTileYCount) || (mPlayField[(y + 1) * mTileXCount + x] == 0) ) { counter++; }

				if (counter == 4)  
				{
					// tile by itself
					instantFail = true;
				}
				else if ( (counter == 3) && (!((x == pSolvePlayerX) && (y == pSolvePlayerY))) )
				{
					// 1 edge tile is okay (still solvable), 2 means impossible
					edgeCounter++;
					if (edgeCounter == 2) { instantFail = true; }
				}
			}
			y++;
		}
		x++;
	}
	
	console.assert(edgeCounter <= 2);
	if (instantFail)
	{
		return 0;
	}
	else
	{
		console.assert(edgeCounter <= 1);
		if (edgeCounter == 1) { return 1; } else { return 2; }	
	}
}

function DebugSolveCompareHistory(pxyIndex, pCrazyIndex)
{
	return false;
	
	// Check if this playfield ALREADY exists. Return TRUE if it does
	// GOOD NEWS!! It NEVER DOES. Turns out this is a DEBUG check.
		
	// Make a copy of the PROPOSED playfield to compare against
	for (var index = 0; index < mTileXYCount; index++) { mAStarPlayField[index] = mSolveCrazyPlayFields[pCrazyIndex][index]; }
	console.assert(mAStarPlayField[pxyIndex] == 1, "SolveCompareHistory: Passed playfield where xyIndex was already explored.");
	mAStarPlayField[pxyIndex] = 0;

	// Does it exist?
	var same = false;	
	for (var crazyIndex = 0; crazyIndex < mHistoryPushIndex; crazyIndex++)
	{
		same = true;
		for (var index = 0; index < mTileXYCount; index++)
		{
			if (mSolveCrazyPlayFields[crazyIndex][index] != mAStarPlayField[index]) { same = false; break; }
		}
		if (same == true) { console.log("SAME! " + pCrazyIndex + ":" + pxyIndex); break; }
	}
	return same;
}


function SolveUpdateStart()
{
	// MUST be called before SolveUpdate
	// Does some quick checks before initalizing the big SHOW
	// Returns 0 if fine, 1 if failure (in sync with mState and SolveUpdate) 
	console.assert(mState == 0, "SolveUpdateStart Error(): Called BUT mState != 0 '" + mState + "'");
	console.assert(mPlayField[mPlayer.top * mTileXCount + mPlayer.left] == 1, "SolveUpdateStart Error: Tile underneath player is 0!");
	console.assert(mUseTheForceState == 0, "SolveUpdateStart Error: SolveUpdate called BUT mUseTheForceState != 0 '" + mUseTheForceState + "'");
	// console.assert(mSolveUpdateCount == 0, "SolveUpdateStart() Error: mSolveUpdateCount must be 0 '" + mSolveUpdateCount + "'");

	let newState = 0;
	
	// <INTIALIZE>
	// SolveUpdate needs all of this.
	mSolveUpdateCount = 0;
	mSolutions = 0;
	mStatePushPopped = false;	
	console.assert(mPlayField[mPlayer.top * mTileXCount + mPlayer.left] == 1, "SolveUpdateStart Error: mPlayField[mPlayer.top * mTileXCount + mPlayer.left] == 0! 'Root' Tile underneath player is DEAD/0! '" + mPlayer.left + "x" + mPlayer.top + "'");
	// <INTIALIZE>
		
	// QUICK check for instant fails before initiating the big bad slow "recursive" check
	if (
		(SolveExaminePlayfield(mPlayer.left, mPlayer.top) == 0)
		|| (AStarTotal(mPlayer.top * mTileXCount + mPlayer.left, mPlayField) != mTileTotal)
		|| (AStarPlayerBridgePoint())
	)
	{
		newState = 1;   // Failed. SolveUpdate won't be called anymore
	}
	else
	{
		mSolveUpdateCount++;
	}
	return newState;
}

function SolveUpdate(pMilliseconds)
{
	// Determine whether the playfield (given where the player is at) can be solved
	// fake "reentrant", fake "mutithreading" - meaning it doesn't do the entire thing but just a piece
	// Returns 3 things: 0 - still working (mSolutions exists)  1 - fail (could be 100% sure or just unable to finnish)   2 - there's ONE path (might be more)
	console.assert(mState == 0, "SolveUpdate() Error: Called BUT mState != 0 '" + mState + "'");
	let newState = 0;	
	let milliseconds = Date.now();

	// <INITIALIZE HEAVY CHECK>
	// copy first playfield as the root of the recursive array
	if (mSolveUpdateCount == 1)
	{
		mHistoryPopIndex = 0; mHistoryPushIndex = 0;
		// mSolveCrazyPlayFields[mHistoryPushIndex] = mPlayField.slice(0, mTileXYCount);
		console.assert(mPlayField[mPlayer.top * mTileXCount + mPlayer.left] == 1, "SolveUpdateStart Error: mPlayField[mPlayer.top * mTileXCount + mPlayer.left] == 0! 'Root' Tile underneath player is DEAD/0! '" + mPlayer.left + "x" + mPlayer.top + "'");
		for (var index = 0; index < mTileXYCount; index++) { mSolveCrazyPlayFields[mHistoryPushIndex][index] = mPlayField[index]; };
		mHistoryxyIndexes[mHistoryPushIndex] = mPlayer.top * mTileXCount + mPlayer.left;
		mHistoryCounts[mHistoryPushIndex] = 0;
		mHistoryTurns[mHistoryPushIndex] = 0;
		mHistoryPushIndex = (mHistoryPushIndex + 1) % mSolveCrazyPlayFields.length;
	}
	// </INITIALIZE HEAVY CHECK>
	
	// <HEAVY CHECK>
	let test = -1;
	var historyCurrentIndex = -1;
	var xyIndex = 0, count = 0, turns = 0;
	var turnsHold = 0;
	var holdDateNow = Date.now() + 500;
	while ((newState == 0) && (Date.now() - milliseconds < pMilliseconds))
	{
		historyCurrentIndex = mHistoryPopIndex; // remember the history element we're processing

		xyIndex = mHistoryxyIndexes[historyCurrentIndex];
		count = mHistoryCounts[historyCurrentIndex];
		turns = mHistoryTurns[historyCurrentIndex];
		console.assert(mSolveCrazyPlayFields[historyCurrentIndex][xyIndex] == 1, "SolveUpdate: mSolveCrazyPlayFields[historyCurrentIndex][xyIndex] is 0! I'm checking dead tile! " + historyCurrentIndex + ":" + mHistoryPopIndex + ":" + mHistoryPushIndex);
		mPlayFieldDivs[xyIndex].solved++;   // colour

		if (AStarTotal(xyIndex, mSolveCrazyPlayFields[historyCurrentIndex]) == (mTileTotal - count))
		{
			// <SOLUTION FOUND>
			// . might be for a FULL playfield >or< a smaller/larger one, but a solution has been found for THIS playfield
			// . mTileTotal can be smaller or larger than good playfield 
			if ((count + 1) == mTileTotal)
			{	
				// If we're generating a level, or player started playing the level - update FinalTile, Answers for Pink
				// If we're using SolveUpdate to determine something else (player moving caluse failure, prove Extras cause failure), do NOT modify these 
				if ( (mTileTotalRemember == 0) || (mTileTotal == mTileTotalRemember) )
				{
					if (mPlayFieldDivs[xyIndex].finalTile == 0)
					{
						mPlayFieldDivs[xyIndex].finalTile = 1;   // regardless of Talktype.finishTile, we want to flag all tiles that are final
						FinishTileAdd(xyIndex, true);
					}
				
					if (turns < mSolvedPlayfieldTurn[0])
					{
						// mSolvedPlayfield[0] = mSolveCrazyPlayFields[historyCurrentIndex].slice(0, mTileXYCount);
						for (var index = 0; index < mTileXYCount; index++) { mSolvedPlayfield[0][index] = mSolveCrazyPlayFields[historyCurrentIndex][index]; }
						mSolvedPlayfieldTurn[0] = turns;
						// console.log("000 " + turns);
					}
					if (turns > mSolvedPlayfieldTurn[1])
					{
						// mSolvedPlayfield[1] = mSolveCrazyPlayFields[historyCurrentIndex].slice(0, mTileXYCount);
						for (var index = 0; index < mTileXYCount; index++) { mSolvedPlayfield[1][index] = mSolveCrazyPlayFields[historyCurrentIndex][index]; }
						mSolvedPlayfieldTurn[1] = turns;
						// console.log("111 " + turns);
					}
				}
				
				mSolutions++;
			}
			// <SOLUTION FOUND>

			// <KEEP LOOKING>
			else
			{
				// LEFT -1
				if ( ((xyIndex % mTileXCount) > 0) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex - 1] > 0) )
				{
					mSolveCrazyPlayFields[historyCurrentIndex][xyIndex] = -1;
					// feel i could calculate this later once I have valid paths. don't care about turns of failures.
					turnsHold = turns;
					if (
						( ((xyIndex - mTileXCount) >= 0) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex - mTileXCount] == -4) )
						|| ( (xyIndex + mTileXCount < mTileXYCount) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex + mTileXCount] == -3) )
					)
					{
						turnsHold++;
					}
					
					// mSolveCrazyPlayFields[mHistoryPushIndex] = mSolveCrazyPlayFields[historyCurrentIndex].slice(0, mTileXYCount);
					for (var index = 0; index < mTileXYCount; index++) { mSolveCrazyPlayFields[mHistoryPushIndex][index] = mSolveCrazyPlayFields[historyCurrentIndex][index]; };
					mHistoryxyIndexes[mHistoryPushIndex]= xyIndex - 1;
					mHistoryCounts[mHistoryPushIndex] = count + 1;
					mHistoryTurns[mHistoryPushIndex] = turnsHold;
					mHistoryPushIndex = (mHistoryPushIndex + 1) % mSolveCrazyPlayFields.length;
					if (mHistoryPushIndex == mHistoryPopIndex)
					{
						if ((mSolveUpdateCount % 2) == 0)
						{
							mHistoryPushIndex--; if (mHistoryPushIndex < 0) { mHistoryPushIndex += mSolveCrazyPlayFields.length; }
						}
						else
						{
							mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length;
						}
						mStatePushPopped = true;
					}
				}		
		
				// RIGHT -2
				if ( ((xyIndex % mTileXCount) < (mTileXCount - 1)) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex + 1] > 0) )
				{
					mSolveCrazyPlayFields[historyCurrentIndex][xyIndex] = -2;
					turnsHold = turns;
					if (
						( ((xyIndex - mTileXCount) >= 0) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex - mTileXCount] == -4) )
						|| ( (xyIndex + mTileXCount < mTileXYCount) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex + mTileXCount] == -3) )
					)
					{
						turnsHold++;
					}

					// mSolveCrazyPlayFields[mHistoryPushIndex] = mSolveCrazyPlayFields[historyCurrentIndex].slice(0, mTileXYCount);
					for (var index = 0; index < mTileXYCount; index++) { mSolveCrazyPlayFields[mHistoryPushIndex][index] = mSolveCrazyPlayFields[historyCurrentIndex][index]; };
					mHistoryxyIndexes[mHistoryPushIndex]= xyIndex + 1;
					mHistoryCounts[mHistoryPushIndex] = count + 1;
					mHistoryTurns[mHistoryPushIndex] = turnsHold;
					mHistoryPushIndex = (mHistoryPushIndex + 1) % mSolveCrazyPlayFields.length;
					if (mHistoryPushIndex == mHistoryPopIndex)
					{
						if ((mSolveUpdateCount % 2) == 0)
						{
							mHistoryPushIndex--; if (mHistoryPushIndex < 0) { mHistoryPushIndex += mSolveCrazyPlayFields.length; }
						}
						else
						{
							mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length;
						}
						mStatePushPopped = true;
					}
				}
				
				// UP -3
				if ( ((xyIndex - mTileXCount) >= 0) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex - mTileXCount] > 0) )
				{
					mSolveCrazyPlayFields[historyCurrentIndex][xyIndex] = -3;
					turnsHold = turns;
					if (
						( ((xyIndex % mTileXCount) > 0) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex - 1] == -2) )   // tile to left points right
						|| ( ((xyIndex % mTileXCount) < (mTileXCount - 1)) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex + 1] == -1) )   // tile to right points left
					)
					{
						 turnsHold++;
					}

					// mSolveCrazyPlayFields[mHistoryPushIndex] = mSolveCrazyPlayFields[historyCurrentIndex].slice(0, mTileXYCount);
					for (var index = 0; index < mTileXYCount; index++) { mSolveCrazyPlayFields[mHistoryPushIndex][index] = mSolveCrazyPlayFields[historyCurrentIndex][index]; };
					mHistoryxyIndexes[mHistoryPushIndex]= xyIndex - mTileXCount;
					mHistoryCounts[mHistoryPushIndex] = count + 1;
					mHistoryTurns[mHistoryPushIndex] = turnsHold;					
					mHistoryPushIndex = (mHistoryPushIndex + 1) % mSolveCrazyPlayFields.length;
					if (mHistoryPushIndex == mHistoryPopIndex)
					{
						if ((mSolveUpdateCount % 2) == 0)
						{
							mHistoryPushIndex--; if (mHistoryPushIndex < 0) { mHistoryPushIndex += mSolveCrazyPlayFields.length; }
						}
						else
						{
							mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length;
						}
						mStatePushPopped = true;
					}
				}			
		
				// DOWN -4
				if  ( (xyIndex + mTileXCount < mTileXYCount) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex + mTileXCount] > 0) )
				{
					mSolveCrazyPlayFields[historyCurrentIndex][xyIndex] = -4;
					turnsHold = turns;
					if (
						( ((xyIndex % mTileXCount) > 0) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex - 1] == -2) )   // tile to left points right
						|| ( ((xyIndex % mTileXCount) < (mTileXCount - 1)) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex + 1] == -1) )   // tile to right points left
					)
					{
						 turnsHold++;
					}

					// mSolveCrazyPlayFields[mHistoryPushIndex] = mSolveCrazyPlayFields[historyCurrentIndex].slice(0, mTileXYCount);
					for (var index = 0; index < mTileXYCount; index++) { mSolveCrazyPlayFields[mHistoryPushIndex][index] = mSolveCrazyPlayFields[historyCurrentIndex][index]; };
					mHistoryxyIndexes[mHistoryPushIndex]= xyIndex + mTileXCount;
					mHistoryCounts[mHistoryPushIndex] = count + 1;
					mHistoryTurns[mHistoryPushIndex] = turnsHold;					
					mHistoryPushIndex = (mHistoryPushIndex + 1) % mSolveCrazyPlayFields.length;
					if (mHistoryPushIndex == mHistoryPopIndex)
					{
						if ((mSolveUpdateCount % 2) == 0)
						{
							mHistoryPushIndex--; if (mHistoryPushIndex < 0) { mHistoryPushIndex += mSolveCrazyPlayFields.length; }
						}
						else
						{
							mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length;
						}
						mStatePushPopped = true;
					}
				}
				
				// if we get here, and no paths were taken, we wound up at a dead end/stuck (a path which ended but did NOT get rid of all tiles).
				// regardless of good or dead path, we're done with this playfield (mHistoryPopIndex++ effectively discards it)
			}
			// </KEEP LOOKING>

		}

		mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length;   // Move immediately, so we can check whether mHistoryPushIndex == mHistoryPopIndex and move it again. mHistoryPopIndex MIGHT EQUAL mHistoryPushIndex at this point.		
		
		// <SEARCHED EVERYTHING>
		if (mHistoryPopIndex == mHistoryPushIndex)
		{
			if (mSolutions > 0)
			{
				newState = 2;   // Finished with 1+ successful solutions! mStatePushPopped indicates whether more solutions were possible
			}
			else
			{
				newState = 1;   // Finished without success (Failed). mStatePushPopped indicates whether more solutions were possible
				// Note: Don't say Fail until you've checked mStatePushPopped
			}
		}
		// <SEARCHED EVERYTHING>		
	}
	// </HEAVY CHECK>

	mSolveUpdateCount++;
	
	return newState;
}


function SolveUpdateOLD(pMilliseconds)
{
	// Determine whether the playfield (given where the player is at) can be solved
	// fake "reentrant", fake "mutithreading" - meaning it doesn't do the entire thing but just a piece
	// Returns 3 things: 0 - still working (mSolutions exists)  1 - fail (could be 100% sure or just unable to finnish)   2 - there's ONE path (might be more)
	console.assert(mState == 0, "SolveUpdate() Error: Called BUT mState != 0 '" + mState + "'");
	let newState = 0;	
	let milliseconds = Date.now();

	// <INITIALIZE HEAVY CHECK>
	// copy first playfield as the root of the recursive array
	if (mSolveUpdateCount == 1)
	{
		mHistoryPopIndex = 0; mHistoryPushIndex = 0;
		// mSolveCrazyPlayFields[mHistoryPushIndex] = mPlayField.slice(0, mTileXYCount);
		console.assert(mPlayField[mPlayer.top * mTileXCount + mPlayer.left] == 1, "SolveUpdateStart Error: mPlayField[mPlayer.top * mTileXCount + mPlayer.left] == 0! 'Root' Tile underneath player is DEAD/0! '" + mPlayer.left + "x" + mPlayer.top + "'");
		for (var index = 0; index < mTileXYCount; index++) { mSolveCrazyPlayFields[mHistoryPushIndex][index] = mPlayField[index]; };
		mHistoryxyIndexes[mHistoryPushIndex] = mPlayer.top * mTileXCount + mPlayer.left;
		mHistoryCounts[mHistoryPushIndex] = 0;
		mHistoryTurns[mHistoryPushIndex] = 0;
		mHistoryPushIndex = (mHistoryPushIndex + 1) % mSolveCrazyPlayFields.length;
	}
	// </INITIALIZE HEAVY CHECK>
	
	// <HEAVY CHECK>
	var historyCurrentIndex = -1;
	var xyIndex = 0, count = 0, turns = 0;
	var turnsHold = 0;
	var holdDateNow = Date.now() + 500;
	while ((newState == 0) && (Date.now() - milliseconds < pMilliseconds))
	{
		historyCurrentIndex = mHistoryPopIndex; // remember the history element we're processing

		xyIndex = mHistoryxyIndexes[historyCurrentIndex];
		count = mHistoryCounts[historyCurrentIndex];
		turns = mHistoryTurns[historyCurrentIndex];
		console.assert(mSolveCrazyPlayFields[historyCurrentIndex][xyIndex] == 1, "SolveUpdate: mSolveCrazyPlayFields[historyCurrentIndex][xyIndex] is 0! I'm checking dead tile! " + historyCurrentIndex + ":" + mHistoryPopIndex + ":" + mHistoryPushIndex);
		mPlayFieldDivs[xyIndex].solved++;   // colour

		if (AStarTotal(xyIndex, mSolveCrazyPlayFields[historyCurrentIndex]) == (mTileTotal - count))
		{
			// <SOLUTION FOUND>
			// . might be for a FULL playfield >or< a smaller/larger one, but a solution has been found for THIS playfield
			// . mTileTotal can be smaller or larger than good playfield 
			if ((count + 1) == mTileTotal)
			{	
				// If we're generating a level, or player started playing the level - update FinalTile, Answers for Pink
				// If we're using SolveUpdate to determine something else (player moving caluse failure, prove Extras cause failure), do NOT modify these 
				if ( (mTileTotalRemember == 0) || (mTileTotal == mTileTotalRemember) )
				{
					if (mPlayFieldDivs[xyIndex].finalTile == 0)
					{
						mPlayFieldDivs[xyIndex].finalTile = 1;   // regardless of Talktype.finishTile, we want to flag all tiles that are final
						FinishTileAdd(xyIndex, true);
					}
				
					if (turns < mSolvedPlayfieldTurn[0])
					{
						// mSolvedPlayfield[0] = mSolveCrazyPlayFields[historyCurrentIndex].slice(0, mTileXYCount);
						for (var index = 0; index < mTileXYCount; index++) { mSolvedPlayfield[0][index] = mSolveCrazyPlayFields[historyCurrentIndex][index]; }
						mSolvedPlayfieldTurn[0] = turns;
						// console.log("000 " + turns);
					}
					if (turns > mSolvedPlayfieldTurn[1])
					{
						// mSolvedPlayfield[1] = mSolveCrazyPlayFields[historyCurrentIndex].slice(0, mTileXYCount);
						for (var index = 0; index < mTileXYCount; index++) { mSolvedPlayfield[1][index] = mSolveCrazyPlayFields[historyCurrentIndex][index]; }
						mSolvedPlayfieldTurn[1] = turns;
						// console.log("111 " + turns);
					}
				}
				
				mSolutions++;
			}
			// <SOLUTION FOUND>

			// <KEEP LOOKING>
			else
			{
				// LEFT -1
				if ( ((xyIndex % mTileXCount) > 0) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex - 1] > 0) )
				{
					mSolveCrazyPlayFields[historyCurrentIndex][xyIndex] = -1;
					// feel i could calculate this later once I have valid paths. don't care about turns of failures.
					turnsHold = turns;
					if (
						( ((xyIndex - mTileXCount) >= 0) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex - mTileXCount] == -4) )
						|| ( (xyIndex + mTileXCount < mTileXYCount) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex + mTileXCount] == -3) )
					)
					{
						turnsHold++;
					}
					
					// mSolveCrazyPlayFields[mHistoryPushIndex] = mSolveCrazyPlayFields[historyCurrentIndex].slice(0, mTileXYCount);
					for (var index = 0; index < mTileXYCount; index++) { mSolveCrazyPlayFields[mHistoryPushIndex][index] = mSolveCrazyPlayFields[historyCurrentIndex][index]; };
					mHistoryxyIndexes[mHistoryPushIndex]= xyIndex - 1;
					mHistoryCounts[mHistoryPushIndex] = count + 1;
					mHistoryTurns[mHistoryPushIndex] = turnsHold;
					mHistoryPushIndex = (mHistoryPushIndex + 1) % mSolveCrazyPlayFields.length;
					if (mHistoryPushIndex == mHistoryPopIndex)
					{
						mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length;
						// if ((mSolveUpdateCount % 2) == 0) { mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length; }
						mStatePushPopped = true;
					}
				}		
		
				// RIGHT -2
				if ( ((xyIndex % mTileXCount) < (mTileXCount - 1)) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex + 1] > 0) )
				{
					mSolveCrazyPlayFields[historyCurrentIndex][xyIndex] = -2;
					turnsHold = turns;
					if (
						( ((xyIndex - mTileXCount) >= 0) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex - mTileXCount] == -4) )
						|| ( (xyIndex + mTileXCount < mTileXYCount) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex + mTileXCount] == -3) )
					)
					{
						turnsHold++;
					}

					// mSolveCrazyPlayFields[mHistoryPushIndex] = mSolveCrazyPlayFields[historyCurrentIndex].slice(0, mTileXYCount);
					for (var index = 0; index < mTileXYCount; index++) { mSolveCrazyPlayFields[mHistoryPushIndex][index] = mSolveCrazyPlayFields[historyCurrentIndex][index]; };
					mHistoryxyIndexes[mHistoryPushIndex]= xyIndex + 1;
					mHistoryCounts[mHistoryPushIndex] = count + 1;
					mHistoryTurns[mHistoryPushIndex] = turnsHold;
					mHistoryPushIndex = (mHistoryPushIndex + 1) % mSolveCrazyPlayFields.length;
					if (mHistoryPushIndex == mHistoryPopIndex)
					{
						mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length;
						// if ((mSolveUpdateCount % 2) == 0) { mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length; }
						mStatePushPopped = true;
					}
				}
				
				// UP -3
				if ( ((xyIndex - mTileXCount) >= 0) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex - mTileXCount] > 0) )
				{
					mSolveCrazyPlayFields[historyCurrentIndex][xyIndex] = -3;
					turnsHold = turns;
					if (
						( ((xyIndex % mTileXCount) > 0) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex - 1] == -2) )   // tile to left points right
						|| ( ((xyIndex % mTileXCount) < (mTileXCount - 1)) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex + 1] == -1) )   // tile to right points left
					)
					{
						 turnsHold++;
					}

					// mSolveCrazyPlayFields[mHistoryPushIndex] = mSolveCrazyPlayFields[historyCurrentIndex].slice(0, mTileXYCount);
					for (var index = 0; index < mTileXYCount; index++) { mSolveCrazyPlayFields[mHistoryPushIndex][index] = mSolveCrazyPlayFields[historyCurrentIndex][index]; };
					mHistoryxyIndexes[mHistoryPushIndex]= xyIndex - mTileXCount;
					mHistoryCounts[mHistoryPushIndex] = count + 1;
					mHistoryTurns[mHistoryPushIndex] = turnsHold;					
					mHistoryPushIndex = (mHistoryPushIndex + 1) % mSolveCrazyPlayFields.length;
					if (mHistoryPushIndex == mHistoryPopIndex)
					{
						mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length;
						// if ((mSolveUpdateCount % 2) == 0) { mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length; }
						mStatePushPopped = true;
					}
				}			
		
				// DOWN -4
				if  ( (xyIndex + mTileXCount < mTileXYCount) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex + mTileXCount] > 0) )
				{
					mSolveCrazyPlayFields[historyCurrentIndex][xyIndex] = -4;
					turnsHold = turns;
					if (
						( ((xyIndex % mTileXCount) > 0) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex - 1] == -2) )   // tile to left points right
						|| ( ((xyIndex % mTileXCount) < (mTileXCount - 1)) && (mSolveCrazyPlayFields[historyCurrentIndex][xyIndex + 1] == -1) )   // tile to right points left
					)
					{
						 turnsHold++;
					}

					// mSolveCrazyPlayFields[mHistoryPushIndex] = mSolveCrazyPlayFields[historyCurrentIndex].slice(0, mTileXYCount);
					for (var index = 0; index < mTileXYCount; index++) { mSolveCrazyPlayFields[mHistoryPushIndex][index] = mSolveCrazyPlayFields[historyCurrentIndex][index]; };
					mHistoryxyIndexes[mHistoryPushIndex]= xyIndex + mTileXCount;
					mHistoryCounts[mHistoryPushIndex] = count + 1;
					mHistoryTurns[mHistoryPushIndex] = turnsHold;					
					mHistoryPushIndex = (mHistoryPushIndex + 1) % mSolveCrazyPlayFields.length;
					if (mHistoryPushIndex == mHistoryPopIndex)
					{
						mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length;
						// if ((mSolveUpdateCount % 2) == 0) { mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length; }
						mStatePushPopped = true;
					}
				}
				
				// if we get here, and no paths were taken, we wound up at a dead end/stuck (a path which ended but did NOT get rid of all tiles).
				// regardless of good or dead path, we're done with this playfield (mHistoryPopIndex++ effectively discards it)
			}
			// </KEEP LOOKING>

		}

		mHistoryPopIndex = (mHistoryPopIndex + 1) % mSolveCrazyPlayFields.length;   // Move immediately, so we can check whether mHistoryPushIndex == mHistoryPopIndex and move it again. mHistoryPopIndex MIGHT EQUAL mHistoryPushIndex at this point.		
		
		// <SEARCHED EVERYTHING>
		if (mHistoryPopIndex == mHistoryPushIndex)
		{
			if (mSolutions > 0)
			{
				newState = 2;   // Finished with 1+ successful solutions! mStatePushPopped indicates whether more solutions were possible
			}
			else
			{
				newState = 1;   // Finished without success (Failed). mStatePushPopped indicates whether more solutions were possible
				// Note: Don't say Fail until you've checked mStatePushPopped
			}
		}
		// <SEARCHED EVERYTHING>		
	}
	// </HEAVY CHECK>

	mSolveUpdateCount++;
	
	return newState;
}

// ---------------------------------------------------------------------------------------------------------------------
// <GRID GENERATION>
// ---------------------------------------------------------------------------------------------------------------------
function WorldResetCheck(pEmptyTileCount = -1)
{
	// mPlayer.xyIndex, mTileXYCount, and mTileTotal MUST be CURRENT
	console.assert(mPlayer.xyIndex == (mPlayer.top * mTileXCount + mPlayer.left) );
	if (mPlayField[mPlayer.top * mTileXCount + mPlayer.left] == 0) { return false; }   // Mirroring can cause this

	mWorldResetCheckFailsafe++;
	if (mWorldResetCheckFailsafe > 250)
	{
		// Browser can't do garbage cleanup unless event finishes. Sending back True means solving continues BUT across a timer
		// console.log("mWorldResetCheckFailsafe!" + Date.now());
		mWorldResetCheckFailsafe = 0;
	}
	else
	{
		var sideCount = 0;
		for (var x=0; x < mTileXCount; x++) { if (mPlayField[0 * mTileXCount + x] > 0) { sideCount++; break; } }
		for (var x=0; x < mTileXCount; x++) { if (mPlayField[(mTileYCount - 1) * mTileXCount + x] > 0) { sideCount++; break; } }
		for (var y=0; y < mTileYCount; y++) { if (mPlayField[y * mTileXCount + 0] > 0) { sideCount++; break; } }
		for (var y=0; y < mTileYCount; y++) { if (mPlayField[y * mTileXCount + (mTileXCount - 1)] > 0) { sideCount++; break; } }
		if (sideCount != 4) { return false; }
		
		// console.log("AStarTotal Start: " + mPlayer.xyIndex + ":" + mPlayField.length + "   " + mPlayField[mPlayer.xyIndex]);
		if (AStarTotal(mPlayer.xyIndex, mPlayField) != mTileTotal) { return false; }
		// console.log("AStarTotal End: " + mPlayer.xyIndex + ":" + mPlayField.length);
		
		if (pEmptyTileCount == -1) { pEmptyTileCount = parseInt(mTileXYCount * 0.05); }
		if (((mTileXYCount) - mTileTotal) < pEmptyTileCount) { return false; }
	}	
	return true;
}

function WorldResetDenseEasy(pFull, pExtreme)
{
	// Produces EASY 5 x 5 square
	// http://bigpants.ca/you/indexdebug.htm?levelgenerate=1,false,0	
	if (pFull)
	{
		if (pExtreme)
		{
			// SUPER EASY. 3 x 4, 4 x 3
			// due to side requirement, CANNOT go lower then 4x3, 3x4
			let hold = 3 + Math.floor(Math.random() * 2);
			ChangeTileCount(hold, 3 + (4 - hold));
		}
		else
		{
			// Easy. 5 x 5, 4 x 6
			if (Math.random() < 0.5)
			{
				ChangeTileCount(5, 5);
			}
			else
			{
				if (Math.random() < 0.5) { ChangeTileCount(4, 6); } else { ChangeTileCount(6, 3); }
			}
		}
	}

	var chance = 0.23 + Math.random() * 0.06;
	var emptySpots = parseInt(mTileXYCount * 0.12 + 1);

	chance = 0.4 + Math.random() * 0.2;
	emptySpots = parseInt(mTileXYCount * 0.15 + 1);

	chance = 0.23 + Math.random() * 0.3;
	emptySpots = parseInt(mTileXYCount * 0.13 + 1);

	do
	{
		mPlayer.ChangePosition(parseInt(Math.random() * mTileXCount), parseInt(Math.random() * mTileYCount));
		
		// Remember: ALL Tiles MUST be set to 0 or 1 (may have been asked for a new pattern (staying at SAME mTileXYCount))
		mTileTotal = 0;	
		for (var index = 0; index < mTileXYCount; index++)
		{
			if ((Math.random() > chance) || (index == mPlayer.xyIndex))
			{
				mPlayField[index] = 1;					
				mTileTotal++;
			}
			else
			{
				mPlayField[index] = 0;
			}
		}
	} while (!WorldResetCheck(emptySpots))
	
	if (mSolveStatTitle == "")
	{ 	
		mSolveStatTitle = "Relax " + mTileXCount + "x" + mTileYCount;
	}
	return false;
}

function WorldResetDense(pFull, pExtreme)
{
	// Produces SQUARE. 9x9 can be VERY slow. 8x8 passable.
	if (pFull)
	{	
		var total = mStatNewFrankLoss + mStatNewFrankWin + 1;
		if ((total < 21) && (mLevelGenerate == null))
		{
			var holdXCount = 4 + parseInt(total * 0.2); if (holdXCount > 4) { holdXCount -= parseInt(Math.random() * 2); }
			var holdYCount = 4 + parseInt(total * 0.2); if (holdYCount > 4) { holdYCount -= parseInt(Math.random() * 2); }
			ChangeTileCount(holdXCount, holdYCount);
		}
		else if (pExtreme)
		{
			// 10x10 possible. 11x11 impossible.
			if (Math.random() < 0.5)
			{
				ChangeTileCount(10, 10);
			}
			else
			{
				if (Math.random() < 0.5) { ChangeTileCount(9, 10); } else { ChangeTileCount(10, 9); } 
			}
		}
		else
		{
			var r = Math.random();
			if (r < 0.33)
			{
				ChangeTileCount(6, 6);
			}
			else if (r < 0.66)
			{
				ChangeTileCount(7, 7);
			}
			else
			{
				ChangeTileCount(8, 8);			
			}
		}
	}

	let chance = 0;
	if (pExtreme)
	{
		chance = 0.28 + Math.random() * 0.05;
	}
	else
	{
		chance = 0.23 + Math.random() * 0.12;
	}

	var emptySpots = parseInt(mTileXYCount * 0.13 + 1);
	if (pExtreme) { emptySpots = 0; }
	do
	{
		mPlayer.ChangePosition(parseInt(Math.random() * mTileXCount), parseInt(Math.random() * mTileYCount));
		
		// Remember: ALL Tiles MUST be set to 0 or 1 (may have been asked for a new pattern (staying at SAME mTileXYCount))
		mTileTotal = 0;	
		for (var index = 0; index < mTileXYCount; index++)
		{
			if ((Math.random() > chance) || (index == mPlayer.xyIndex))
			{
				mPlayField[index] = 1;					
				mTileTotal++;
			}
			else
			{
				mPlayField[index] = 0;
			}
		}
	} while (!WorldResetCheck(emptySpots))
	
	if (mSolveStatTitle == "")
	{ 	
		mSolveStatTitle = "Dense " + mTileXCount + "x" + mTileYCount;
		if (pExtreme) { mSolveStatTitle += "E"; }
	}
	return false;
}
// </GRID GENERATION>


// ---------------------------------------------------------------------------------------------------------------------
// <WORLD>
// ---------------------------------------------------------------------------------------------------------------------

function WorldChange(pWorldMode, pWorldDayOfWeek, pWorldEvening)
{
	// if there's a change, grab the JSON levels 
	if (
		(pWorldMode != mWorldMode)
		|| ((pWorldMode == 1) && ((pWorldDayOfWeek != mWorldDayOfWeek) || (pWorldEvening != mWorldEvening)))
	)
	{
		mWorldMode = pWorldMode;
		mWorldDayOfWeek = pWorldDayOfWeek;
		mWorldEvening = pWorldEvening;

		if (mWorldMode == 1)
		{
			LevelsGet("Level" + mWorldEvening + "" + mWorldDayOfWeek + ".json");   // asynchronous
		}
		else
		{
			LevelsGet("fetch-content-full.json");
		}
	}
}

function WorldPlayFieldResize()
{
	// Called by WorldResize AND when:
	// 1. a new playfield is created (legacy reasons means divs need style reapplied, can likely fix then remove this odd dependency)
	// 2. player resized browser
	if (mPlayFieldDivs != null)
	{
		// Formerly WorldRefresh
		mWorldDeltaX = -1;
		mWorldDeltaY = -1;
		
		mTileSize = -1;
		mWorldFlipped = false;

		if (
			((mTileXCount > mTileYCount) && (mWorldHeight > mWorldWidth))
			|| ((mTileYCount > mTileXCount) && (mWorldWidth > mWorldHeight))
		)
		{
			mWorldFlipped = true;

			mTileSize = parseInt(mWorldWidth / (mTileYCount + 0.5));
			if ((mWorldHeight / (mTileXCount + 0.5)) < mTileSize) { mTileSize = parseInt(mWorldHeight / (mTileXCount + 0.5)); }	

			mWorldDeltaX = parseInt((mWorldWidth - (mTileSize * mTileYCount)) * 0.5);
			mWorldDeltaY = parseInt((mWorldHeight - (mTileSize * mTileXCount)) * 0.5);
		}
		else
		{
			mTileSize = parseInt(mWorldWidth / (mTileXCount + 0.5));
			if ((mWorldHeight / (mTileYCount + 0.5)) < mTileSize) { mTileSize = parseInt(mWorldHeight / (mTileYCount + 0.5)); }	
			
			mWorldDeltaX = parseInt((mWorldWidth - (mTileSize * mTileXCount)) * 0.5);
			mWorldDeltaY = parseInt((mWorldHeight - (mTileSize * mTileYCount)) * 0.5);		
		}
		
		mWorldShadowType = -1;
		var gap = parseInt(mTileSize * 0.18); if (gap < 4) { gap = 4; }
		mTileSize2 = mTileSize - gap;
		if (mWorldShadowType != 1)
		{
			let shadowSize = parseInt(gap * 0.65); if (shadowSize < 3) { shadowSize = 3; }
			let borderSize = parseInt(gap * 0.2); if (borderSize < 1) { borderSize = 1; }
			// alert(gap + " " + shadowSize + "!!!");
			for (var xyIndex = 0; xyIndex < mPlayFieldDivs.length; xyIndex++)
			{
				mPlayFieldDivs[xyIndex].div.style.boxShadow = shadowSize + "px " + shadowSize + "px #FFFFFF80";
				mPlayFieldDivs[xyIndex].div.style.border = borderSize + "px solid #000000FF";
				mPlayFieldDivs[xyIndex].div.style.borderRadius = "5px";
			}
			
			mPlayback.Refresh();
			
			mWorldShadowType = 1;
		}

		var y = -1, x = -1;
		var hold = 0;
		for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
		{
			y = parseInt(xyIndex / mTileXCount);
			x = xyIndex - (y * mTileXCount);			
			if (mWorldFlipped) {
				hold = x; x = y; y = hold; // - (mTileYCount - mTileXCount);
			}

			mPlayFieldDivs[xyIndex].newLeft = parseInt(mWorldDeltaX + x * mTileSize + mTileSize * 0.5);
			mPlayFieldDivs[xyIndex].newTop = parseInt(mWorldDeltaY + y * mTileSize + mTileSize * 0.5);
		}

		RestartPosition(mRestart.xyIndexRemember);
	}
}

var WorldResizeTimeoutID = -1;
function WorldResize(pType = 0)
{
	// pType: 0-called from Resize Event   1-called from code

	// when running as an iPhone home page app, window.innerWidth/Height NOT set properly. This event needs to finish to fix.
	if (pType == 0)
	{
		if (WorldResizeTimeoutID == -1) { WorldResizeTimeoutID = window.setTimeout(WorldResize, 100, 1); }
	}
	else
	{
		WorldResizeTimeoutID = -1;

		// width:100% and height:100% is ambiguous across devices, causing all kinds of headaches
		var w = parseInt(window.innerWidth), h = parseInt(window.innerHeight);
		if ((w == mWorldWidth) && (h == mWorldHeight)) { return; }

		mWorldWidth = w; mWorldHeight = h;
				
		if (mWord != null) { WordShowResize(); }

		if (mWorldDiv)
		{
			mWorldDiv.style.width = mWorldWidth + "px";
			mWorldDiv.style.height = mWorldHeight + "px";

			mCanvasMain.width = mWorldWidth;   // do NOT use px
			mCanvasMain.height = mWorldHeight;

			CurtainRefresh(0);
		}
		WorldPlayFieldResize();

		// ----------
		let shadowSize = -1;
		
		let fontSize = (mWorldWidth > mWorldHeight) ? Math.floor(mWorldHeight * 0.075) : Math.floor(mWorldWidth * 0.075);
		
		if (mStatTopLeftDiv != null)
		{
			mStatTopLeftDiv.style.fontSize = fontSize;
			mStatTopLeftDiv.style.color = "#FFFF00FF";
			mStatTopLeftDiv.style.opacity = 1;
			shadowSize = Math.floor(fontSize * 0.04);
			mStatTopLeftDiv.style.textShadow = shadowSize + "px " + shadowSize + "px " + "0px #000000FF";

			mStatTopRightDiv.style.fontSize = fontSize;
			mStatTopRightDiv.style.color = "#FFFF00FF";
			mStatTopRightDiv.style.opacity = 1;
			shadowSize = Math.floor(fontSize * 0.04);
			mStatTopRightDiv.style.textShadow = shadowSize + "px " + shadowSize + "px " + "0px #000000FF";

			mStatBottomLeftDiv.style.fontSize = fontSize;
			mStatBottomLeftDiv.style.color = "#FFFF00FF";
			mStatBottomLeftDiv.style.opacity = 1;
			shadowSize = Math.floor(fontSize * 0.04);
			mStatBottomLeftDiv.style.textShadow = shadowSize + "px " + shadowSize + "px " + "0px #000000FF";

			mStatBottomRightDiv.style.fontSize = fontSize;
			mStatBottomRightDiv.style.color = "#FFFF00FF";
			mStatBottomRightDiv.style.opacity = 1;
			shadowSize = Math.floor(fontSize * 0.04);
			mStatBottomRightDiv.style.textShadow = shadowSize + "px " + shadowSize + "px " + "0px #000000FF";
		}
	}
}
window.onresize = WorldResize;

function WorldResizeUpdate()
{
	// Resize event doesn't fire on iPhone when link is shortcut on home page. This subsidez
	// OnResize doesn't fire properly when it's on an iPhone home screen
	var w = parseInt(window.innerWidth), h = parseInt(window.innerHeight);
	if ((w != mWorldWidth) || (h != mWorldHeight)) { WorldResize(1); }
	window.setTimeout(WorldResizeUpdate, 1000)
}


/*
FAILURE: Want WorldResetIncrease and WorldResetShift to share this, BUT it only works for INCREASING
function WorldResetResizePlayfield(pChangeX, pChangeY, pNewTileXCount)
{
	// pChangeX, pChangeY - how much (positive OR negative) to change mTileXCount and mTileYCount by
	// Assumes mTileXCOunt, mTileYCount and mPlayfield are CURRENT
	
	mPlayer.left += pChangeX;
	mPlayer.top += pChangeY;
	mPlayer.xyIndex = mPlayer.top * pNewTileXCount + mPlayer.left;

	if (mRestart.xyIndexRemember != -1)
	{
		let restartY = parseInt(mRestart.xyIndexRemember / mTileXCount);
		let restartX = mRestart.xyIndexRemember - (restartY * mTileXCount);
		restartX += pChangeX;
		restartY += pChangeY;
		mRestart.xyIndexRemember = restartY * pNewTileXCount + restartX;
	}

	// <TILES>
	// increases size of Playfield AND Solutions

	// Prep 3 Temp Array Holders
	for (var index = 0; index < mPlayField.length; index++)
	{
		mSolveCrazyPlayFields[0][index] = 0;   // temporarily hold mSolvedPlayfield[0]
		mSolveCrazyPlayFields[1][index] = 0;   // temporarily hold mSolvedPlayfield[1]
		mSolveCrazyPlayFields[2][index] = 0;   // temporarily hold mPlayField
	}

	// Translate old size into temp new size (put in above arrays)
	for (let x = 0; x < mTileXCount; x++)
	{
		for (let y = 0; y < mTileYCount; y++)
		{
			if (mSolvedPlayfieldTurn[0] != 100000) { mSolveCrazyPlayFields[0][(y + pChangeY) * pNewTileXCount + (x + pChangeX)] = mSolvedPlayfield[0][y * mTileXCount + x]; }
			if (mSolvedPlayfieldTurn[1] != -1) { mSolveCrazyPlayFields[1][(y + pChangeY) * pNewTileXCount + (x + pChangeX)] = mSolvedPlayfield[1][y * mTileXCount + x]; }
			mSolveCrazyPlayFields[2][(y + pChangeY) * pNewTileXCount + (x + pChangeX)] = mPlayField[y * mTileXCount + x];
		}
	}

	// Copy temp new size back into old
	for (var index = 0; index < mPlayField.length; index++)
	{
		if (mSolvedPlayfieldTurn[0] != 100000) { mSolvedPlayfield[0][index] = mSolveCrazyPlayFields[0][index]; }
		if (mSolvedPlayfieldTurn[1] != -1) { mSolvedPlayfield[1][index] = mSolveCrazyPlayFields[1][index]; }
		mPlayField[index] = mSolveCrazyPlayFields[2][index];
	}		
	// </TILES>
}
*/

function WorldResetIncrease(pAmount = 1)
{
	// Expands the border around the playfield. 1 = a border of size 1 will be ATTEMPTED or as MUCH as we can add
	// Only in use by Extra

	let xIncrease1 = 0, xIncrease2 = 0;
	let yIncrease1 = 0, yIncrease2 = 0;

	while (pAmount > 1)
	{
		if ( ((mTileXCount + xIncrease1 + xIncrease2 + 2) * (mTileYCount + yIncrease1 + yIncrease2 + 2)) <= (mTileXMax * mTileYMax) )
		{
			xIncrease1 += 1; xIncrease2 += 1;
			yIncrease1 += 1; yIncrease2 += 1;	
		}
		pAmount -= 1;
	}

	if ( ((mTileXCount + xIncrease1 + xIncrease2 + 2) * (mTileYCount + yIncrease1 + yIncrease2 + 2)) <= (mTileXMax * mTileYMax) )
	{
		// xxxxx
		// xyyyx
		// xxxxx
		// 3x1 > 5x3
		xIncrease1 += 1; xIncrease2 += 1;
		yIncrease1 += 1; yIncrease2 += 1;	
	}
	else
	{
		// can't expand in all directions, so try expanding 1, 2 or 3 ...
		let space = (mTileXMax * mTileYMax) - (mTileXCount * mTileYCount);
		space -= mTileYCount;   // if only 1 side is added, no need for + 1
		if (space >= 0)
		{
			xIncrease1 += 1;
			space -= (mTileXCount + 1);
			if (space >= 0)
			{
				yIncrease1 += 1;
				space -= (mTileYCount + 1);
				if (space >= 0)
				{
					xIncrease2 += 1;
					space -= (mTileXCount + 1);
					if (space >= 0)
					{
						alert("ERROR: We were able to add 4 sides. Should have happened earlier!");
					}
				}
			}
		}
	}
	
	if ((xIncrease1 > 0) || (yIncrease1 > 0))
	{
		let newTileXCount = mTileXCount + xIncrease1 + xIncrease2;

		mPlayer.left += xIncrease1;
		mPlayer.top += yIncrease1;
		mPlayer.xyIndex = mPlayer.top * newTileXCount + mPlayer.left;
	
		if (mRestart.xyIndexRemember != -1)
		{
			let restartY = parseInt(mRestart.xyIndexRemember / mTileXCount);
			let restartX = mRestart.xyIndexRemember - (restartY * mTileXCount);
			restartX += xIncrease1;
			restartY += yIncrease1;
			RestartPosition(restartY * newTileXCount + restartX);
		}
		
		// <TILES>
		// increases size of Playfield AND Solutions

		// Prep 3 Temp Array Holders
		for (var index = 0; index < mPlayField.length; index++)
		{
			mSolveCrazyPlayFields[0][index] = 0;   // temporarily hold mSolvedPlayfield[0]
			mSolveCrazyPlayFields[1][index] = 0;   // temporarily hold mSolvedPlayfield[1]
			mSolveCrazyPlayFields[2][index] = 0;   // temporarily hold mPlayField
		}

		// Translate old size into temp new size (put in above arrays)
		for (let x = 0; x < mTileXCount; x++)
		{
			for (let y = 0; y < mTileYCount; y++)
			{
				if (mSolvedPlayfieldTurn[0] != 100000) { mSolveCrazyPlayFields[0][(y + yIncrease1) * newTileXCount + (x + xIncrease1)] = mSolvedPlayfield[0][y * mTileXCount + x]; }
				if (mSolvedPlayfieldTurn[1] != -1) { mSolveCrazyPlayFields[1][(y + yIncrease1) * newTileXCount + (x + xIncrease1)] = mSolvedPlayfield[1][y * mTileXCount + x]; }
				mSolveCrazyPlayFields[2][(y + yIncrease1) * newTileXCount + (x + xIncrease1)] = mPlayField[y * mTileXCount + x];
			}
		}

		// Copy temp new size back into old
		for (var index = 0; index < mPlayField.length; index++)
		{
			if (mSolvedPlayfieldTurn[0] != 100000) { mSolvedPlayfield[0][index] = mSolveCrazyPlayFields[0][index]; }
			if (mSolvedPlayfieldTurn[1] != -1) { mSolvedPlayfield[1][index] = mSolveCrazyPlayFields[1][index]; }
			mPlayField[index] = mSolveCrazyPlayFields[2][index];
		}		

		ChangeTileCount(mTileXCount + xIncrease1 + xIncrease2, mTileYCount + yIncrease1 + yIncrease2);
		// </TILES>
	}	
}


function WorldResetShift()
{
	// some levels generate "empty borders". fix that here.
	// does NOT fix everything "attached" to the tiles (mPlayFieldDivs) - JUST mPlayField
	// console.assert((mSolvedPlayfieldTurn[0] == 100000) && (mSolvedPlayfieldTurn[1] == -1), "WorldResetShift Error: mSolvedPlayfieldTurn has been filled out (and we'll mess that up)"); 

	var x1 = 1000, x2 = -1, y1 = 1000, y2 = -1;	
	for (var xx = 0; xx < mTileXCount; xx++)
	{
		for (var yy = 0; yy < mTileYCount; yy ++)
		{
			if (mPlayField[yy * mTileXCount + xx] > 0)
			{
				if (xx < x1) { x1 = xx; }
				if (xx > x2) { x2 = xx; }
				if (yy < y1) { y1 = yy; }
				if (yy > y2) { y2 = yy; }			
			}
		}
	}
	console.assert((x1 != 1000) && (x2 != -1) && (y1 != -1000) && (y2 != -1), "that's beyond fucked yo.");

	// alert("HEY " + mTileXCount + "x" + mTileYCount + "   " + ((x2 - x1) + 1) + "x" + ((y2 - y1) + 1));  
	let holdExtra = new Array(mPlayField.length);
	for (let index = 0; index < holdExtra.length; index++) { holdExtra[index] = {}; }
	
	if ( (((x2 - x1) + 1) != mTileXCount) || (((y2 - y1) + 1) != mTileYCount) )
	{		
		for (var index = 0; index < mPlayField.length; index++)
		{
			if (mSolvedPlayfieldTurn[0] != 100000) { mSolveCrazyPlayFields[0][index] = mSolvedPlayfield[0][index]; }
			if (mSolvedPlayfieldTurn[1] != -1) { mSolveCrazyPlayFields[1][index] = mSolvedPlayfield[1][index]; }
			mSolveCrazyPlayFields[2][index] = mPlayField[index];
			mPlayFieldDivs[index].ShiftSave(holdExtra[index]);
		}

		for (var index = 0; index < mPlayField.length; index++)
		{
			if (mSolvedPlayfieldTurn[0] != 100000) { mSolvedPlayfield[0][index] = 0; }
			if (mSolvedPlayfieldTurn[1] != -1) { mSolvedPlayfield[1][index] = 0; }
			mPlayField[index] = 0;
			mPlayFieldDivs[index].Reset(false);   // extra reset, does NOT reset visuals
		}	

		var originalTileXCount = mTileXCount;
		ChangeTileCount((x2 - x1) + 1, (y2 - y1) + 1);
		
		for (var x = x1; x <= x2; x++)
		{
			for (var y = y1; y <= y2; y++)
			{
				if (mSolvedPlayfieldTurn[0] != 100000) { mSolvedPlayfield[0][(y - y1) * mTileXCount + (x - x1)] = mSolveCrazyPlayFields[0][y * originalTileXCount + x]; }
				if (mSolvedPlayfieldTurn[1] != -1) { mSolvedPlayfield[1][(y - y1) * mTileXCount + (x - x1)] = mSolveCrazyPlayFields[1][y * originalTileXCount + x]; } 
				mPlayField[(y - y1) * mTileXCount + (x - x1)] = mSolveCrazyPlayFields[2][y * originalTileXCount + x];
				// holdExtra[y * originalTileXCount + x].ShiftCopy(mPlayFieldDivs[(y - y1) * mTileXCount + (x - x1)]);
				mPlayFieldDivs[(y - y1) * mTileXCount + (x - x1)].ShiftLoad(holdExtra[y * originalTileXCount + x]);
			}
		}
		
		mPlayer.left -= x1;
		mPlayer.top -= y1;
		mPlayer.xyIndex = mPlayer.top * mTileXCount + mPlayer.left;

		if (mRestart.xyIndexRemember != -1)
		{
			let restartY = parseInt(mRestart.xyIndexRemember / originalTileXCount);
			let restartX = mRestart.xyIndexRemember - (restartY * originalTileXCount);
			restartX -= x1;
			restartY -= y1;
			RestartPosition(restartY * mTileXCount + restartX);
		}
	}
}

function WorldResetInitialize(pFull)
{
	// Do NOT touch mLevelIndex or mTalkIndex, which have selected the World we're resetting
	if (pFull)
	{	
		mWorldLevelCount++;
		mLevelStageCount = 0;   // LevelType:Boss has THREE stages
		mTileTotal = 0;
		mTileTotalRemember = 0;

		mWorldState2Action = 0;
		mScoreUpdated = 0;

		mTalkCurrentTimeRemember = 0;	
		mGrowCount = 0;
		mGrowDie = false;		
		mSolveUpdateColorFlag = true;
		mWorldResetCheckFailsafe = 0;	
		mUseTheForceState = 0;

		mWorldResetUpdateCount = 0;
		mSolveStart = Date.now();

		mWorldRepeatCount = 0;
		
		mStatNewSolution = 0;
		mSolveStatAttempt = 0;
		mSolveStatTitle = "";
		
		mWord.tileTotal = 0;
	}
	
	RestartInitialize();
	
	CurtainRefresh(2);
	
	mWorldState = 0;   // 0:Building
	mWorldState2Action = 0;   // Set when mWorldState == 2
	mWorldStateAlive = 0;
	mState = 0;   // 0:Checking if puzzle can be solved
	
	mLevelIndex = -1;

	// Answers will be loaded from file (levelsget / LevelFileIntoMemory)
	mSolvedPlayfieldTurn[0] = 100000;
	mSolvedPlayfieldTurn[1] = -1;
	for (var answer = 0; answer < 2; answer++)
	{
		for (var index = 0; index < mSolvedPlayfield[answer].length; index++) { mSolvedPlayfield[answer][index] = 0; }
	}

	for (var index = 0; index < mPlayFieldDivs.length; index++)
	{
		mPlayField[index] = 0;
		mPlayFieldDivs[index].Reset(false);   // this is overkill, BUT I got paranoid & worried.
	}
	
	mFinishxyIndex = -1;
	mSolutionsFileRemember = 0;
}


let mWorldResetNewLevelIndexSpecial = -1;
function WorldResetNew()
{	
	/*
	Called for 2 cases:
	. Game Start/Restart: Levels have just been loaded from file.
	. Game Playing: Everytime a level is completed this is called. 10 levels means this is called 10 times.
	
	. Can ONLY do upcoming level initialization here, NO World initialization (MenuMainRestart does that)
	. Unlike WorldReset, does NOT generate levels and therefore is not being called over and over again during creation.
	  Just called once per level (MUCH simpler to think about)  
	*/
	console.assert(mWorldMode > 0, "WorldResetNew Error: It can only be used by Weekdays - NOT 'Tale of Frank'");
	console.assert(
		(mLevelGenerate == null) || (mLevelGenerate == "fix")
		, "WorldResetNew Error: It's been asked to generated levels! It can't. mLevelGenerate != null '" + mLevelGenerate + "'"
	);
	
	// if levels have not arrived yet, wait.
	if (mLevels == null) { window.setTimeout(WorldResetNew, 500); return; }
	WorldResetInitialize(true);
	// Even though the loaded level is complete (not 0) and valid (not 1), we'll leave it at 0 so level starts flashing

	// mWeekdayLevelsRemaining dictates what level we're on. Starts at mLevels.length and counts down. Initialized in MenuMainRestart and LevelsGet
	// mLevelIndex is just a temp variable Frank to pass between WorldReset and WorldResetFinish (and we inherited)	
	mLevelIndex = mLevels.length - mWeekdayLevelsRemaining;
	mLevelType = LevelType.Regular;

	let holdErrorMessage = LevelFileIntoMemory();   // Sets up CURRENT Level using legacy mLevelIndex: mState, mSolutions, mWorldType, mWorldExtreme
	if (holdErrorMessage != "")
	{
		alert("WorldResetNew Error: LevelFileIntoMemory found problems in JSON. mLevelIndex:'" + mLevelIndex + "'\n" + holdErrorMessage);
	}
	else
	{
		holdErrorMessage = WorldCheck();   // everything should be great, but a paranoid check never hurt
		if (holdErrorMessage != "")
		{
			alert("WorldResetNew Error: WorldCheck found problems in the JSON. mLevelIndex:'" + mLevelIndex + "'\n" + holdErrorMessage);
		}
		else
		{
			mState = 0;
			mState = SolveUpdateStart();   // keep the 2 answers but redo everything (solution count, finalTile), must be done BEFORE Extras get added
			if (mState == 1)
			{
				alert("WorldResetNew Error: SolveUpdateStart returned FAIL (mState == 1) on a JSON level. mLevelIndex:'" + mLevelIndex + "'");
			}
			else
			{
				if (mLevelGenerate == "fix")
				{
					window.setTimeout(WorldResetUpdate, 15);
				}
				else
				{
					TalkStatesReset();

					if (mWorldResetNewLevelIndexSpecial == -1) { mWorldResetNewLevelIndexSpecial = 4; }

					let worldResetFinish = true;
					// Do not want extras put at the beginning (new players) or near the end (levels already complicated)
					if (
						(mLevelIndex >= mWorldResetNewLevelIndexSpecial)
						&& (mLevelIndex < mLevels.length - 2)
					)
					/*
					if (
						( ((mLevelIndex % 10) > 3) && ((mLevelIndex % 10) < 8) )   // Levels 4,5,6,7 ot 14,15,16,17
						&& ( mWeekdayExtraAdded < (Math.floor(mLevelIndex / 10) + 1) )   // Has NOT happened in this group of 10
						&& ( (Math.ceil(mLevelIndex / 10) * 10) <= mLevels.length )  // If we're at 15 levels, does NOT happen on 14,15,16,17
					)
					*/
					{
						// Overall there's a ~40% chance something special will be applied
						// Will only happen ONCE er game (sometimes not at all)
						// Saturday and Sunday have 20 levels, so they can get TWO of these
						// These are JUST distractions and NONE of them will increase time or steps taken
						
						// <EXTRA>
						if (
							(mLevels[mLevelIndex][15] != null)   // [15] contains array of extra tiles 
							&& (mTileTotal < 125)   // don't want hard level + extra tile
							&& (Math.random() < 0.18)
						)
						{
							mTalkStates[TalkType.tileExtra] = 1;
							MenuWeekdayExtraTile();
							mWorldResetNewLevelIndexSpecial = mLevelIndex + 6;
							worldResetFinish = false;
						}
						// </EXTRA>

						// <FINISH>
						else if (
							( (mLevels[mLevelIndex][4] == 2) && (mLevels[mLevelIndex][1] > 2) )
							// [4] == 2 means solved completely guaranteeing 2 finishes/2 full pink answers
							// [1] > 2 means level has lots of possible finishes, so playe can finish wrong
							&& (Math.random() < 0.18)
						)
						{
							mTalkStates[TalkType.finishTile] = 1;
							MenuWeekdayFinishTile();
							mWorldResetNewLevelIndexSpecial = mLevelIndex + 6;
							worldResetFinish = false;
						}
						// </FINISH>

						// <INVISIBLE>
						else if (Math.random() < 0.08)
						{
							mTalkStates[TalkType.tileInvisible] = 3;
							MenuWeekdayInvisible();
							mWorldResetNewLevelIndexSpecial = mLevelIndex + 6;
							worldResetFinish = false;
						}
						// </INVISIBLE>

						// <FAIL>
						else if (Math.random() < 0.08)
						{
							mTalkStates[TalkType.randomFail] = 1;
							MenuWeekdayRandomFail();
							mWorldResetNewLevelIndexSpecial = mLevelIndex + 6;
							worldResetFinish = false;
						}
						// </FAIL>
					}
					
					if (worldResetFinish) { WorldResetFinish(); }
				}
			}
		}
	}
}

function WorldReset(pFull = true)
{
	// Can be called MULTIPLE times for ONE talk (player finishes multiple levels during one talk)
	// Called MULTIPLE times while generating a level (SolveUpdate concludes it's a fail, so everything is WorldReset(true))
	// This should be rewritten so it's only called once while generating a level (WorldResetUpdate should ENTIRELY take over until it's generated)

	// if levels have not arrived yet, wait.
	if (mLevels == null) { window.setTimeout(WorldReset, 500); return; }

	if (mTalkIndex == 30)
	{
		MenuFrankEnd();
		return;
	}

	WorldResetInitialize(pFull);

	// <SELECT A TYPE OF LEVEL>
	// we'll either get it from thousands of levels in JSON, or we'll generate it (can take FOREVER)
	if (pFull)
	{	
		// <Talk:mLevelType>
		if (mTalkLevelCount == 0)   // The FIRST TIME we're on this talk (player can finish many levels during one talk)
		{
			// States in [4] column need to be setup BEFORE levels are rendered.
			// (States in [3] happen during talk (after the levels have been created))
			if (mTalkIndex < mTalk3000Index)
			{
				if (mTalks[mTalkIndex][4] != null)
				{
					let holdTalkStates = mTalks[mTalkIndex][4];
					for (let index = 0; index < holdTalkStates.length; index++)
					{
						mTalkStates[holdTalkStates[index].type1] = holdTalkStates[index].type2;
					}
				}
				mLevelType = mTalks[mTalkIndex][0];
			}		
			/*
			mLevelType = LevelType.Regular;
			if ( (mMusic.talkIndex == -1) && (mTalkLastDate == 0) && (mTalkIndex < mTalk3000Index) ) { mLevelType = mTalks[mTalkIndex][0]; }
			console.log("HEY HEY:" + Object.keys(LevelType)[mLevelType] + "   " + mMusic.talkIndex + "," + mTalkLastDate + "," + mTalkIndex);
			*/
		}
		else
		{
			mLevelType = LevelType.Regular;   // Talk still says Bonus/Milestone/Boss/One Hundred, BUT we finished. Play regular levels until its time for next talk
		}
		// </Talk:mLevelType>
		
		mWorldType = -1;
		mWorldExtreme = false;
		
		let total = mStatNewFrankLoss + mStatNewFrankWin + 1;
		
		const myParam = urlParams.get("worldtype");
		if (myParam != null)
		{
			mLevelType = LevelType.Regular;
			mWorldType = parseInt(myParam);
			const myParam2 = urlParams.get("worldtypeextreme");
			if ( (myParam2 != null) && (myParam2 != "") && (myParam2 == "true") ) { mWorldExtreme = true; }
		}
		else if (mTalkStates[TalkType.randomFail] == 1)
		{
			// Fail is broken. Player MUST figure this out BEFORE gregg/frank/jake reveal it. MUST be easy
			mLevelType = LevelType.Regular;
			mWorldType = WorldType.DenseEasy;
		}
		else if ((mWorldLevelCount == 0) && (mLevelType == LevelType.Regular))
		{
			//  Even if they continue Frank, first level is EASY (don't turn them off the game)
			mLevelType = LevelType.Regular;
			mWorldType = WorldType.DenseEasy;
		}
		else if (total < 21)
		{
			mLevelType = LevelType.Regular;
			mWorldType = WorldType.Dense;
		}
		else if (mLevelType == LevelType.OneHundred)
		{
			mSolveUpdateColorFlag = false;
			mWorldExtreme = true;   // RailsBonus only available in Extreme
			if (Math.random() < 0.5)
			{
				mWorldType = WorldType.RailsBonus;   // one thin path that's impossible to fail
			}
			else
			{
				mWorldType = WorldType.RailsBonusMirror;   // one thin path but very easy, even though it's large/extreme
			}
		}
		else if (mLevelType == LevelType.MileStone)
		{
			// MILESTONE
			mSolveUpdateColorFlag = false;
			mWorldExtreme = true;
			mWorldTypeMilestoneCounter = (mWorldTypeMilestoneCounter + 1) % 4;
			switch (mWorldTypeMilestoneCounter)
			{
				case 0:
					mWorldType = WorldType.TwoByTwoBonus;
					break;
				case 1:
					mWorldType = WorldType.TwoByTwoBonusMirror;
					break;					
				case 2:
					mWorldType = WorldType.SnakeTwoByTwoBonus;
					break;
				case 3:
					mWorldType = WorldType.RingsBonus;
					break;
				default:
					console.log("WorldReset() Unhandled mWorldTypeMilestoneCounter case: " + mWorldTypeMilestoneCounter);
					break;
			}			
		}
		else if (mLevelType == LevelType.Boss)
		{
			// BOSS - hardest, take time to render
			mSolveUpdateColorFlag = false;
			mWorldExtreme = true;
			mWorldType = WorldType.Stripes;
		}
		else if (mLevelType == LevelType.Bonus)
		{
			// BONUS
			mSolveUpdateColorFlag = false;
			mWorldTypeBonusCounter = (mWorldTypeBonusCounter + 1) % 4;
			switch (mWorldTypeBonusCounter)
			{
				case 0:
					mWorldType = WorldType.TwoByTwoBonus;
					break;
				case 1:
					mWorldType = WorldType.TwoByTwoBonusMirror;
					break;					
				case 2:
					mWorldType = WorldType.SnakeTwoByTwoBonus;
					break;
				case 3:
					mWorldType = WorldType.RingsBonus;
					break;
				default:
					console.log("WorldReset() Unhandled mWorldTypeBonusCounter case: " + mWorldTypeBonusCounter);
					break;
			}
		}
		
		/*
		// <EXTRA>
		// BEFORE WE CACHED EXTRA, we picked a JSON level and dynamically added extra
		// Now we pick levels that have Extra in JSON
		else if (mTalkStates[TalkType.tileExtra] > 0)
		{
			// takes too long to add tiles to certain types of levels
			var choices = null;
			if (false)
			// if (Math.random() < 0.6)
			{
				mWorldExtreme = false;
				var keepers = [
				];

				choices = [
					WorldType.Dense, WorldType.DenseEasy, WorldType.DenseMirror, WorldType.Snake, WorldType.SnakeMirror, WorldType.CrissCross, WorldType.SnakeDense, WorldType.SnakeDenseMirror, WorldType.Mold
					, WorldType.Paintball, WorldType.Spiral, WorldType.Patches
					, WorldType.DenseMold, WorldType.Plus, WorldType.Donut, WorldType.Box, WorldType.PlusPlus, WorldType.Pane
					, WorldType.SinWav, WorldType.HashTag, WorldType.SnakeImproved, WorldType.Monolith, WorldType.Corner				
				];
				
				mWorldTypeBonusCounter++;
				mWorldType = choices[mWorldTypeBonusCounter];
			}		
			else
			{
				mWorldExtreme = true;

				choices = [
					WorldType.Dense, WorldType.DenseMirror, WorldType.Snake, WorldType.SnakeMirror, WorldType.CrissCross, WorldType.SnakeDense, WorldType.SnakeDenseMirror, WorldType.Mold
					, WorldType.Paintball, WorldType.Spiral, WorldType.Patches
					, WorldType.Plus, WorldType.Donut, WorldType.Box, WorldType.PlusPlus
					, WorldType.SinWav, WorldType.HashTag, WorldType.SnakeImproved, WorldType.Monolith				
				];
				mWorldTypeBonusCounter++;
				mWorldType = choices[mWorldTypeBonusCounter];
			}
		}
		// </EXTRA>
		*/
	
		else if (mLevelType == LevelType.Regular)
		{
			// Regular
			// consider switching to random, BUT adjust # of levels to "weight" things
			// i.e. DenseEasy has 100 levels, Corner:Extreme has 20
			mWorldTypeCounter = (mWorldTypeCounter + 1) % 90;
			switch (mWorldTypeCounter)
			{
				case 0: mWorldType = WorldType.Dense; break;
				case 1: mWorldType = WorldType.SnakeTwoByTwo; break;
				case 2: mWorldType = WorldType.SnakeDense; break;
				case 3: mWorldType = WorldType.Spiral; break;
				case 4: mWorldType = WorldType.Dense; break;						
				case 5: mWorldType = WorldType.DenseMirror; break;						
				case 6: mWorldType = WorldType.Pane; break;		
				case 7: mWorldType = WorldType.Mold; break;
				case 8: mWorldType = WorldType.DenseEasy; break;
				case 9: mWorldType = WorldType.DenseEasy; break;

				case 10: mWorldType = WorldType.Monolith; break;
				case 11: mWorldType = WorldType.Donut; break;
				case 12: mWorldType = WorldType.Vertigo; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 13: mWorldType = WorldType.Dense; break;
				case 14: mWorldType = WorldType.ThreeSixty; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 15: mWorldType = WorldType.Paintball; break;
				case 16: mWorldType = WorldType.HashTag; break;					
				case 17: mWorldType = WorldType.DenseEasy; break;
				case 18: mWorldType = WorldType.DenseEasy; break;
				case 19: mWorldType = WorldType.Corner; break;

				case 20: mWorldType = WorldType.DenseMold; break;
				case 21: mWorldType = WorldType.Snake; break;
				case 22: mWorldType = WorldType.SnakeMirror; break;
				case 23: mWorldType = WorldType.Plus; break;
				case 24: mWorldType = WorldType.Snake; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 25: mWorldType = WorldType.SnakeDense; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 26: mWorldType = WorldType.Patches; break;
				case 27: mWorldType = WorldType.Dense; break;
				case 28: mWorldType = WorldType.DenseMirror; break;
				case 29: mWorldType = WorldType.Vertigo; break;

				case 30: mWorldType = WorldType.DenseEasy; break;
				case 31: mWorldType = WorldType.DenseEasy; break;				
				case 32: mWorldType = WorldType.ThreeSixty; break;				
				case 33: mWorldType = WorldType.Dense; break;
				case 34: mWorldType = WorldType.DenseMirror; break;
				case 35: mWorldType = WorldType.CrissCross; break;
				case 36: mWorldType = WorldType.Mold; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 37: mWorldType = WorldType.Box; break;
				case 38: mWorldType = WorldType.DenseEasy; break;
				case 39: mWorldType = WorldType.DenseEasy; break;

				case 40: mWorldType = WorldType.SinWav; break;
				case 41: mWorldType = WorldType.Pane; break;
				case 42: mWorldType = WorldType.SnakeTwoByTwo; break;
				case 43: mWorldType = WorldType.SnakeDense; break;
				case 44: mWorldType = WorldType.Snake; break;
				case 45: mWorldType = WorldType.HashTag; mWorldExtreme = true; break;
				case 46: mWorldType = WorldType.DenseEasy; break;
				case 47: mWorldType = WorldType.DenseEasy; break;				
				case 48: mWorldType = WorldType.Pane; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 49: mWorldType = WorldType.DenseMold; break;

				case 50: mWorldType = WorldType.Dense; break;
				case 51: mWorldType = WorldType.Paintball; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 52: mWorldType = WorldType.Spiral; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 53: mWorldType = WorldType.SnakeDenseMirror; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 54: mWorldType = WorldType.Patches; mWorldExtreme = true; break;
				case 55: mWorldType = WorldType.DenseEasy; break;
				case 56: mWorldType = WorldType.DenseEasy; break;				
				case 57: mWorldType = WorldType.Donut; break;
				case 58: mWorldType = WorldType.Box; mWorldExtreme = true; break;
				case 59: mWorldType = WorldType.DenseMold; break;

				case 60: mWorldType = WorldType.PlusPlus; break;
				case 61: mWorldType = WorldType.SinWav; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;	
				case 62: mWorldType = WorldType.Dense; break;
				case 63: mWorldType = WorldType.DenseMirror; break;
				case 64: mWorldType = WorldType.Dense; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 65: mWorldType = WorldType.Snake; break;
				case 66: mWorldType = WorldType.SnakeMirror; break;
				case 67: mWorldType = WorldType.DenseEasy; break;
				case 68: mWorldType = WorldType.Corner; break;				
				case 69: mWorldType = WorldType.DenseEasy; break;

				case 70: mWorldType = WorldType.Monolith; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 71: mWorldType = WorldType.Plus; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 72: mWorldType = WorldType.CrissCross; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 73: mWorldType = WorldType.Dense; break;
				case 74: mWorldType = WorldType.Paintball; break;
				case 75: mWorldType = WorldType.DenseMirror; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 76: mWorldType = WorldType.HashTag; break;
				case 77: mWorldType = WorldType.SnakeMirror; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 78: mWorldType = WorldType.DenseEasy; break;
				case 79: mWorldType = WorldType.DenseEasy; break;				

				case 80: mWorldType = WorldType.Corner; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 81: mWorldType = WorldType.DenseEasy; break;
				case 82: mWorldType = WorldType.DenseEasy; break;								
				case 83: mWorldType = WorldType.SnakeTwoByTwo; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 84: mWorldType = WorldType.SnakeImproved; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 85: mWorldType = WorldType.SnakeImproved; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 86: mWorldType = WorldType.DenseEasy; break;				
				case 87: mWorldType = WorldType.DenseEasy; break;
				case 88: mWorldType = WorldType.SnakeImproved; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;
				case 89: mWorldType = WorldType.PlusPlus; mWorldExtreme = true; mLevelType = LevelType.Tricky; break;					

				default: console.log("WorldReset() Unhandled mWorldTypeCounter case: " + mWorldTypeCounter); break;
			}
		}
		else
		{
			console.assert(1 == 0, "WorldReset() Error: Unhandled mLevelType '" + mLevelType + "'. Remember: Talks do NOT specify .Tricky");
		}		
		// debugjim
		// mWorldType = WorldType.SnakeImproved; mWorldExtreme = true; mLevelType = LevelType.Tricky;
	}
	// </SELECT A TYPE OF LEVEL>
	
	// <URINESTATE>
	mUrineState = 0;
	if ( (mLevelGenerate != null) && (mLevelGenerate[2] == 1) )
	{
		mUrineState = 1;
	}
	else if (mTalkStates[TalkType.urine] > 0)
	{
		if (Math.random() < 0.5) { mUrineState = 1; } else { mUrineState = 2; }
	}
	// </URINESTATE>
	
	// <LOAD LEVEL>
	let total = mStatNewFrankLoss + mStatNewFrankWin + 1;

	mLevelIndex = -1;	
	if (mLevelGenerate != null)
	{
		mLevelType = LevelType.Regular;
		mWorldType = parseInt(mLevelGenerate[0]);
		mWorldExtreme = (mLevelGenerate[1] === "true");
	}
	else if (total >= 21)   // Below 21 and the code dynamically generates the level (need to replace with levels)
	{
		// mLevelType = specified by Talk (and WorldReset(FULL))
		var levels = new Array();

		// <TILEEXTRA>
		if (mTalkStates[TalkType.tileExtra] > 0)
		{
			for (var index = 0; index < mLevels.length; index++)
			{
				if (
					(mLevels[index][3] == 0)   // not already chosen
					&& (mLevels[index][15] != null)   // has an array of extras
					&& (mLevels[index][6] == 0)   // not urine (there's abug if broken urine got extra tiles)
				)
				{
					levels.push(index);
				}
			}
		}
		// </TILEEXTRA>
		
		// <FINISHTILE>
		else if (mTalkStates[TalkType.finishTile] > 0)
		{
			console.assert(mUrineState == 0, "WorldReset() Error: mTalkStates[TalkType.finishTile] > 0 BUT mUrineState != 0 '" + mUrineState + "'");
			for (var index = 0; index < mLevels.length; index++)
			{
				if (
					(mLevels[index][3] == 0)   // not already chosen
					&& ( (mLevels[index][1] >= 3) && (mLevels[index][1] <= 5) )   // has 3,4 or 5 finish tiles
					&& (mLevels[index][6] == 0)   // not urine
				)
				{
					levels.push(index);
				}
			}
		}
		// <FINISHTILE>
		
		else
		{
			var holdExtreme = 0; if (mWorldExtreme) { holdExtreme = 1; }	
			var holdUrineState = 0; if (mUrineState == 1) { holdUrineState = 1; }

			for (var index = 0; index < mLevels.length; index++)
			{
				if (
					(mLevels[index][3] == 0)					
					&& (mLevels[index][0] == mWorldType) 
					&& ( (mLevels[index][1] < 3) || (mLevels[index][1] > 5) )
					&& (mLevels[index][2] == holdExtreme)
					&& (mLevels[index][6] == holdUrineState)
				)
				{
					levels.push(index);
				}
			}
			console.assert(levels.length > 0, "NO LEVELS FOUND!!! " + Object.keys(WorldType)[mWorldType] + ":" + mWorldType + " " + levels.length + " of " + mLevels.length);
			
			if (levels.length == 0)
			{
				// couldn't find the specific level, can i find ANY level (not used before)
				for (var index = 0; index < mLevels.length; index++)
				{
					if (
						(mLevels[index][3] == 0)					
						&& ( (mLevels[index][1] < 3) || (mLevels[index][1] > 5) )
						&& (mLevels[index][6] == holdUrineState)
					)
					{
						levels.push(index);
					}
				}
			}			
		}
		
		// debug
		// var levels = new Array();
		// for (var levelIndex = 0; levelIndex < mLevels.length; levelIndex++) { if (mLevels[levelIndex][3] == 0) { levels.push(levelIndex); break; } }
		
		if (levels.length > 0)
		{
			ShuffleArray(levels);
			mLevelIndex = levels[0];
		}
		else if (pFull)
		{
			// <RANDOM PICK>
			// The player has finished ALL cached levels!!!??? Generate random levels on the fly. Remove levels that take too long (mostly extreme)
			mLevelType = LevelType.Regular;
			var choices = null;
			if (Math.random() < 0.6)
			{
				mWorldExtreme = false;
				choices = [
					WorldType.Dense, WorldType.DenseEasy, WorldType.DenseMirror, WorldType.Snake, WorldType.SnakeMirror, WorldType.CrissCross, WorldType.SnakeDense, WorldType.SnakeDenseMirror, WorldType.Mold, WorldType.Paintball
					, WorldType.SnakeTwoByTwo, WorldType.Spiral, WorldType.DenseMold, WorldType.Vertigo, WorldType.Plus, WorldType.Donut, WorldType.Box, WorldType.PlusPlus, WorldType.Pane, WorldType.ThreeSixty, WorldType.SinWav
					, WorldType.HashTag, WorldType.SnakeImproved, WorldType.Monolith, WorldType.Corner
				];
			}		
			else
			{
				mWorldExtreme = true;
				choices = [
					WorldType.Snake, WorldType.CrissCross, WorldType.SnakeDenseMirror
					, WorldType.Spiral, WorldType.Plus, WorldType.Box
					, WorldType.ThreeSixty, WorldType.HashTag, WorldType.SnakeImproved
				];
			}
			mWorldType = choices[Math.floor(Math.random() * choices.length)];
			
			console.log("---------------------------------------------------");
			console.log(
				(mStatNewFrankWin + mStatNewFrankLoss + 1) + " " + mWorldType + ":" + Object.keys(WorldType)[mWorldType] + "," + mWorldExtreme
				+ "   W:" + mStatNewFrankWin + " L:" + mStatNewFrankLoss
			);			
			// <RANDOM PICK>
		}
	}
	// </LOAD LEVEL>
	
	if (mLevelIndex != -1)
	{
		console.assert(
			(mLevelGenerate == null) || (mLevelGenerate == "fix")
			, "WorldReset Error: We've picked a JSON level '" + mLevelIndex + "', but mLevelGenerate says GENERATE '" + mLevelGenerate + "'"
		);
	
		// <COPIED FROM WORLDRESETNEW>
		let holdErrorMessage = LevelFileIntoMemory();   // Sets mState, mSolutions, mWorldType, mWorldExtreme
		if (holdErrorMessage != "")
		{
			alert("WorldReset Error: LevelFileIntoMemory found problems in JSON. mLevelIndex:'" + mLevelIndex + "'\n" + holdErrorMessage);
		}
		else
		{
			holdErrorMessage = WorldCheck();   // everything should be great, but a paranoid check never hurt
			if (holdErrorMessage != "")
			{
				alert("WorldReset Error: WorldCheck found problems in the JSON. mLevelIndex:'" + mLevelIndex + "'\n" + holdErrorMessage);
			}
			else
			{
				mLevels[mLevelIndex][3] = 2;   // 2 means we TENTATIVELY will use this, but MIGHT not. WorldResetFinish makes this 1 (we'll definitely use this). 2 means "Don't pick again this WorldReset"
				mState = 0;
				mState = SolveUpdateStart();   // keep the 2 answers but redo everything (solution count, finalTile), must be done BEFORE Extras get added
				if (mState == 1)
				{
					alert("WorldReset Error: SolveUpdateStart returned FAIL (mState == 1) on a JSON level. mLevelIndex:'" + mLevelIndex + "'");
				}
				else
				{
					if (mLevelGenerate == "fix")
					{
						window.setTimeout(WorldResetUpdate, 15);
					}
					else
					{
						WorldResetFinish();
					}
				}
			}
		}
		// </COPIED FROM WORLDRESETNEW>
	}
	else
	{
		// FailSafe. If level takes more than 2 minutes to build, switch to Snake which is guaranteed to work
		// Doesn't help is Solving goes on FOREVER (thanks to 80,000 > 1,500,000)
		if ( ((Date.now() - mSolveStart) > 150.0 * 1000) && (mLevelGenerate == null) )
		{
			mWorldType = WorldType.Snake;   // guaranteed to work
			// inherit mWorldExtreme
		}

		let solved = false;
		switch (mWorldType)
		{
			case WorldType.Dense:
			{
				solved = WorldResetDense(pFull, mWorldExtreme);
				break;
			}
			case WorldType.DenseEasy:
			{
				solved = WorldResetDenseEasy(pFull, mWorldExtreme);
				break;
			}
			case WorldType.DenseMirror:
			{
				solved = WorldResetDenseMirror(pFull, mWorldExtreme);
				break;
			}
			case WorldType.Snake:
			{
				solved = WorldResetSnake(pFull, mWorldExtreme);
				break;
			}
			case WorldType.SnakeMirror:
			{
				solved = WorldResetSnakeMirror(pFull, mWorldExtreme);
				break;
			}
			case WorldType.CrissCross:
			{
				solved = WorldResetCrissCross(pFull, mWorldExtreme);
				break;
			}
			case WorldType.SnakeDense:
			{
				solved = WorldResetSnakeDense(pFull, mWorldExtreme);
				break;
			}
			case WorldType.SnakeDenseMirror:
			{
				solved = WorldResetSnakeDenseMirror(pFull, mWorldExtreme);
				break;
			}			
			case WorldType.Mold:
			{
				solved = WorldResetMold(pFull, mWorldExtreme);
				break;
			}
			case WorldType.Paintball:
			{
				solved = WorldResetPaintball(pFull, mWorldExtreme);
				break;
			}
			case WorldType.SnakeTwoByTwo:
			{
				solved = WorldResetSnakeTwoByTwo(pFull, mWorldExtreme);
				break;
			}
			case WorldType.Spiral:
			{			
				solved = WorldResetSpiral(pFull, mWorldExtreme);
				break;
			}
			case WorldType.Patches:
			{
				solved = WorldResetPatches(pFull, mWorldExtreme);
				break;
			}
			case WorldType.DenseMold:
			{
				solved = WorldResetDenseMold(pFull);
				break;
			}
			case WorldType.Stripes:
			{
				solved = WorldResetStripes(pFull, mWorldExtreme);
				break;
			}
			case WorldType.Vertigo:
			{
				solved = WorldResetVertigo(pFull, mWorldExtreme);
				break;
			}
			case WorldType.Plus:
			{
				solved = WorldResetPlus(pFull, mWorldExtreme);
				break;
			}		
			case WorldType.Donut:
			{
				solved = WorldResetDonut(pFull, mWorldExtreme);
				break;
			}		
			case WorldType.Box:
			{
				solved = WorldResetBox(pFull, mWorldExtreme);
				break;
			}		
			case WorldType.PlusPlus:
			{
				solved = WorldResetPlusPlus(pFull, mWorldExtreme);
				break;
			}		
			case WorldType.Pane:
			{
				solved = WorldResetPane(pFull, mWorldExtreme);
				break;
			}		
			case WorldType.ThreeSixty:
			{
				solved = WorldReset360(pFull, mWorldExtreme);
				break;
			}
			case WorldType.SinWav:
			{
				solved = WorldResetSinWave(pFull, mWorldExtreme);
				break;
			}
			case WorldType.HashTag:
			{
				solved = WorldResetHashTag(pFull, mWorldExtreme);
				break;
			}
			case WorldType.SnakeImproved:
			{
				solved = WorldResetSnakeImproved(pFull, mWorldExtreme);
				break;
			}
			case WorldType.Monolith:
			{
				solved = WorldResetMonolith(pFull, mWorldExtreme);
				break;
			}
			case WorldType.Corner:
			{
				solved = WorldResetCorner(pFull, mWorldExtreme);
				break;
			}
			
			// ---
			case WorldType.TwoByTwoBonus:
			{
				solved = WorldResetTwoByTwoBonus(pFull, mWorldExtreme);
				break;
			}
			case WorldType.TwoByTwoBonusMirror:
			{
				solved = WorldResetTwoByTwoBonusMirror(pFull, mWorldExtreme);
				break;
			}
			case WorldType.SnakeTwoByTwoBonus:
			{
				solved = WorldResetSnakeTwoByTwoBonus(pFull, mWorldExtreme);
				break;
			}			
			case WorldType.RingsBonus:
			{
				solved = WorldResetRingsBonus(pFull, mWorldExtreme);
				break;
			}		
			case WorldType.RailsBonus:
			{
				solved = WorldResetRailsBonus(pFull);
				break;
			}
			case WorldType.RailsBonusMirror:
			{
				solved = WorldResetRailsBonusMirror(pFull);
				break;
			}			

			// ---
			case WorldType.Monolith2:
			{
				solved = WorldResetMonolith2(pFull, mWorldExtreme);
				break;
			}

			default:
				console.error("WorldReset() Unhandled mWorldType enumeration: " + mWorldType);
				break;		
		}

		WorldResetShift();		
		console.assert(mState == 0, "WorldReset() Error: mState != 0 '" + mState + "'");

		if (mLevelGenerate != null)
		{
			// SolveUpdate needs to approve this level. Keep looping until 1 solution found.
			// Don't do any quick analysis to discard, might need to keep due to Urine

			// break it (hopefully) for URINE!
			// debugJIm - did NOT test this.
			if ( (solved) && (mLevelGenerate[2] == 1) )
			{
				var holdTotal = parseInt(mTileTotal * 0.025); if (holdTotal < 3) { holdTotal = 3; }
				holdTotal = 1;
				for (var count = 0; count < holdTotal; count++) { TileRemove(); }
			}

			mState = SolveUpdateStart();

			window.setTimeout(WorldResetUpdate, 15);
		}
		else
		{
			// Paranoid QUICK checks to ensure the level I generated IS solvable (I mean, I >think< they are but have not mathematically gauranteed that)
			// Known Problem: mWorldType:WorldType.TwoByTwo mWorldExtreme:true  sometimes generates BROKEN!!!
			mState = SolveUpdateStart();
			if (mState == 1)
			{
				// Generated Level is unfortunately broken. Good try. This is normal and happens ALL THE TIME (level didn't come from a file)
				window.setTimeout(WorldReset, 15, false);
			}
			else if (solved)
			{
				// We produced a valid level (Snake) but CANNOT PROVE THAT with WorldResetUpdate.SolveUpdate due to TOO MANY POSSIBILITIES
				// Trust that I'm right and it's solvable and start the game
				// Note: There may still be more solutions to find (mState = 0 means code will keep looking for more solutions), WorldUpdate.SolveUpdate will keep looking
				WorldResetFinish();
			}
			else
			{
				// SolveUpdate needs to approve this level. Keep looping until 1 solution found.
				window.setTimeout(WorldResetUpdate, 15);
			}
		}
	}
}

function WorldResetUpdateTiles(pType)
{
	switch (pType)
	{
		case 0:   // initialize
		{
			break;
		}
		case 1:   // update
		{
			for (var index = 0; index < mPlayFieldDivs.length; index++)
			{
				if ( (index < mTileXYCount) && (mPlayField[index] > 0) )
				{
					mPlayFieldDivs[index].transform.LerpChangeTile(mPlayFieldDivs[index].newLeft, mPlayFieldDivs[index].newTop, 1, mTileSize2, mTileSize2, 1);
					mPlayFieldDivs[index].visualState = 2;
				}
				else
				{
					mPlayFieldDivs[index].visualState = 3;
				}
			}
			break;
		}
		case 2:   // terminate
		{
			for (var index = 0; index < mPlayFieldDivs.length; index++)
			{
				if ( (index < mTileXYCount) && (mPlayField[index] > 0) )
				{
					mPlayFieldDivs[index].transform.LerpChangeTile(mPlayFieldDivs[index].newLeft, mPlayFieldDivs[index].newTop, 1);
					mPlayFieldDivs[index].visualState = 2;
				}
				else
				{
					mPlayFieldDivs[index].visualState = 3;
				}
			}
		}
	}	
}

function WorldResetUpdate()
{
	// ONLY CALLED when Level being Generated
	// CANNOT BE CALLED if Level so complex/thick a solution can't be found (we exhaust PushPopped)
	// Will discard a level it cannot find 1+ solutions for. Does NOT exit until 1 solution found.
	// Levels loaded from JSON should NEVER call this UNLESS they're being fixed. Trust that their data is right.
	
	var w = parseInt(window.innerWidth), h = parseInt(window.innerHeight);
	var min = w; if (h < min) { min = h; }

	mWorldResetUpdateCount++;
	if ((mWorldResetUpdateCount == 50) && ((mMusic.currentTime == 0) || (mMusic.talkIndex == -1))) { MusicSelect(); }   // start playing the trumpet
	BackgroundUpdate();

	// 2024-09-25 these assert were removeed. if level is loaded from JSON, LevelFileIntoMemory (called beore this) will fill out mSolvedPlayfieldTurn
	// console.assert( (mWorldResetUpdateCount > 1) || ((mWorldResetUpdateCount == 1) && (mSolvedPlayfieldTurn[0] == 100000)), "WorldResetUpdate() Error: Not initialized properly. mTileTotalRemember:" + mTileTotalRemember + " mSolvedPlayfieldTurn[0]:" + mSolvedPlayfieldTurn[0]);
	// console.assert( (mWorldResetUpdateCount > 1) || ((mWorldResetUpdateCount == 1) && (mSolvedPlayfieldTurn[1] == -1)), "WorldResetUpdate() Error: Not initialized properly. mTileTotalRemember:" + mTileTotalRemember + " mSolvedPlayfieldTurn[1]:" + mSolvedPlayfieldTurn[1]);

	// EXTRA tiles have NOT been added, so no need to disable and enable them here.
	var hold = 50; if (mLevelGenerate != null) { hold = 1000; }
	if (mState != 1) { mState = SolveUpdate(hold); }   // SolveUpdateStart was called before launching this (in WorldReset)
	
	if ((mWorldResetUpdateCount % 50) == 5)
	{
		WorldPlayFieldResize();
		WorldResetUpdateTiles(0);
		WorldResetUpdateTiles(1);
	}
	WordUpdate();   // does WordPosition	
	
	// <DRAW>
	{
		// Shrink Tiles Away
		// HACK: Core Tile info is changing, but Visual Tile info isn't. Shrink away tiles successfully touched
		var tile = null, tileT = null;
		for (var xyIndex = 0; xyIndex < mPlayFieldDivs.length; xyIndex++)
		{
			tile = mPlayFieldDivs[xyIndex]; tileT = tile.transform;
			if (tile.visualState == 3)
			{
				if (tileT.jimWidth < 2)
				{
					if (tileT.jimLeft > -1000)
					{
						tileT.LerpChangeTile(-1000, -1000, 1, 1, 1, 1);
					}
				}
				else
				{
					tileT.LerpChangeTile(tileT.jimLeft, tileT.jimTop, 0.05, 1, 1, 0.025);
				}
			}
		}

		mCanvasMain.style.opacity = 0.5;
		mCanvasMainContext.clearRect(0, 0, mCanvasMain.width, mCanvasMain.height);		
		let holdInt = -1;
		let holdColorRFinal = -1;
		let holdColorGFinal = -1;
		let holdColorBFinal = -1;
		for (var xyIndex = 0; xyIndex < mPlayFieldDivs.length; xyIndex++)
		{
			tile = mPlayFieldDivs[xyIndex];
			if (tile.visualState > 1)
			{
				tileT = tile.transform;

				holdColorRFinal = tile.colorRFinal;
				holdColorGFinal = tile.colorGFinal;
				holdColorBFinal = tile.colorBFinal;			
				if (tile.colorTempTime > 0)
				{
					if (mWorldFrameCounter > tile.colorTempTime)
					// if (Date.now() > tile.colorTempTime)
					{
						tile.colorTempTime = 0;
					}
					else			
					{
						holdColorRFinal = tile.colorRTemp;
						holdColorGFinal = tile.colorGTemp;
						holdColorBFinal = tile.colorBTemp;		
					}
				}

				// 2 key decisions (tested)
				// . uses mWorldFrameCounter and NOT Date.now() + deltaTime (drastic colour changes are NEVER good, even if it's proper)
				// . linear (not exponential) ascend and descend towards the colour (matched original CSS timer delay, drastic colour changes are NEVER good)
				const speed = 9;   // slowly fade in and out (not too flashy, but enough to reach within 400 milliseconds)

				if (tile.colorR != holdColorRFinal)
				{
					if (tile.colorR < holdColorRFinal)
					{
						tile.colorR += speed; if (tile.colorR > holdColorRFinal) { tile.colorR = holdColorRFinal; }
					}
					else
					{
						tile.colorR -= speed; if (tile.colorR < holdColorRFinal) { tile.colorR = holdColorRFinal; }
					}
				}

				if (tile.colorG != holdColorGFinal)
				{
					if (tile.colorG < holdColorGFinal)
					{
						tile.colorG += speed; if (tile.colorG > holdColorGFinal) { tile.colorG = holdColorGFinal; }
					}
					else
					{
						tile.colorG -= speed; if (tile.colorG < holdColorGFinal) { tile.colorG = holdColorGFinal; }
					}
				}

				if (tile.colorB != holdColorBFinal)
				{
					if (tile.colorB < holdColorBFinal)
					{
						tile.colorB += speed; if (tile.colorB > holdColorBFinal) { tile.colorB = holdColorBFinal; }
					}
					else
					{
						tile.colorB -= speed; if (tile.colorB < holdColorBFinal) { tile.colorB = holdColorBFinal; }
					}
				}

				// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas
				// https://web.dev/articles/canvas-performance
				mCanvasMainContext.beginPath();

				// ellipse applies to BOTH stroke and fill, doing one for each requires sepearte BeginPath likely defeating the purpose
				// ellipse strokes / fills from center. subpixels were happending (border overlap aliasing) regardless of parseInt, so removed
				mCanvasMainContext.ellipse(
					tileT.jimLeft
					, tileT.jimTop
					, tileT.jimWidth * 0.5
					, tileT.jimHeight * 0.5
					, 0, 0, 2 * Math.PI
				);

				let holdLineWidth = tileT.jimWidth * 0.1;
				if (holdLineWidth < 1) { holdLineWidth = 1; }
				mCanvasMainContext.lineWidth = holdLineWidth;
				mCanvasMainContext.stroke();

				mCanvasMainContext.fillStyle = "rgb(" + parseInt(tile.colorR) + "," + parseInt(tile.colorG) + "," + parseInt(tile.colorB) + ")";
				mCanvasMainContext.fill();   // overlaps half the stroke. fixes for that overdraw required more computation and BeginPath removal
			}
		}
	}
	// </DRAW>		

	RestartUpdate();	

	mPlayer.Draw();
	
	// console.log("SOLVEUPDATE " + mTileXCount + ":" + mTileYCount + ":" + mTileTotal + " " + mPlayer.left + ":" + mPlayer.top + " " + mState + " " + mSolveUpdateCount + " " + mWorldType); 
	if ( ((Date.now() - mSolveStart) > 150.0 * 1000.0) && (mLevelGenerate == null) ) { mState = 1; }   // Give up after 2.5 minutes (60 + 60 + 30), WorldReset will choose guaranteed Snake

	if (mUrineState == 1)
	{
		if (mState == 0)
		{
			window.setTimeout(WorldResetUpdate, 15);
		}
		else if (mState == 2)
		{
			window.setTimeout(WorldReset, 15, false);   // might switch mUrineState = 2
		}
		else
		{
			// mState == 1. Level CANNOT be finished! BUT is it too obvious?
			/*
			console.log(
				"FAIL! " + mStatePushPopped + ":" + mSolveUpdateCount + ":" + SolveExaminePlayfield(mPlayer.left, mPlayer.top)
				+ " AStar:" + AStarTotal(mPlayer.top * mTileXCount + mPlayer.left, mPlayField) + ":" + mTileTotal
			);
			*/
			// Usually we don't want failed levels (because they can't be solved), BUT if it's urine KEEP IT!
			if (
				(!mStatePushPopped)
				&& ( (mSolveUpdateCount > 1) || (mLevelGenerate != null) )
				&& (SolveExaminePlayfield(mPlayer.left, mPlayer.top) > 1)
				&& (AStarTotal(mPlayer.top * mTileXCount + mPlayer.left, mPlayField) == mTileTotal)
				&& (!AStarPlayerBridgePoint())
			)
			{
				// the above criteria is somewhat duplicated (but better safe than sorry)
				// need to ensure broken level is not OBVIOUSLY broken (2 edges, tile islands, player a bridge point)
				mState = 2; // oh the LIES! (mSolutions STILL 0)	
				WorldResetFinish();
			}
			else
			{
				window.setTimeout(WorldReset, 15, false);
			}
		}
	}
	else if (mState == 1)
	{
		// Original idea was to procedurally generate the next level WHILE player played.
		// Took to long so this was abanonded. Still used to generate small levels when Total < 21 (but this needs to be removed)
		
		// Fail (even after 50 tries!)
		// Although there may be a possible path (pushpopped), for all intents and purposes we've failed.
		// We would need a larger memory consuming ipad crashing array to explore more.
		mSolveStatAttempt++;
		if (mLevelGenerate == "fix") { console.log("mState = 1 while trying to fix " + mLevelIndex); }
		WorldReset(false);   // keep trying the SAME WorldType, WorldMirror, WorldExtreme and mTileXCount * mTileYCount 				
	}
	else if
	(
		(mSolutions == 0)
		|| ( (mState == 0) && (mLevelGenerate != null) )
	)
	{
		// Keep trying using the SAME level
		// Eventually SolveUpdate will produce 1+ solutions (mState == 0 or 2), OR Fail (mState == 1)
		// Player CANNOT start level until ONE solution has been found
		// Earlier code will change level to a "guaranteed solved level" (Snake) if player is waiting more than 2 minutes
		// If levels are being generated, 1 solution is NOT enough. NEED them all (mState == 2) for least/most answers
		window.setTimeout(WorldResetUpdate, 15);
	}	
	else
	{	
		// mState == 0 OR 2. We have 1 solution (or more), and more possibilities might still need to be calculated
		// 0 - we have 1 solution, but we need to calculate more while the player moves
		// 2 - we have ALL solutions. stop calculating
		// WorldResetFinish lets the player start playing WHILE it finishes
		// (the player can move ruining the least/most answer)
		console.assert(
			( (mSolvedPlayfieldTurn[0] < 100000) && (mSolvedPlayfieldTurn[1] > -1) )
			, "WorldResetUpdate() Error: We have a solution '" + mSolutions + "', BUT mSolvedPlayfieldTurn[] has NOT been filled out '" + mSolvedPlayfieldTurn[0] + "':'" + mSolvedPlayfieldTurn[1] + "'" 
		);
		WorldResetFinish();
	}
}

function FinishTileAdd(pXYIndex, pSound = true)
{
	if (mTalkStates[TalkType.finishTile] > 0)
	{
		console.assert(mPlayField[pXYIndex] > 0, "FinishTileAdd() Error: Trying to make an empty spot '" + pXYIndex + "' final.");
		console.assert(mPlayFieldDivs[pXYIndex].finalTile == 1, "FinishTileAdd() Error: Tile '" + pXYIndex + "' NOT a finalTile (.finalTile = 0)");
		console.assert(mPlayFieldDivs[pXYIndex].finishTileState == 0, "FinishTileAdd() Error: Tile '" + pXYIndex + "' HAS .finishTileState > 0");
		console.assert(mPlayFieldDivs[pXYIndex].extra == 0, "FinishTileAdd() Error: Tile '" + pXYIndex + "' is EXTRA?!");

		let tile = null;

		let count = 0;
		for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
		{
			if (mPlayFieldDivs[xyIndex].finishTileState > 0) { count++; }
		}							
		
		// .finishTile=1   one tile. must end on this tile and CANNOT touch it enroute
		if (mTalkStates[TalkType.finishTile] == 1)
		{
			if (count == 0)
			{
				console.assert((mFinishxyIndex == -1), "FinishTileAdd() Error: mFinishxyIndex already set! '" + mFinishxyIndex + "'");
				mFinishxyIndex = pXYIndex;
				tile = mPlayFieldDivs[pXYIndex];
			}
		}
		
		// /finishTile=2   multiple tiles. must end on one of these and CAN eliminate enroute
		else
		{
			if (count < 4) { tile = mPlayFieldDivs[pXYIndex]; }
		}
		
		if (tile != null)
		{
			let tile = mPlayFieldDivs[pXYIndex];
			tile.finishTileState = 1;
			tile.transform.jimWidth = mTileSize * 10;
			tile.transform.jimHeight = mTileSize * 10;
			if (pSound) { SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundfinishtile1); }
		}
	}
}

function FinishTileRemoveAll()
{
	// we do NOT touch .finalTile because that's STILL needed for stats/trivia, and NOT related to TalkType.finishTile
	if (mTalkStates[TalkType.finishTile] > 0)
	{
		mFinishxyIndex = -1;

		let success = false;
		for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
		{
			var tile = mPlayFieldDivs[xyIndex];
			if (tile.finishTileState != 0)
			{
				console.assert((mPlayField[xyIndex] > 0), "FinishTileRemoveAll() Error: Turning off FinishTileState BUT mPlayField['" + xyIndex + "'] == 0");
				console.assert((mPlayFieldDivs[xyIndex].finalTile > 0), "FinishTileRemoveAll() Error: Turning off FinishTileState BUT mPlayFieldDivs['" + xyIndex + "'].finalTile == 0");
				success = true;
				tile.finishTileState = 0;
				TileSetColor(tile, 0, 0, 0);
			}
		}
		if (success) { SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundfinishtile2); }
	}	
}

function WorldResetFinish()
{
	/*
	At this point, we have a VALID level to play. 2 Types of VALID:
	1. We found 1+ solutions (mSolutions > 0), therefore Level CAN be solved.
       While playing (even before moving), SolveUpdate will finish finding MORE solutions, answers and Final Tiles

	2. A solution exists BUT can't be calculated (too complex) (mSolutions == 0) - Totally playable BUT no Answers (no pink solution), no Final tile.
       While playing (even before moving), SolveUpdate will fruitlessly pursue and fail to find MORE solutions, answers and Final Tiles
	   (mStatePushPopped will be hit)
	   
	mState can be 0 (1+ solutions, still finding more) or 2 (1+ solutions, done finding more even if more exist), assuming NOT 1
	If Level is loaded in from JSON, all of that info has been transferred into mPlayfield including .finalTile.
	This method is unaware whether it received a dynamically generated level or a level from JSON (and it doesn't care)
	*/
	
	console.assert(mSolveUpdateCount > 0, "WorldResetFinish Error: SolveUpdateStart NOT called before reaching her. mSolveUpdateCount == 0");

	console.assert(mState != 1, "WorldResetFinish Error: We received a failed playfield. Fine for urine but otherwise. mState == 1");

	console.assert
	(
		((mState == 0) && (mSolutions >= 0))
		|| ((mState == 2) && (mSolutions > 0))
		|| ((mState == 2) && (mSolutions == 0) && (mUrineState == 1))
		, "WorldResetFinish() Error: The combo of State '" + mState + "' or Solution '" + mSolutions + "' is wrong."
	);

	// Unlike playing the game, all possibilities MUST be exhausted before we continue
	// Remember: If WorldReset is struggling to create a level, it will give up and use Snake which is guaranteed to produce 2 
	// Note: We have may have maxed out the array (mStatePushPopped = true), so there may be more solutions. But we don't care at this point. As long as we have 1+ that's FINE (anything after 1 is just information to the player)
	console.assert
	(
		(mLevelGenerate == null)
		|| ((mLevelGenerate != null) && (mState == 2))
		, "WorldResetFinish() Error: Generating levels BUT Finish() called and Level NOT COMPLETELY built mState !=2 '" + mState + "'"
	);

	console.assert(
		((mTileXMax == 23) && (mTileYMax == 23))
		, "WorldResetFinish Error: mTileXMax x mTileYMax NOT 23x23 '" + mTileXMax + "x" + mTileYMax + "'\n"
		  + "For crap legacy reasons, generators change mTileXMax x mTileYMax but they're supposed to return them back (need to change this)"
	);
	
	/*
	// Debug
	while (mState == 0)
	{
		mState = SolveUpdate(2000);
	}
	*/
	
	CurtainRefresh(2);	
	WorldPlayFieldResize();	
	TilesWhite();
	mCanvasMain.style.opacity = 1;

	mTileTotalRemember = mTileTotal;   // Must be set BEFORE TILEEXTRA. SolveUpdate uses to determine whether a solution was for a FULL playfield or partial
	// Remember tiles for repeating level. Extra tiles will be added to Remember (making it out-of-sync with mTileTotalRemember)
	for (var index = 0; index < mTileXYCount; index++) { mPlayFieldRemember[index] = mPlayField[index]; }
	mRememberPlayerXYIndex = mPlayer.xyIndex;
	
	if (configMouseDisable) { try { document.body.requestPointerLock( {unadjustedMovement: true} ); } catch { } }
	ButtonChangeState(1);
	mButtonCloseDiv.style.display = "";

	// <FINALTILE>
	// Each answer contains one finalTile - set it (SolveUpdate would find this eventually)
	// Note: SolveUpdate is might have already set this finalTile, and SolveUpdate is STILL setting finalTiles
	if (!((mSolvedPlayfieldTurn[0] == 100000) && (mSolvedPlayfieldTurn[1] == -1)))
	{
		for (let answer = 0; answer < 2; answer++)
		{
			for (let xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
			{
				if (mSolvedPlayfield[answer][xyIndex] == 1)
				{
					mPlayFieldDivs[xyIndex].finalTile = 1;
				}
			}
		}
	}
	// </FINALTILE>

	// <TILEEXTRA>
	// we have a lovely perfect mPlayfield, let's add some extra tiles (VERY slow process)
	// Consider adding (!mStatePushPopped == true), although I've seen Extras addedd to levels with this?!?!
	// if there are a TON of solutions then it's a very dense level with lots of possibilities - it will take too long to determine failure, and adding extra tiles to a mass of tiles isn't very fun (hard to deduce)
	if ((mLevelGenerate != null) && ((mLevelGenerate == "fix") || (mLevelGenerate[3])) && (mSolutions < 200000))
	{
		// Talk item in 5th column happens BEFORE gameplay starts, so tiles can be rebuilt if needed.
		mTalkStates[TalkType.tileExtra] = 10;
	
		mState = 0;   // was formerly 2. SolveUpdateStart rightfully complains if it's not at 0.
		let preserveSolutions = mSolutions;
		// WorldResetIncrease(1);   // add padding where extra tiles can appear - needed for small levels BUT increases complexity so abandoned.
		// Extra tiles are NOT on.
		var extraCount = TalkTypeExtraGenerateStart();   // attempts to add tile. does NOT touch mTileTotal. Adds tiles to mPlayField BUT with .extra caveat (so SolveUpdate doesn't count them)
		// WorldResetShift();   // mTileXCount and mTileYCount include ALL the Extra tiles added (whether they're showing or not). If we don't apply all the extra Tiles, LevelFileIntoMemory removes extra rows/columns			
		mSolutions = preserveSolutions;
		mState = 2;
		mSolveUpdateCount = 0;
	}
	// </TILEEXTRA>
	
	if (mUrineState != 0) { console.log("mUrineState == " + mUrineState);	}

	let holdErrorMessage = WorldCheck();
	if (holdErrorMessage != "") { alert("WorldResetFinish WorldCheck Error\n" + holdErrorMessage); }
	LevelMemoryIntoFile();
	
	if (mLevelGenerate == "fix")
	{
		mWeekdayLevelsRemaining--;   // level is fixed, this moves to the next one.
		window.setTimeout(WorldResetNew, 15, true); return;
	}	
	else if (mLevelGenerate != null)
	{
		// good
		mLevelGenerateCount++;
		if (mLevelGenerateCount < 40) { window.setTimeout(WorldReset, 15, true); return; } else { console.log("LevelGenerate " + mLevelGenerateCount + " DONE!"); } 
	}	
	
	mPlayer.Reset();
	mWorldState = 1;
		
	mPlayer.rotateS = -45;
	
	for (var index = 0; index < mMilestoneRollers.length; index++)
	{
		mMilestoneRollers[index].xyIndex = -1;
		mMilestoneRollers[index].speed = -1;
		mMilestoneRollers[index].speedCount = -1;
		mMilestoneRollers[index].colorR = -1;
		mMilestoneRollers[index].colorG = -1;
		mMilestoneRollers[index].colorB = -1;
	}

	WorldResetUpdateTiles(2);
	mPlayback.Reset();
	mRestart.transform.LerpChange(mRestart.newLeft, mRestart.newTop, 1, 1, 1, 1);

	mStatNewFailRemember = mStatNewFail;
	mStatNewFrankWinRemember = mStatNewFrankWin;
	mStatNewFrankLossRemember = mStatNewFrankLoss;

	// <TALK>
	// Does this Talk have a talk? If no talks are playing (indexof("talk"), and we've waited long enough (mTalkLastDate), go 4 it!
	if (mWorldMode == 0)
	{
		if (
			(mMusic.talkIndex == -1)
			&& (mTalkLastDate == 0)
			&& (mTalkIndex < mTalk3000Index)
			&& (mTalks[mTalkIndex][2] != null)
			&& (mTalks[mTalkIndex][2] != "")
		)
		{
			TalkPlay1(mTalkIndex);
		}
	}
	MusicSelect();   // Only plays if no talking
	// </TALK>

	// <MESSAGE>
	// player has been waiting for level generation, and the title has dissapeared. give them another one
	var freezeTime = 1000;
	if (mWorldMode == 1)
	{
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundpop);

		var innerHTML = "LEVEL<BR>" + (mLevels.length - mWeekdayLevelsRemaining + 1).toLocaleString() + " OF " + mLevels.length.toLocaleString();
		// innerHTML += "<BR>" + Object.keys(WorldType).find(key => WorldType[key] === mLevels[mLevelIndex][0]);
		// if (mLevels[mLevelIndex][2] > 0) { innerHTML += " Extreme" + mLevels[mLevelIndex][2]; }
		WordShow(innerHTML, undefined, undefined, 2, -1);
	}
	else
	{
		var total = mStatNewFrankLoss + mStatNewFrankWin + 1;

		if (mWorldLevelCount == 0)
		{
			WordShow("SOUND<BR>REQUIRED", "#FFFF00", "#FF0000", 1.5, 2000 + 1500);
		}
		
		else if (total == 20)
		{
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundletthegamebegin);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
			WordShow("LET THE<BR>GAME<BR>BEGIN", "#FFFF00", "#FF0000", 1.2, 2000 + 1500);	
		}
		
		else if (mUrineState != 0)
		{
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
			WordShow("LEVEL " + total.toLocaleString() + "<BR>SOMEONE PEED<BR>IN THIS POOL", "#000000", "#FF0000", 1.5, 2000 + 1500);
		}
		
		else if (mLevelType == LevelType.OneHundred)
		{
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.sound100hundred);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
			WordShow(total.toLocaleString(), "#FFFFFF", "#00FF00", 1, 2000 + 1500, 0.03);
			freezeTime = 2000;
		} 
		else if (mLevelType == LevelType.MileStone)
		{
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundmilestone);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);	
			WordShow("MILE<BR>STONE", "#00FFFA", "#FF00FF", 1, 2000 + 1500, 0.03);
			freezeTime = 2000;
		} 
		else if (mLevelType == LevelType.Boss)
		{
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundboss);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);		
			WordShow("BO<BR>SS", "#FFFFFF", "#000066", 1, 2000 + 1500, 0.015);
			freezeTime = 2000;
		}
		else if (mLevelType == LevelType.Bonus)	
		{
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundbonus);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);		
			WordShow("BON<BR>US", "#00FFFA", "#660066", 1, 2000 + 1500, 0.015);
			freezeTime = 2000;
		}
		else if (mLevelType == LevelType.Tricky)
		{
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundpop);
			WordShow("tricky", undefined, undefined, 0.75);
		}
		else if (total < 20)
		{
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundpop);
			WordShow("LEVEL " + total.toLocaleString() + "<BR>GO", undefined, undefined, 0.5);	
		}
		else
		{
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundpop);

			var innerHTML = "LEVEL " + total.toLocaleString();
			var r = Math.random();
			if (r < 0.33)
			{
				innerHTML += "<BR>GO!";
			}
			else if (r < 0.66)
			{
				innerHTML += "<BR>YUP!";
			}
			else
			{
				innerHTML += "<BR>WHY NOT!?";	
			}
			WordShow(innerHTML, undefined, undefined, 1.2, 2000 + 1500);	
		}
	}
	mWorldFreezeTime = Date.now() + freezeTime;	
	// </MESSAGE>

	mSpots.Finish(mPlayFieldDivs[mPlayer.xyIndex].newLeft, mPlayFieldDivs[mPlayer.xyIndex].newTop);

	if (mUrineState != 0) { mRestart.div.style.backgroundColor = "#0000FF"; }

	// <TALKSTATES>
	TalkTypeLightSet(mTalkStates[TalkType.light]);
	TalkTypeControlSet(mTalkStates[TalkType.control]);
	TalkTypeFailSet(mTalkStates[TalkType.fail], false);
	TalkTypeInvisibleSet(mTalkStates[TalkType.tileInvisible], true);
	TalkTypeRandomFailSet();
	TalkTypeFinishTileSet(mTalkStates[TalkType.finishTile], true);
	TalkTypeConcreteBlockSet(mTalkStates[TalkType.concreteBlock]);
	TalkTypeExtraSet(mTalkStates[TalkType.tileExtra], true);
	// Extra Tiles are ON at this point.
	// </TALKSTATES>

	RestartAttach();   // safe to find a spot tht's NOT an extra tile. will drill through concrete (if necessary) to make hole
	StatTopLeftRefresh();
	
	// SolveUpdate may or may not have finished. Regardless like to start with a needless SolveUpdate so level arrives blinking (pretty)
	// While this destroys the solution count, we've preserved it in mSolutionsFileRemember
	mState = 0;
	mSolveUpdateCount = 0;	
	mSolveUpdateDate = 0;   // don't wait to launch SolveUpdateStart
	WorldUpdate();   // Start the BIG LOOP
	
	if (mUseTheForceStateWait > 0) { mUseTheForceStateWait--; }

	if (mWorldMode == 0)
	{
		// if level was picked from the file (and not dymacially generated), don't pick it again
		if (mLevelIndex > -1)
		{
			// reset all the Levels we tried to use but failed (maybe next time)
			for (var index = 0; index < mLevels.length; index++) { if (mLevels[index][3] == 2) { mLevels[index][3] = 0; } }
			mLevels[mLevelIndex][3] = 1;   // don't use this level again. 2024-used to permanently save this
		}
	}
	
	if (mLevelIndex == 0) { GoogleAnalytics("Start"); }
	GoogleAnalytics("Level" + mLevelIndex);
}

function StatTopLeftRefresh()
{
	// Level 1 of 10
	// Attempt 2
	// 3 invisible tiles

	mStatTopLeftDiv.innerHTML = "";
	if (mWorldMode > 0)
	{
		mStatTopLeftDiv.innerHTML += mUserData.weekday[mWorldDayOfWeek][mWorldEvening].captionLong;
		// Moon clearly indicated evening (trying to avoid too much text)
		// if (configPaid > 0) { mStatTopLeftDiv.innerHTML += (mWorldEvening) ? " Evening" : " Daytime"; }
		mStatTopLeftDiv.innerHTML += "<BR>" + (mLevelIndex + 1) + " of " + mLevels.length;
	}
	else
	{
		mStatTopLeftDiv.innerHTML += "Frank's Story";
		if (mLevelType == LevelType.Bonus) { mStatTopLeftDiv.innerHTML += "<BR>BONUS!"; }
		else if (mLevelType == LevelType.Boss) { mStatTopLeftDiv.innerHTML += "<BR>BOSS!"; }
		else if (mLevelType == LevelType.MileStone) { mStatTopLeftDiv.innerHTML += "<BR>MILESTONE!"; }
		else if (mLevelType == LevelType.OneHundred) { mStatTopLeftDiv.innerHTML += "<BR>CENTENNIAL!"; }
		else { mStatTopLeftDiv.innerHTML += "<BR>Level " + (mStatNewFrankWin + mStatNewFrankLoss + 1);	}
	}

	if (mWorldRepeatCount > 0) { mStatTopLeftDiv.innerHTML += "<BR>Attempt " + (mWorldRepeatCount + 1); }

	if (mTalkStates[TalkType.tileInvisible] > 0)
	{
		let invisibleCount = 0;
		for (let xyIndex = 0; xyIndex < mTileXYCount; xyIndex++) { if (mPlayFieldDivs[xyIndex].visiblePermanent != 1) { invisibleCount++; } }
		if (invisibleCount > 1)
		{
			mStatTopLeftDiv.innerHTML += "<BR>" + invisibleCount + " Invisible Tiles";
		}
		else
		{
			mStatTopLeftDiv.innerHTML += "<BR>1 Invisible Tile";
		}
	}
	if (mTalkStates[TalkType.tileExtra] > 0)
	{
		let extraCount = 0;
		for (let xyIndex = 0; xyIndex < mTileXYCount; xyIndex++) { if (mPlayFieldDivs[xyIndex].extra != 0) { extraCount++; } }
		if (extraCount > 1)
		{
			mStatTopLeftDiv.innerHTML += "<BR>" + extraCount + " Extra Tiles";
		}
		else
		{
			mStatTopLeftDiv.innerHTML += "<BR>1 Extra Tile";
		}
	}
	if (mTalkStates[TalkType.randomFail] > 0) { mStatTopLeftDiv.innerHTML += "<BR>Fail's Broken"; }
	if (mTalkStates[TalkType.finishTile] > 0) { mStatTopLeftDiv.innerHTML += "<BR>1 Final Tile"; }

	if (mUseTheForceState == 1)
	{ mStatTopLeftDiv.innerHTML += "<BR>Duplicate Past Success"; }	
	else if (mUseTheForceState == 2)
	{ mStatTopLeftDiv.innerHTML += "<BR>Use The Force"; }
	
	if (mLevelType == LevelType.Boss)
	{
		if (mLevelStageCount == 2)
		{ mStatTopLeftDiv.innerHTML += "<BR>Repeat That EXACTLY"; }	
		else if (mLevelStageCount == 1)
		{ mStatTopLeftDiv.innerHTML += "<BR>Reverse IT"; }	
	}	
}


function LevelName2(levelIndex)
{
	return ""
		+ levelIndex + ":" + mLevels[levelIndex].length + ":" 
		+ Object.keys(WorldType)[mLevels[levelIndex][0]] + "," + mLevels[levelIndex][1] + "," + mLevels[levelIndex][2]
		+ "," + mLevels[levelIndex][5] + "," + mLevels[levelIndex][6]
		+ "," + mLevels[levelIndex][7] + "," + mLevels[levelIndex][8]
		+ "," + mLevels[levelIndex][mLevels[levelIndex].length - 1]
		+ "";
}

window.onload = function()
{	
	// Called ONCE. Setup minimum required to show shrinking Title, then continue full slow setup in OnLoad2
	// Consider launching more HTTP requests here to cache things while title shrinks

	backgroundR = 0; backgroundG = 0; backgroundB = 0;	
	document.body.style.backgroundColor = RGBToHex(backgroundR, backgroundG, backgroundB);	

	mWorldDiv = document.getElementById("WorldContainer");

	mCanvasMain = document.getElementById("CanvasMain");
	mCanvasMainContext = mCanvasMain.getContext("2d");

	mButtonCloseDiv = document.getElementById("ButtonClose");

	// <SOUND>
	// We cannot FULLY setup sound here (must be done in response to click).
	// Locally cache all the sound effects
	if (window.AudioContext) { mAudioContext = new window.AudioContext(); } else { mAudioContext = new window.webkitAudioContext(); }
	mSoundBuffers = new Array(8);
	mSoundBufferState = 0;
	SoundBufferFillStart();   // starts with THANKS
	// Remember: No sound until user clicks...
	// </SOUND>

	// <CONTROLS>
	// can't call / link to methods of an object. Maybe AddEventListener can?
	document.addEventListener('touchstart', (pEvent) => { return gBrowser.OnTouchStart(pEvent); });
	document.addEventListener('touchmove', (pEvent) => { return gBrowser.OnTouchMove(pEvent); });
	document.addEventListener('touchend', (pEvent) => { return gBrowser.OnTouchEnd(pEvent); });

	document.addEventListener('mousedown', Browser_OnMouseDown);
	document.addEventListener('mousemove', Browser_OnMouseMove);
	document.addEventListener('mouseup', Browser_OnMouseUp);
	
	document.addEventListener('keydown', (pEvent) => { return gBrowser.OnKeyDown(pEvent); });
	// short for document.addEventListener('keydown', function(pEvent) { gBrowser.OnKeyDown(pEvent); } );
	document.addEventListener('keyup', (pEvent) => { return gBrowser.OnKeyUp(pEvent); });
	// http://unixpapa.com/js/mouse.html // doubleclick causes a mouseup followed by doubleclick (not mousedown)
	// 	"If you don't have any other compelling reason to prefer one event over another, it's probably generally best to attach your event handlers to mouseup."
	// </CONTROLS>

	// <WORD SETUP>
	// needed here for Title Display
	mWord = document.createElement("div");
	mWord.style.cssText = "touch-action:none; position:absolute; z-index:20; left:0px; top:0px; white-space:nowrap; text-align:center; color:#FFFFFF;";
	mWord.shakeRatio = 0;
	mWord.shakeRatioAngleOld = 0;
	mWord.fontRatio = 1.0;
	mWord.textShadowColor = "#000000";
	mWord.aliveRemember = 0;
	mWord.screenWidth = -1;    // preserve width (static variable)
	mWord.screenHeight = -1;   // preserve height (static variable)
	mWord.fontSizeMain = -1;   // preserve font size (static variable)
	mWord.tileTotal = 0;   // background word starts counting down
	mWord.jimOpacity = 1;
	mWord.jimOpacityFinal = 0;	
	mWord.jimColor = "#FFFFFF";
	document.body.appendChild(mWord);
	// </WORD SETUP>

	mWordCurtain = document.createElement("div");
	mWordCurtain.style.cssText = "touch-action:none; position:absolute; left:0px; top:0px; white-space:nowrap; text-align:center; background: url('') repeat;";
	document.body.appendChild(mWordCurtain);

	mWordCurtainImage = document.createElement("div");
	mWordCurtainImage.style.cssText = "touch-action:none; position:absolute; left:0px; top:0px;";
	document.body.appendChild(mWordCurtainImage);

	WorldResizeUpdate();   // calls WorldResize(1) AND starts polling for the Resize change (supplments bug)

	CurtainRefresh(2);
	WordShow("YOU <SPAN Style='color:#FFFFFFFF;'>CAN</SPAN><BR>ALWAYS<BR><SPAN Style='color:#FFFFFFFF;'>GO</SPAN> BACK", undefined, undefined, 2, -1);
	mWorldUpdateTitleRunning = 1;
	WorldUpdateTitle();   // mini WordUpdate, no depedencies and shrinks

	mWorldClick = OnLoad2;
}

function OnLoad2MusicSetup()
{
	// Ideally we'd have ONE OnLoad that does OnLoad, OnLoad2 and OnLoad2MusicSetup
	// BUT you're not allowed to initialize music in OnLoad, so we split this up

	// https://stackoverflow.com/questions/30482887/playing-a-simple-sound-with-web-audio-api
	// https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
	// https://stackoverflow.com/questions/5194898/html5-audio-multiple-play/35459153#35459153
	// https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Using_Web_Audio_API
	// https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/createGain		
	
	// for iPhone Safari, MUST play mMusic ONCE in response to click ("do something")
	// 1. Enables mMusic to play ANY audio (can't .play() the Audio tags, BUT can use their SRC)
	// 2. Enables Web Audio. Since it's mixed with a REGULAR Audio tag (mMusic), Web Audio uses this iPhone approved Channel		
	if (mAudioContext.state === 'suspended') { mAudioContext.resume(); }

	// https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createMediaElementSource
	// can't control volume on iPhone UNLESS you reroute it through Web Audio.
	// "As a consequence of calling createMediaElementSource(),
	//  audio playback from the HTMLMediaElement will be re-routed into the processing graph of the AudioContext.
	//  So playing/pausing the media can still be done through the media element API and the player controls."

	mMusic = new Audio();   // HTMLAudioElement (DOM) inherits from HTMLMediaElement (.play)
	// https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement
	mMusic.talkIndex = -1;
	mMusic.talkJSON = "";
	mMusic.talkJSONIndex = -1;	
			
	mMusic.onended = function()
	{
		// mMusic.addEventListener('ended', MusicOnEnded);   // works! this.talkIndex == 1

		// https://www.javascripttutorial.net/javascript-bind/
		// let f = person.getName.bind(person);
		// First, bind the person.getName method to the person object.
		// let f = MusicOnEnded.bind(mMusic);
		// mMusic.addEventListener('ended', f);

		if (this.talkIndex == -1)
		{
			// If player hasn't finished Bonus/MileStone/One Hundred by the time music ends, they've failed.
			if ( (this.src.indexOf("music-song") != -1) && ((mLevelType == LevelType.Bonus) || (mLevelType == LevelType.MileStone) || (mLevelType == LevelType.OneHundred) || (mLevelType == LevelType.Boss)) ) { mGrowDie = true; }
		}
		else
		{
			// Talk Or Interjection ends
			console.log("Talk Ended! " + this.talkIndex + ":" + this.src);
			if (this.talkIndex >= mTalk3000Index) { TalkStop3000(); } else { TalkStop1(); }
			MusicSelect();
		}
	}
	
	mMusic.ontimeupdate = function()
	{
		// ONLY applies to Talks (not Music or Interjections)
		if ( (this.talkIndex > -1) && (this.talkIndex < mTalk3000Index) && (this.talkJSONIndex > -1) )
		{
			while ((this.talkJSONIndex < this.talkJSON.length) && (this.currentTime >= this.talkJSON[this.talkJSONIndex].time))
			{
				// console.log("HEY:" + this.talkJSON[this.talkJSONIndex].time + " " + this.talkJSON[this.talkJSONIndex].type1 + " " + this.talkJSON[this.talkJSONIndex].type2);
				switch (this.talkJSON[this.talkJSONIndex].type1)
				{
					case TalkType.light:
					{
						TalkTypeLightSet(this.talkJSON[this.talkJSONIndex].type2);
						break;
					}
					case TalkType.control:
					{
						TalkTypeControlSet(this.talkJSON[this.talkJSONIndex].type2);
						break;
					}
					case TalkType.fail:
					{
						TalkTypeFailSet(this.talkJSON[this.talkJSONIndex].type2);
						break;
					}							
					case TalkType.tileInvisible:
					{
						TalkTypeInvisibleSet(this.talkJSON[this.talkJSONIndex].type2);   // adds it to mTalkStates
						break;
					}
					case TalkType.tileExtra:
					{
						console.assert(this.talkJSON[this.talkJSONIndex].type2 == 0, "TalkPlay3000() - Attempted to add a tile WHILE TALKING. Currently NOT supported. Can only REMOVE.");
						// Extra tiles can be turned off while talking. They cannot be currently be turned on while talking (mTilesRemember not updated, likely other issues)
						TalkTypeExtraSet(this.talkJSON[this.talkJSONIndex].type2);
						break;
					}
					case TalkType.finishTile:
					{
						TalkTypeFinishTileSet(this.talkJSON[this.talkJSONIndex].type2);
						break;
					}
					case TalkType.concreteBlock:
					{
						TalkTypeConcreteBlockSet(this.talkJSON[this.talkJSONIndex].type2);
						break;
					}
					default:
					{
						console.assert(1 == 0, "TalkPlay3000() - Unhandled this.talkJSON[this.talkJSONIndex].type1:" + this.talkJSON[this.talkJSONIndex].type1);							
					}
				}
				
				this.talkJSONIndex++;
			}
		}
	}
	
	mMusicSource = mAudioContext.createMediaElementSource(mMusic);
	mMusicGain = mAudioContext.createGain();
	mMusicSource.connect(mMusicGain);
	mMusicGain.connect(mAudioContext.destination);
}

function OnLoad2(pEvent)
{
	// Called ONCE - AFTER an interaction so Audio/Sound can be intialized
	OnLoad2MusicSetup();

	mPlayer = new Player();

	// <RESTART>
	mRestart = {};
	mRestart.div = document.createElement("div");
	mRestart.div.style.cssText = "position:absolute; z-index:2; left:-1000px; top:-1000px; width:10px; height:10px; background:#000000; border:0px solid black; border-radius:100px; box-shadow:4px 4px #FFFFFF; pointer-events:none; touch-action:none;";	
	mWorldDiv.appendChild(mRestart.div);
	mRestart.transform = new Transform(mRestart.div);
	// </RESTART>
			
	mStatTopLeftDiv	= document.getElementById("StatTopLeftDiv");
	mStatTopRightDiv = document.getElementById("StatTopRightDiv");
	mStatBottomLeftDiv	= document.getElementById("StatBottomLeftDiv");
	mStatBottomRightDiv = document.getElementById("StatBottomRightDiv");

	/*
	var holdErrorMessage = "";
	var counter = 0;
	var hold0 = -1, hold1 = -1, hold2 = -1;   // debug
	
	for (var levelIndex = 0; levelIndex < mLevels.length; levelIndex++)
	{
		hold0 = mLevels[levelIndex][0];
		hold1 = mLevels[levelIndex][1];
		hold2 = mLevels[levelIndex][2];
		
		if (hold1 != 0)
		{
			console.log("!!! " + levelIndex + ":" + Object.keys(WorldType)[mLevels[mLevelIndex][0]]);
		}
	}
	console.log("DONE! " + counter);
	return;
	*/

	// one of three ways got us here, remove the other two
	mWorldUpdateTitleRunning = 0;   // stop timer that causes Title to fly in
	
	mPlayback = new Playback();
	mPlayback.Load();

	mSpots = new Spots();
	mSpots.Load();
		
	document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
	document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
	document.addEventListener('pointerlockchange', lockChangeAlert, false);
	document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
	
	// playfield will NEVER be larger than 20 x 20 (can be smaller, but do NOT resize array)
	mPlayField = new Array(mTileXMax * mTileYMax);
	mPlayFieldDivs = new Array(mPlayField.length);
	mPlayFieldRemember = new Array(mPlayField.length);
	
	for (var index = 0; index < mPlayField.length; index++)
	{
		mPlayField[index] = 0;		
		mPlayFieldDivs[index] = new Tile();
		mPlayFieldDivs[index].index = index;
	}
	
	mAStarPlayField = new Array(mPlayField.length);	
	mAStarxyIndexes = new Array(mPlayField.length * 4);
	
	mPlayFieldExtraPreserve = new Array(mPlayField.length);   // Used to preserve Extra state.

	mLevelGenerate = null;
	var levelGenerate = urlParams.get('levelgenerate');
	if (levelGenerate == "fix")
	{
		mLevelGenerate = "fix";
	}
	else if (levelGenerate != null)
	{
		// levelgenerate=2,false,0 = Snake, not extreme, not urine
		// levelgenerate=10,true,0 = Spiral, extreme, not urine
		// levelgenerate=12,true,1 = DenseMold, extreme, urine that CANNOT be solved - there is NO NEED to generate solvable urine (those are just regular levels coloured yellow)
		if (mStatNewFrankWin + mStatNewFrankLoss + 1 < 21) { mStatNewFrankWin = 21; mStatNewFrankLoss = 1; }
		mLevelGenerate = levelGenerate.split(",");
		console.assert(mLevelGenerate.length >= 2, "WorldReset() Error: levelgenerate URL parameter must contain 2 elements i.e. 2,false '" + levelGenerate + "'");
		if (mLevelGenerate[2] == null) { mLevelGenerate[2] = 0; }

		// Generate Extra spots
		if (mLevelGenerate.length < 4) { mLevelGenerate[3] = true; } else { mLevelGenerate[3] = (mLevelGenerate[3] === "true"); }
		const now = new Date();
		console.log("Generating New " + mLevelGenerate[0] + ":" + Object.keys(WorldType)[mLevelGenerate[0]] + " " + now.toLocaleString());
	}
	
	if (mLevelGenerate != null)
	{
		mSolveCrazyPlayFields = new Array(1300000);
		// mSolveCrazyPlayFields = new Array(1750000);   // works BUT takes forever to determine failure, especially important during Extra
		// in order to prove level is impossible, must exhaust every tile possibility. the higher this array the more possibilities that can be explored
		// (the drawback is it can take a looooong time to prove this)
		// dense/thick levels with lots of clumped together tiles will quickly exhaust this array, causing mStatePushPopped == true
		// we're going to find a solution for this puzzle, even if it takes 4GB of RAM
		// more crashes Chrome even on desktop (last tested 2024-09-12) 
		// we STILL fill this, so easy to have so many possibilities
	}
	else
	{
		mSolveCrazyPlayFields = new Array(5000);   // changed 2024-09-04. used to be 60000 - needlessly kills iPhone battery
		// while playing SolveUpdate uses 5000 to determine 100% fail. Ambiguous for huge playfields, great once player reduces them
		// also allows levels to be procedurally generated while playing (between levels) but we need to stop this POST HASTE
		// mSolveCrazyPlayFields = new Array(60000);   // needed for initial playfield generation
		// every move it checks a max of 60000+ paths then gives up trying to see if you failed
	}

	// 2022 Stats
	//  80,000 GOOD (crashes original iPad SOMETIMES - crashes my iPhone on complex levels)
	// 100,000 enough for 9x9 no holes (all puzzles MUST be solvable without popping). My iPhone Web App reset :(
	// 200,000 works and likely generates more complex possibilities that would be rejected
	// 1,000,000 / 1,500,000 WORKS on Em's Superman. 2,000,000 crashes Superman
	for (var index = 0; index < mSolveCrazyPlayFields.length; index++)
	{
		mSolveCrazyPlayFields[index] = new Array(mTileXMax * mTileYMax);
	}
	
	mHistoryxyIndexes = new Array(mSolveCrazyPlayFields.length);
	mHistoryCounts = new Array(mSolveCrazyPlayFields.length);
	mHistoryTurns = new Array(mSolveCrazyPlayFields.length);

	mSolvedPlayfield = new Array(2);
	mSolvedPlayfield[0] = new Array(mTileXMax * mTileYMax);
	mSolvedPlayfield[1] = new Array(mTileXMax * mTileYMax);
	mSolvedPlayfieldTurn = new Array(2);
	mSolvedPlayfieldTurn[0] = 0;
	mSolvedPlayfieldTurn[1] = 0;	

	mSensitivity = document.createElement("div");
	mSensitivity.style.cssText = "position:absolute; display:none; z-index:10; left:0px; top:0px; width:100px; height:10px; background:#6666FF; border:1px solid white; pointer-events:none; touch-action:none;";
	mSensitivity.exponent = 2.5; if (getCookie("SensitivityExponent") != "") { mSensitivity.exponent = parseFloat(getCookie("SensitivityExponent")); }
	mSensitivity.alive = 0;
	mWorldDiv.appendChild(mSensitivity);
		
	WorldCountersLoad();
	
	mMilestoneRollers = new Array(20);
	for (var index = 0; index < mMilestoneRollers.length; index++)
	{
		mMilestoneRollers[index] = new Object();
		mMilestoneRollers[index].xyIndex = -1;
		mMilestoneRollers[index].colorR = -1;
		mMilestoneRollers[index].colorG = -1;
		mMilestoneRollers[index].colorB = -1;		
		mMilestoneRollers[index].speed = -1;
		mMilestoneRollers[index].speedCount = -1;
		mMilestoneRollers[index].dir = -1;
	}

	// Even though Daily Mantra doesn't use this, need Talks initialized for switching between "The Tale of Frank" and Daily
	Talk3000Load();

	mWorldWidth = -1; mWorldHeight = -1;
	WorldResize(1);

	/*
	// ----------------------------------------------- debug
	// prove levels in array are good (LevelFileIntoMemory and LevelMemoryIntoFile produce errors if not)
	if (false)
	{
		for (var levelIndex = 0; levelIndex < mLevels.length; levelIndex++)
		{
			var holdErrorMessage = LevelFileIntoMemory(levelIndex);
			if (holdErrorMessage != "")
			{
				console.error(holdErrorMessage);
				counter++;
			}
			else if (
				(SolveExaminePlayfield(mPlayer.left, mPlayer.top) > 0)
				&& (AStarTotal(mPlayer.xyIndex, mPlayField) == mTileTotal)
				&& (!AStarPlayerBridgePoint())
			)
			{
				LevelMemoryIntoFile();
			}
			else
			{
				console.error("LevelIndex:Error:" + levelIndex + " is BROKEN.");			
			}
		}
		return;
	}	
	// ----------------------------------------------- debug
	*/

	mUserData.LoadAllDays();
	mStatNewFrankWin = 0;
	if (getCookie("StatWin") != "") { mStatNewFrankWin = parseInt(getCookie("StatWin")); }
	mStatNewFrankLoss = 0;
	if (getCookie("StatLoss") != "") { mStatNewFrankLoss = parseInt(getCookie("StatLoss")); }		

	// Even if we start with "The Tale Of Frank", need to pull in WeekDay for Stats menu option
	// (player can view weekday stats while playing "The Tale Of Frank")
	// could also do this in Stats, unsure which is worse
	let holdDayEvening = GetDayEvening();
	
	if (
		(urlParams.get("talkindex") != null)
		|| (urlParams.get("worldtype") != null)
		|| ((urlParams.get("levelgenerate") != null) && (urlParams.get("levelgenerate") != "fix"))
	)
	{
		// Narrative (original): The Tale of Frank
		MenuMainRestart(null, 0, holdDayEvening[0], holdDayEvening[1]);
	}
	else
	{
		// Immediately start with Day Of Week (no menu)
		MenuMainRestart(null, 1, holdDayEvening[0], holdDayEvening[1]);
	}
	
	if (pEvent) { pEvent.preventDefault(); pEvent.stopPropagation(); return false; }
}

function WorldUpdateTitle(pTimeStamp)
{
	if (mWorldUpdateTitleRunning == 1)
	{
		BackgroundUpdate();
		WordUpdate();
		window.setTimeout(WorldUpdateTitle, 15);		
	}
}

function FormatTime(pSeconds, pBreak = "")
{
	// we're actually passed a count of 1/60th seconds	
	let minutes = 0;
	if (pSeconds >= 60 * 60)
	{
		minutes = parseInt(pSeconds / (60.0 * 60.0));
		pSeconds -= minutes * (60 * 60);
	}
	
	let seconds = parseInt(pSeconds / 60.0);
	pSeconds -= seconds * 60;

	let hold = (pSeconds < 10) ? "0" + pSeconds : pSeconds;
	let fractionHTML = "<SPAN Style='font-size:40%; line-height:100%;'>" + hold + "/60</SPAN>";

	if (pBreak != "")
	{		
		// very wide, not good for list of Days in Phone Portrait mode!
		if (minutes > 0)
		{
			return minutes + "m<BR>" + "00".substr(1, 2 - (seconds + "").length) + seconds + "s" + fractionHTML;
		}
		else
		{
			return seconds + "s" + fractionHTML;
		}	
	}
	else
	{
		if (minutes > 0)
		{
			return minutes + "m" + "00".substr(1, 2 - (seconds + "").length) + seconds + "s" + fractionHTML;
		}
		else
		{
			return seconds + "s" + fractionHTML;
		}	
	}	
}



// ---------------------------------------------------------------------------------------------------------------------
// <WORLDEND>
// ---------------------------------------------------------------------------------------------------------------------
/*
RULES
-----
. WorldEndLevelNew/WorldEndLevelRepeat do NOT touch Lose/Win because they don't know enough to make the call.
  i.e. Repeat MIGHT make Lose increase, but it MIGHT not
. Flow is controlled by WorldUpdate and NOT WorldEndLevelNew/WorldEndLevelRepeat. i.e. WorldReset is called by WorldUpdate
*/
function WorldEndStatUpdate(pState)
{
	if (mWorldMode > 0) { return; }

	// Only called ONCE per Level
	console.assert((pState > 0) && (pState < 4));
	console.assert((pState == 3) || (mScoreUpdated == 0), "Error: WorldEndStatUpdate() updated TWICE in the SAME level!");
	
	switch (pState)
	{
		case 1:
		{
			console.assert(mScoreUpdated != 2, "Error: WorldEndStatUpdate() - Recorded a loss, BUT now recording a win?!");
			if (mScoreUpdated == 0)
			{
				// Win!
				WorldCountersSave();
				mStatNewFrankWin++; setCookie("StatWin", mStatNewFrankWin);			
				mScoreUpdated = 1;
			}
			break;
		}
		case 2:
		{
			console.assert(mScoreUpdated != 1, "Error: WorldEndStatUpdate() - Recorded a win, BUT now recording a loss?!");
			if (mScoreUpdated == 0)
			{
				// Lose!
				WorldCountersSave();
				mStatNewFrankLoss++; setCookie("StatLoss", mStatNewFrankLoss);
				mScoreUpdated = 2;
			}
			break;
		}
		case 3:
		{
			// Reset
			mStatNewFrankWin = mStatNewFrankWinRemember;
			mStatNewFrankLoss = mStatNewFrankLossRemember;

			setCookie("StatWin", mStatNewFrankWin);
			setCookie("StatLoss", mStatNewFrankLoss);
			
			mScoreUpdated = 0;
			break;
		}	
	}
	
	mStatBottomLeftDiv.innerHTML = "Losses:" + mStatNewFrankLoss.toLocaleString();
	mStatBottomRightDiv.innerHTML = "Wins:" + mStatNewFrankWin.toLocaleString();
}


function WorldMessageNew()
{
	console.assert(!mGrowDie, "WorldMessageNew() Error - mGrowDie true, should NOT be calling this!");
	console.assert(mUseTheForceState == 0, "WorldMessageNew() Error - mUseTheForceState != 0, should NOT be calling this!");
	console.assert(mUrineState == 0, "WorldMessageNew() Error - mUrineState != 0, should NOT be calling this!");
	console.assert(mLevelType != LevelType.Boss, "WorldMessageNew() Error - LevelType.Boss is NOT handled here.");

	console.log(
		"mStatePushPopped:" + mStatePushPopped
		+ "  mSolutions:" + mSolutions
		+ "  mTileTotalRemember:" + mTileTotalRemember
		+ "  mSolvedPlayfieldTurn[0]:" + mSolvedPlayfieldTurn[0]
		+ "  mSolvedPlayfieldTurn[1]:" + mSolvedPlayfieldTurn[1]
		+ "  mPlayer.turns:" + mPlayer.turns
	);

	if (mTalkRandomFailState > 0)
	{
		let innerHTML = (mTalkStates[TalkType.randomFail] == 1)
			? "HOW<SPAN Style='color:#FFFFFF;'>!?</SPAN>"
			: "<SPAN Style='color:#FFFFFF;'>FAIL'S</SPAN><BR>BROKEN";
		WordShow(innerHTML, "#FFFFFF", "#FF0000", 1.5, 4000);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		SoundBufferPlay(mSoundBufferMisc, 0.1, SoundBufferMiscType.soundcow);
		TalkPlay3000(TalkType2.failfinished);
	}
	else if (mTalkStates[TalkType.turns] > 0)
	{
		// ( (mTalkStates[TalkType.turns] == 1) && (mTileTotal <= 1) && (mPlayer.turns > mSolvedPlayfieldTurn[0]) )
		// || ( (mTalkStates[TalkType.turns] == 2) && (mTileTotal <= 1) && (mPlayer.turns < mSolvedPlayfieldTurn[1]) )
	
		if (mTalkStates[TalkType.turns] == 2)
		{
			if (mPlayer.turns > mSolvedPlayfieldTurn[1])
			{
				// assuming this isn't a 993 level, player should NEVER be able to do more moves than mSolvedPlayfieldTurn[1]
				// if they pull this off, it's a bug in the level and we'll CELEBRATE because really it's harmless and the player is a freaking genius
				WordShow("MORE<BR>THAN<BR>MOST" + mPlayer.turns + "!", "#FF00FF", "#660066", 1, 2000 + 1500, 0.02);
			}
			else
			{
				WordShow("MOSTED<BR>" + mPlayer.turns + "!", "#FFFFFF", "#00FFFF", 1, 2000 + 1500, 0.015);
			}
		}
		else
		{
			if (mPlayer.turns < mSolvedPlayfieldTurn[0])
			{
				// assuming this isn't a 993 level, player should NEVER be able to do less moves than mSolvedPlayfieldTurn[0]
				// if they pull this off, it's a bug in the level and we'll CELEBRATE because really it's harmless and the player is a freaking genius
				WordShow("LESS<BR>THAN<BR>LEAST" + mPlayer.turns + "!", "#FF00FF", "#660066", 1, 2000 + 1500, 0.02);
			}
			else
			{
				WordShow("LEASTED<BR>" + mPlayer.turns + "!", "#FFFFFF", "#00FFFF", 1, 2000 + 1500, 0.015);
			}
		}
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		SoundBufferPlay(mSoundBufferMisc, 0.25, SoundBufferMiscType.soundapplausenormal);
	}
	else if ( (mLevelType == LevelType.OneHundred) && (mWorldRepeatCount == 0) )
	{
		WordShow((mStatNewFrankLoss + mStatNewFrankWin + 100).toLocaleString() + "?", "#FFFFFF", "#0000FF", 1.2, 2000 + 1500, 0.03);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.sound100hundreded);
		SoundBufferPlay(mSoundBufferMisc, 0.5, SoundBufferMiscType.soundapplausescream);
		TalkPlay3000(TalkType2.completed50);
	}
	else if ( (mLevelType == LevelType.MileStone) && (mWorldRepeatCount == 0) )
	{
		WordShow("MILE<BR>STONED", "#FFFF00", "#0000FF", 1.2, 2000 + 1500, 0.03);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundmilestoned);
		SoundBufferPlay(mSoundBufferMisc, 0.5, SoundBufferMiscType.soundapplausescream);
	}
	/*
	else if ( (mLevelType == LevelType.Boss) && (mWorldRepeatCount == 0) )
	{
		WordShow("BOS<BR>SED", "#FFFF00", "#0000FF", 1.2, 2000 + 1500, 0.015);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundbossed);
		SoundBufferPlay(mSoundBufferMisc, 0.25, SoundBufferMiscType.soundapplausenormal);
	}
	*/
	else if ( (mLevelType == LevelType.Bonus) && (mWorldRepeatCount == 0) )
	{
		WordShow("BON<BR>USSED", "#FFFF00", "#0000FF", 1.2, 2000 + 1500, 0.015);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundbonussed);
		SoundBufferPlay(mSoundBufferMisc, 0.25, SoundBufferMiscType.soundapplausenormal);
	}
	else if ( (mTalkStates[TalkType.finishTile] == 1) && (mPlayFieldDivs[mPlayer.xyIndex].finishTileState == 1) )
	{
		WordShow("BULLS<BR>EYE", undefined, undefined, 1, 2000 + 1500, 0.015);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);	
	}	
	else if ( (!mStatePushPopped) && (mSolutions > 1) && (mTileTotalRemember > 30) && (mSolvedPlayfieldTurn[0] != mSolvedPlayfieldTurn[1]) && (mPlayer.turns == mSolvedPlayfieldTurn[0]) )
	{
		// LEAST TURNS!
		WordShow("SLICK!", undefined, undefined, 1.5, 2000 + 1500, 0.015);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		const outstandings = [SoundBufferMiscType.soundoutstanding1, SoundBufferMiscType.soundoutstanding2, SoundBufferMiscType.soundoutstanding3, SoundBufferMiscType.soundoutstanding4];
		SoundBufferPlay(mSoundBufferMisc, 1, outstandings[parseInt(Math.random() * outstandings.length)]);
		SoundBufferPlay(mSoundBufferMisc, 0.25, SoundBufferMiscType.soundapplausenormal);
	}
	else if ( (!mStatePushPopped) && (mSolutions > 1) && (mTileTotalRemember > 30) && (mSolvedPlayfieldTurn[0] != mSolvedPlayfieldTurn[1]) && (mPlayer.turns == mSolvedPlayfieldTurn[1]) )
	{
		// MOST TURNS!
		WordShow("you are... <BR>the worst.", undefined, undefined, 1.5, 2000 + 1500, 0.015);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		const outstandings = [SoundBufferMiscType.soundoutstanding1, SoundBufferMiscType.soundoutstanding2, SoundBufferMiscType.soundoutstanding3, SoundBufferMiscType.soundoutstanding4];
		SoundBufferPlay(mSoundBufferMisc, 1, outstandings[parseInt(Math.random() * outstandings.length)]);
		SoundBufferPlay(mSoundBufferMisc, 0.25, SoundBufferMiscType.soundapplausenormal);
	}
	else if (mWorldRepeatCount == 0)
	{
		WordShow("OUT<BR>STAND<BR>ING", undefined, undefined, 1, 2000 + 1500, 0.015);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		const outstandings = [SoundBufferMiscType.soundoutstanding1, SoundBufferMiscType.soundoutstanding2, SoundBufferMiscType.soundoutstanding3, SoundBufferMiscType.soundoutstanding4];
		SoundBufferPlay(mSoundBufferMisc, 1, outstandings[parseInt(Math.random() * outstandings.length)]);
		SoundBufferPlay(mSoundBufferMisc, 0.25, SoundBufferMiscType.soundapplausenormal);
	}
	else if (mWorldRepeatCount == 1)
	{
		WordShow("CONGRAT<BR>ULATIONS", undefined, undefined, 1, 2000 + 1500, 0.01);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		const congratulations = [SoundBufferMiscType.soundcongratulations1, SoundBufferMiscType.soundcongratulations2];
		SoundBufferPlay(mSoundBufferMisc, 1, congratulations[parseInt(Math.random() * congratulations.length)]);
		SoundBufferPlay(mSoundBufferMisc, 0.1, SoundBufferMiscType.soundapplausenormal);
	}
	else if (mWorldRepeatCount == 2)
	{
		WordShow("congratulations", undefined, undefined, 1, 2000 + 1500, 0.005);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundcongratulationsconfused);
		SoundBufferPlay(mSoundBufferMisc, 0.05, SoundBufferMiscType.soundapplausenormal);
	}
	else if (mWorldRepeatCount < 7)
	{
		WordShow("DIGNITY<BR>RETAINED", undefined, undefined, 0.9, 2000 + 1500);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.sounddignityretained);
		SoundBufferPlay(mSoundBufferMisc, 0.5, SoundBufferMiscType.soundapplauseweak);
	}
	else
	{
		WordShow((mWorldRepeatCount + 1) + " TRIES?<BR>SAD.", undefined, undefined, 0.9, 2000 + 1500, 0.001);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundapplauseweak);
	}
}


function WorldMessageRepeat()
{
	console.assert(mUseTheForceState == 0, "WorldMessageRepeat() Error - mUseTheForceState != 0, should NOT be calling this!");
	console.assert(mUrineState == 0, "WorldMessageRepeat() Error - mUrineState != 0, should NOT be calling this!");

	if (mWorldRepeatCount == 2)
	{
		WordShow("ALL THE<BR>MARBLES", undefined, undefined, 2, 3000);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
	}	
	else if (mWorldRepeatCount == 3)
	{
		WordShow("THE HOLE<BR>ARRIVES", undefined, undefined, 1, 2000);   // the hole is upon us
	}
	else
	{
		var innerHTML = "";
		switch (mWorldRepeatCount)
		{
		case 0: { innerHTML = "ATTEMPT<BR>" + (mWorldRepeatCount + 1); break; }
		case 1: { innerHTML = "ATTEMPT<BR>" + (mWorldRepeatCount + 1); break; }
		case 2: { innerHTML = "ATTEMPT<BR>" + (mWorldRepeatCount + 1); break; }
		// case 3: { innerHTML = "CONSIDER<BR>THE HOLE"; break; }
		// no hole for you
		// you are above the hole
		// no country for old hole
		// we should fill that hole in
		// there's a hole, but not in your heart
		// there is always a choice, what is right and the hole
		case 4: { innerHTML = "I LIKE<BR>YOUR STYLE."; break; }
		case 5: { innerHTML = "DON'T GIVE<BR>UP!"; break; }
		case 6: { innerHTML = "YOU GOT<BR>THIS!"; break; }
		case 7: { innerHTML = "I BELIEVE<BR>IN YOU!"; break; }
		case 8: { innerHTML = "YOU ARE<BR>THE BEST!"; break; }
		case 9: { innerHTML = "TENTH'S<BR>THE CHARM!"; break; }
		
		case 10: { innerHTML = "ELEVEN<BR>IS THE ONE ONE!"; break; }
		case 11: { innerHTML = "FINISH THIS<BR>DIRTY DOZEN!"; break; }
		case 12: { innerHTML = "LUCKY<BR>THIRTEEN!"; break; }
		case 13: { innerHTML = "FOURTEEN?<BR>WHY NOT!"; break; }
		case 14: { innerHTML = "OBSCENE<BR>FIFTEEN!"; break; }
		case 15: { innerHTML = "give<BR>up."; break; }
		case 16: { innerHTML = "seriously,<BR>it's over."; break; }
		case 17: { innerHTML = "that ship has<BR>sailed."; break; }
		case 18: { innerHTML = "the sun<BR>has set."; break; }
		case 19: { innerHTML = "TWENTY?!<BR>absurd"; break; }

		case 20: { innerHTML = "something is wrong<BR>with you"; break; }
		case 21: { innerHTML = "i'm very<BR>worried"; break; }
		case 22: { innerHTML = "this can't<BR>continue"; break; }
		case 23: { innerHTML = "you have a<BR>problem"; break; }
		case 24: { innerHTML = "you need to<BR>stop"; break; }
		case 25: { innerHTML = "go outside,<BR>get some air"; break; }
		case 26: { innerHTML = "meet somebody ...<BR>anybody"; break; }
		case 27: { innerHTML = "have some<BR>kids"; break; }
		case 28: { innerHTML = "quit wasting<BR>your life"; break; }
		case 29: { innerHTML = "THIRTY<BR>GOOD GOD THIRTY"; break; }

		case 30: { innerHTML = "your heart<BR>still beats"; break; }
		case 31: { innerHTML = "you're still<BR>alive"; break; }
		case 32: { innerHTML = "there's still<BR>time"; break; }
		case 33: { innerHTML = "you can always<BR>go back"; break; }
		case 34: { innerHTML = "back to before<BR>you started playing"; break; }
		case 35: { innerHTML = "back to<BR>a simper time"; break; }
		case 36: { innerHTML = "when mom made<BR>pancakes"; break; }
		case 37: { innerHTML = "remember<BR>pancakes?"; break; }
		case 38: { innerHTML = "remember ...<BR>love?"; break; }
		case 39: { innerHTML = "FORTY<BR>THIS HURTS."; break; }

		case 40: { innerHTML = "unending<BR>darkness"; break; }
		case 41: { innerHTML = "endless<BR>screaming"; break; }
		case 42: { innerHTML = "unanswered<BR>cries"; break; }
		case 43: { innerHTML = "infinite<BR>emptiness"; break; }
		case 44: { innerHTML = "eternal<BR>pain"; break; }
		case 45: { innerHTML = "absolute<BR>melancholy"; break; }
		case 46: { innerHTML = "everlasting<BR>sorrow"; break; }
		case 47: { innerHTML = "unquenchable<BR>thirst"; break; }				
		case 48: { innerHTML = "please<BR>end this"; break; }
		case 49: { innerHTML = "FIFTY<BR>HOLY CRAP<BR>FIFTY"; break; }

		case 50: { innerHTML = "it's<BR>OVER."; break; }				
		case 51: { innerHTML = "it's long,<BR>long, over."; break; }
		case 52: { innerHTML = "it's time<BR>to start over"; break; }
		case 53: { innerHTML = "get in<BR>the hole"; break; }
		case 54: { innerHTML = "only the hole<BR>understands you"; break; }
		case 55: { innerHTML = "only the hole<BR>can save you"; break; }
		case 56: { innerHTML = "the hole<BR>is an angel"; break; }
		case 57: { innerHTML = "the hole<BR>was sent<BR>by god"; break; }
		case 58: { innerHTML = "the hole<BR>loves you"; break; }
		case 59: { innerHTML = "get in<BR>the hole"; break; }

		default: { innerHTML = "GET IN THE<BR>" + "F*CKING ".repeat(mWorldRepeatCount - 26) + "<BR>HOLE!!!"; break; }
		}

		WordShow(innerHTML, undefined, undefined, 0.75, 1000);
		SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundblah)
	}
}

function WorldEndNew()
{
	// Happens IMMEDIATELY when you COMPLETE or FAIL COMPLETELY
	// BEFORE player starts flying towards camera

	console.assert(mState != 0, "WorldEndNew() Error: mState == 0, must be 1 (fail) or 2 (success) before calling.");
	// Level is complete - either FAILED or SUCCESS (mState determines that). Player flies towards camera for 2 seconds.
	// WorldUpdate() examines mWorldState, and after 2 seconds either repeats the level OR creates a new one
	if (mWeekdayLevelsRemaining > 1) { MusicStop();	}
	TilesWhite();
	gBrowser.KeyReset();
	
	// some variations (urinestate == 1 fail 3 times) leave tiles behind, making it hard to read. so remove those tiles
	for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
	{
		if (mPlayField[xyIndex] != 0)
		{
			mPlayField[xyIndex] = 0;
			mPlayFieldDivs[xyIndex].visualState = 3;
		}
	}
	
	if (mState != 1) { mPlayer.FaceChange(3); }
	mPlayer.transform.jimWidth = mTileSize * 0.4;
	mPlayer.transform.jimHeight = mTileSize * 0.4;
	mPlayer.Draw();

	// Remove Tile player is ON (keep in sync with Player.Update())
	if (mPlayer.xyIndex != mRestart.xyIndexRemember)
	{
		mPlayField[mPlayer.xyIndex] = 0;
		mPlayFieldDivs[mPlayer.xyIndex].visualState = 3;
	}
	
	let tile = null;
	for (let xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
	{	
		tile = mPlayFieldDivs[xyIndex];
		if (tile.concreteBlock != 0)
		{
			tile.concreteBlock = 0;
			tile.transform.jimWidth = mTileSize2 * 2;
			tile.transform.jimHeight = mTileSize2 * 2;
			TileSetColor(tile, 255, 255, 0, 0);   // INSANT change to yellow (since they're fading away)
		}
		else if (tile.extra > 0)
		{
			mPlayField[xyIndex] = 0;
			tile.extra = 0;
			tile.transform.jimWidth = mTileSize2 * 2;
			tile.transform.jimHeight = mTileSize2 * 2;
			TileSetColor(tile, 255, 255, 0, 0);   // INSANT change to yellow (since they're fading away)
		}
	}
	
	// mState set by caller
	mWorldState = 2;
	mWorldState2Action = 2;
	mWorldStateAlive = Date.now() + 2000;   // 2 seconds of flying towards camera
}


function WorldEndHole()
{
	TalkStop3000();
	MusicStop();
	TilesWhite();
	mPlayback.Reset();
	
	// sink into the hole
	for (var index = 0; index < mTileXYCount; index++)
	{
		if (mPlayField[index] > 0)
		{
			mPlayField[index] = 0;
			mPlayFieldDivs[index].visualState = 4;
		}
	}
	mTileTotal = 0;

	mPlayer.rotateS = 20;
	mPlayer.transform.jimWidth = mTileSize * 1;
	mPlayer.transform.jimHeight = mTileSize * 1;
	mPlayer.colorR = 0; mPlayer.colorG = 250; mPlayer.colorB = 0;
	mPlayer.transform.jimRotate = 0; 	
	RotateDiv(mPlayer.div, mPlayer.transform.jimRotate);
	mPlayer.Draw();
	mPlayer.Reset();

	mRestart.penalty++;
	// setCookie("RestartPenalty", mRestart.penalty, 365 * 20);	
	SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundhole);

	mState = 1;
	mWorldState = 2;
	mWorldState2Action = 2;
	mWorldStateAlive = Date.now() + 5000;
	// mRestart.penalty * 3000;   // originally I was going to have the hole take longer and longer BUT it just feels like the game/computer hung
	// with more work an increasing penalty (permaentnly saved to disk) would be incredible - the penalty for those who keep using the hole
}


function WorldLevelReset()
{	
	// WorldResetFinish() and this should perhaps be the same
	gBrowser.KeyReset();
	
	// mWorldState STAYS at 1

	// Note: mPlayFieldRemember contains extra tiles, TileTotal does NOT
	mTileTotal = mTileTotalRemember;
	for (var index = 0; index < mTileXYCount; index++) { mPlayField[index] = mPlayFieldRemember[index]; }	

	TalkTypeRandomFailSet();   // Prep next failure

	// Extra Tiles get revealed on 6th attempt (mercy), colouring taken care of by TilesWhite
	if ((mTalkStates[TalkType.tileExtra] > 0) && (mWorldRepeatCount == 6)) { TalkPlay3000(TalkType2.addedtilered); }	

	if ((mWorldMode > 0) && (mUseTheForceState == 0)) { mStatNewFail++; }
	mState = 0;
	mSolveUpdateCount = 0;	

	if ( (mScoreUpdated == 0) || (mLevelType == LevelType.Boss) ) { MusicSelect(); }

	mPlayer.rotateS = 45;
	mPlayer.colorR = 255; mPlayer.colorG = 255; mPlayer.colorB = 0;
	mPlayer.transform.jimRotate = 360 * 2; 	
	RotateDiv(mPlayer.div, mPlayer.transform.jimRotate);
	
	mPlayer.top = parseInt(mRememberPlayerXYIndex / mTileXCount);
	mPlayer.left = mRememberPlayerXYIndex - (mPlayer.top * mTileXCount);
	mPlayer.xyIndex = mRememberPlayerXYIndex;
	mPlayer.Reset();
	mWorldFreezeTime = Date.now() + 750;
	mSpots.Finish(mPlayFieldDivs[mPlayer.xyIndex].newLeft, mPlayFieldDivs[mPlayer.xyIndex].newTop);	

	TilesWhite();
	StatTopLeftRefresh();
}

function WorldUpdateFailStuck(pFail)
{
	// Fail and Stuck can have the EXACT same result
	// Otherwise, pFail:True lets player wander UNTIL they get stuck
	// Should Urine or UseTheForce really call this? Love the idea of relocating ALL WordShow/Text here
	console.assert(mState != -1, "WorldUpdateFailStuck() Error: We're called BUT mState == -1 (fail)");

	MusicStop();

	// <URINESTATE END FAILURE1>
	if (mUrineState > 0)
	{
		console.assert(!pFail, "WorldUpdateFailStuck() Error: mUrineState == " + mUrineState + ", BUT FAIL HAPPENED?!");
		// mState might be 1 because of FAKE URINE FAIL
		if (mWorldRepeatCount >= 2)
		{
			if (mUrineState == 1)
			{
				WordShow("FAIL!<BR>IMPOSSIBLE!", "#FFFFFF", "#000000", 1, 4000, 0.02);
				SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
				mState = 1;
				WorldEndNew();
			}
			else if (mUrineState == 2)
			{
				// Level CAN be beaten, but player took more than 3 attempts.
				WordShow("FAIL!<BR>TOTALLY POSSIBLE!<BR>PROVE IT<BR>YOURSELF!", "#FFFFFF", "#000000", 1, 4000, 0.03);
				SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);

				// if (mScoreUpdated == 0) { WorldEndStatUpdate(2); }					
				// mPlayback.Reset();   // history from Urine is INVALID, don't want these kept around
				mUrineState = -1;   // a reminder this started as a urine level
				mWorldState = 2;
				mWorldState2Action = 3;
				mWorldStateAlive = Date.now() + 2000;
			}
		}
		else
		{
			WordShow("THIS >MIGHT< BE<BR>IMPOSSIBLE!", "#000000", "#FF0000", 1.5, 4000);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
			mState = 1;
			mWorldState = 2;
			mWorldState2Action = 3;
			mWorldStateAlive = Date.now() + 2000;
		}
	}
	// </URINESTATE END FAILURE>

	// <USETHEFORCE FAILURE>
	else if (mUseTheForceState > 0)
	{
		console.assert(!pFail, "WorldUpdateFailStuck() Error: mUseTheForceState = " + mUseTheForceState + ", BUT FAIL HAPPENED?!");
		if (mUseTheForceState == 1)
		{
			WordShow("NOPE!", "#0000FF", "#FFFF00", 1, 4000, 0.02);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		}
		else
		{
			WordShow("DISAPPOINTED<BR>I AM", "#00FF00", "#00FF00", 1.5, 4000);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
		}
		WorldEndStatUpdate(3);   // May have WON (recorded), but now FAILED (so reset)
		mState = 1;
		WorldEndNew();
	}
	// </USETHEFORCE FAILURE>
	
	// <BONUS FAILURE>
	else if ( 
		(mLevelType == LevelType.OneHundred)
		|| (mLevelType == LevelType.MileStone)
		|| (mLevelType == LevelType.Bonus)
		|| ( (mLevelType == LevelType.Boss) && (mScoreUpdated == 0) && (mWorldRepeatCount >= 2) )
	)
	{	
		// SolveUpdate still in use (just hidden). Fail or Stuck could have happened.
		TalkStop3000(0);   // Stop current intejected talk WITHOUT a gap afterward, so I can interrupt with ANOTHER interjected talk lamenting how the song finished early
		MusicStop();

		if (mLevelType == LevelType.Boss)
		{
			WordShow("BYE", "#FFFFFF", "#000000", 1, 1000, 0.03);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundbonusbye);
			if (mMusic.currentTime < 70) { TalkPlay3000(TalkType2.songendedearly); }		
		}
		if (mLevelType == LevelType.OneHundred)
		{
			WordShow("NOOOOO!", "#FFFFFF", "#000000", 1, 7000, 0.03);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.sound100hundredno);
		}
		else if (mLevelType == LevelType.MileStone)
		{
			WordShow("BE<BR>GONE!", "#FFFFFF", "#000000", 1, 7000, 0.03);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundmilestonebegone);
			if (mMusic.currentTime < 70) { TalkPlay3000(TalkType2.songendedearly); }
		}
		else
		{
			WordShow("bye!", "#FFFFFF", "#000000", 1, 1000, 0.03);
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundbonusbye);
			if (mMusic.currentTime < 70) { TalkPlay3000(TalkType2.songendedearly); }
		}

		// remove remaining tiles
		for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
		{
			if (mPlayField[xyIndex] != 0)
			{
				mPlayField[xyIndex] = 0;
				mPlayFieldDivs[xyIndex].visualState = 3;
			}
		}

		mState = 1;
		mWorldState = 2;
		mWorldState2Action = 2;
		mWorldStateAlive = Date.now() + 2000;
	}
	// </BONUS FAILURE>
	
	else
	{
		console.assert(mUrineState <= 0, "WorldUpdateFailStuck Error: Fail happened BUT someone peeed in this pool");
		console.assert(mUseTheForceState == 0, "WorldUpdateFailStuck Error: We SolveUpdate failed WHILE the force was on");

		if (pFail)
		{	
			if ( (mWorldMode == 0) && ((mWorldRepeatCount % 4) == 0) ) { TalkPlay3000(TalkType2.instructions); }
		}
		
		var overrideWordShow = 0;   // 1:HAHA 2:PATHETIC (formerly used by Streak)

		// <CHANGE SCORE>
		if (mWorldMode > 0)
		{
			// WorldLevelReset updated mStatNewFail
		}
		else
		{
			if ((mWorldRepeatCount == 2) && (mState == 0) && (mScoreUpdated == 0) && (mUrineState == 0) && (mLevelType != LevelType.Boss) )
			{
				if ( ((pFail) && (mTalkRandomFailState == 0)) || (!pFail) )
				{
					WorldEndStatUpdate(2);
				}
			}
		}
		// </CHANGE SCORE>

		if (pFail)
		{
			// Fail. Player can keep moving (until they are stuck)
			SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundfail);   // player continues, level NOT rebuilt.
			mState = 1;
			console.assert(mUrineState <= 0, "WorldUpdateFailStuck() Error: Fail occurred BUT mUrineState > 0 :" + mUrineState);
			WordShow("", "#000000", "#000000", 1, 100000);
			
			/*
			for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
			{
				if (mPlayField[xyIndex] > 0)
				{
					let ratio = (0.1 + Math.random() * 0.4);
					mPlayFieldDivs[xyIndex].transform.jimWidth = mTileSize * ratio;
					mPlayFieldDivs[xyIndex].transform.jimHeight = mTileSize * ratio;
				}
			}
			*/
		}
		else
		{
			// Stuck. Player expands for 2 seconds, then level resets
			mPlayer.transform.jimWidth = mTileSize * 1.1;   // electricity might have warped things
			mPlayer.transform.jimHeight = mTileSize * 1.1;

			if (mUrineState < 0)
			{
				WordShow("SERIOUSLY.<BR>IT >CAN< BE DONE.<BR>", "#000000", "#FF0000", 1.5, 4000);
				SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
			}
			else
			{
				WordShow("", "#000000", "#000000", 1, 100000);
				SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
			}
						
			mState = 1;
			mWorldState = 2;
			mWorldState2Action = 3;
			mWorldStateAlive = Date.now() + 2000;
		}

		if (overrideWordShow > 0)
		{
			if (overrideWordShow == 1)
			{
				WordShow("HA<BR>HA", "#FFA500", "#FFFF00", 1, 6000, 0.03);
				SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
				SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundlaughing);
			}
			else if (overrideWordShow == 2)
			{
				WordShow("PATH<BR>ETIC", "#E2A916", "#00FF00", 1, 6000, 0.015);
				SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
				SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundapplauseweak);
			}				
		}
	}

	TilesWhite();
	mPlayer.FaceChange(1);
}

document.addEventListener("visibilitychange", () => {
	// Catches the cases document.hasFocus() doesn't (tab change)
	// iPhone and Browser testing shows this stops WorldUpdate.requestAnimationFrame.
	// I am RELYING on this fact, otherwise WorldUpdate is going to keep working (even though no-one can see it)
	if (mLevelGenerate == null)
	{
		if ((document.hidden) || (document.visibilityState != "visible"))
		{
			mWorldFreezeTime = Date.now() + 1000 * 60 * 60 * 24;
			mAudioContext.suspend();
		}
		else
		{
			mWorldFreezeTime = Date.now() + 750;
			backgroundR = 0; backgroundG = 255; backgroundB = 0;
			mAudioContext.resume();
		}
	}
});

var TimeStampOld = 0.0;
var mWorldUpdateCalled = false;
var mWorldFocus = 1;
function WorldUpdate(pTimeStamp = 100)
{
	if (mWorldState == 0) { return; }

	// Catches the cases "VisibilityChange" doesn't (browser loses focus to smaller window in front)
	if (mLevelGenerate == null)
	{
		if (!document.hasFocus())
		{
			if (mWorldFocus == 1)
			{
				mWorldFreezeTime = Date.now() + 1000 * 60 * 60 * 24;
				mAudioContext.suspend();
				mWorldFocus = 0;
			}
			window.setTimeout(WorldUpdate, 1000);   // passes pTimeStamp 1/10th of a second
			return;
		}
		else if (mWorldFocus == 0)
		{
			mWorldFreezeTime = Date.now() + 750;
			backgroundR = 0; backgroundG = 255; backgroundB = 0;
			mAudioContext.resume();
			mWorldFocus = 1;
		}
	}

	console.assert(!mWorldUpdateCalled, "WorldUpdate() called WHILE WorldUpdate going.");	
	mWorldUpdateCalled = true;

	var requestFrame = true;
	if (pTimeStamp - TimeStampOld >= (1000.0 / 60.0))
	{
		// Fixed frame rate. Everything in here runs at 60fps (no more, no less)
		// If machine can't handle that, game slows down
		if ((pTimeStamp - TimeStampOld) > (1000.0 / 60.0) * 1.2)
		{
			// we're too backed up, process it all
			TimeStampOld = pTimeStamp;
		}
		else
		{
			// we'll do 1/60th now and then return QUICKER if more than 1/60th passed
			TimeStampOld += (1000.0 / 60.0);
		}
		mWorldFrameCounter++;

		/*
		visualstate
		0. DEAD. NOT part of this level. NOT MOVING
		1. DYING - either shrinking to 0 or heading toward -100, -100 (enroute to DEAD). 1. Level transition made it NOT part of level OR 2. player remnoved  AFTER failing
		2. Part of this level - UNTOUCHED. Moving only to stay part of the grid.
		3. Part of this level - TOUCHED
		*/

		ButtonUpdate();				
		WordUpdate();
		SensitivityUpdate();
		
		// Note: mPlayer.Update() no LONGER constantly called - it only responds to events (unlike mPlayer.Draw())
		if (mWorldFreezeTime > 0)
		{
			gBrowser.KeyReset();		
			if (Date.now() > mWorldFreezeTime) { mWorldFreezeTime = 0; }
		}
		gBrowser.TouchProcessUpdate();
		mPlayer.Draw();
		TilesUpdate();
		mPlayback.Update();   // player KILLS playback here.
		
		RestartUpdate();	
		BackgroundUpdate();
		mSpots.Update();

		
		// <SOLUTIONS DISPLAY>
		if (mState == 1)
		{
			// Failure!
			mStatTopRightDiv.innerHTML = ":(";
			mStatNewSolution = 0;
		}
		else if (mTileTotal == mTileTotalRemember)
		{
			// Using pre-calculated solution from File which MIGHT be a ?
			if (mSolutions > mSolutionsFileRemember) { mSolutionsFileRemember = mSolutions; }
			mStatTopRightDiv.innerHTML = mSolutionsFileRemember.toLocaleString();
			mStatNewSolution = mSolutionsFileRemember;
		}
		else if (mWorldState == 2)
		{
			// Success!
			mStatTopRightDiv.innerHTML = ":)";
			mStatNewSolution = 0;		
		}
		else
		{
			// Don't immediately show mSolutions (which is constantly counting up from 0). A "lazy" update is much better
			// Don't want constant addition/removal of ?. Give SolveUpdate a chance to resolve before changing number
			if ( (mSolveUpdateCount > 0) && (Date.now() >= mSolveUpdateDate + 200) )
			{
				if ( (mState == 2) && (mSolutions != -1) && (!mStatePushPopped) )
				{
					mStatTopRightDiv.innerHTML = mSolutions.toLocaleString();
					mStatNewSolution = mSolutions;
				}
				else
				{
					// we may have found 1 solution but NOT all solutions (indicate with ?)
					if (mSolutions > mStatNewSolution) { mStatNewSolution = mSolutions; }
					mStatTopRightDiv.innerHTML = mStatNewSolution.toLocaleString() + "?";
				}
			}
		}
		// </SOLUTIONS DISPLAY>

		// <WORLDSTATE == 2>
		if (mWorldState == 2)
		{
			console.assert(mWorldStateAlive > 0, "WorldUpdate Error() : mWorldState == 2 BUT mWorldStateAlive == 0!");
			console.assert(
				((mWorldState2Action >= 1) && (mWorldState2Action <= 3))
				, "WorldUpdate Error() : mWorldState == 2 BUT mWorldState2Action INCORRECT '" + mWorldState2Action + "'"
			);	
			
			if (Date.now() > mWorldStateAlive)
			{
				mWorldStateAlive = 0;
				console.assert(mWorldState2Action != 0, "WorldUpdate() Error: mWorldState == 2 is finished, BUT mWorldState2Action = 0");

				// <REPEAT>
				if (mWorldState2Action == 3)
				{
					// don't get to repeat final level
					if ((mWorldMode > 0) && (mWeekdayLevelsRemaining == 1))
					{
						MenuFinalLevelFailed();
						requestFrame = false;
					}
					else
					{
						// no message, must be set BEFORE we get here
						mWorldRepeatCount++;
						if ( (mWorldRepeatCount >= 3) && (mScoreUpdated == 0) ) { WorldEndStatUpdate(2); }
						mPlayback.freezeTime = Date.now() + 500;
						mPlayback.Add();
						WorldLevelReset();
						mWorldState = 1;   // switch from ending to playing
					}
				}
				// <REPEAT>

				else if (mWorldState2Action == 1)
				{
					console.assert("WorldUpdate() Error: mWorldState2Action == 1 is DEAD/REPLACED.");
				}

				// <NEW LEVEL>				
				else if (mWorldState2Action == 2)
				{
					console.assert(mState != 0, "WorldUpdate() Error: Level ended (mWorldStateAction == 2) BUT mState == 0");
					
					if (mWorldMode == 0)
					{
						if (mScoreUpdated == 0)
						{
							if (mState == 1) { WorldEndStatUpdate(2); } else { WorldEndStatUpdate(1); } 
						}
					
						// All endings resolve here (success, failure, hole, urine success/failure, use the force success/failure)
						// Remember: cannot use WordShow here, because WorldReset can finish quickly, immediately overwriting word
						console.assert((mScoreUpdated != 0), "Error: Finished level (mWorldState == 2) BUT score was NOT updated!");

						// <TALK NEXT>
						// Do we go to the NEXT TALK, or just the NEXT LEVEL?
						// mTalkIndex can ONLY BE CHANGED HERE. Do NOT want mMusic.OnEnded changing it, because half the level could use old mTalkIndex, and half the level the new mTalkIndex
						// If bonus level is complete (success or fail), mTalkIndex MUST change
						// If player finishes levels fast: mTalkLastDate ensures GAPS between talks - mTalkIndex will NOT change until 2 minutes have passed (includes time to build level)
						// If player finishes levels slow: mTalkLevelCount ensures they must complete 4 levels before mTalkIndex changes
						// Remember: Talks control EVERYTHING (not levels). After a talk completes, it tells game to switch levels via mTalkLastDate. This MUST happen. Nothing else switches levels.
						// Remember: Talk can NEVER stop another talk (which might contain some state changes). It's okay for a talk to ignore timer.
						// console.log("NEW LEVEL mMusic.talkIndex:" + mMusic.talkIndex + " : mTalkLastDate:" + mTalkLastDate);
						mTalkLevelCount++;

						/*
						// DEBUG 2024-07-25
						mMusic.talkIndex = -1;	 
						mMusic.pause();
						mTalkLastDate = 0;
						mTalkIndex++;
						setCookie("TalkIndex", mTalkIndex);
						mTalkLevelCount = 0;
						console.log("!!! mTalkIndex CHANGED: " + mTalkIndex);
						*/
						
						if ( (mMusic.talkIndex == -1) && (mTalkIndex < mTalk3000Index) )
						{
							// Talking is finished (we will NEVER overlap talking), BUT we still need to wait for the gap afterward to finish (mTalkLastDate)
							var waitTime = 1000 * 60;   // a minute and a half between levels
							var total = mStatNewFrankWin + mStatNewFrankLoss + 1;
							if (total < 20) { waitTime = 1000 * 30; } // levels are so simple
							/*
							alert(
								"TALKINDEX: " + (Date.now() - mTalkLastDate > waitTime) + " :: " + (Date.now() - mTalkLastDate)
								+ ":" + waitTime + " " + mTalkIndex + "   " + mTalkLevelCount
							);
							*/
							if (
								(mTalkLevelCount >= 4)
								&&
								(
									(
										(mTalkLastDate > 0)
										&&
										(
											( (!mTalkLastType3000) && (Date.now() - mTalkLastDate > waitTime) )   // Talks that want to say something need to wait 60 seconds from previous Talk
											|| ( (mTalkLastType3000) && (Date.now() - mTalkLastDate > 1000 * 15) )   // Talks that want to say something need to wait 15 seconds from previous interjection
											|| ( (mTalkIndex + 1 < mTalk3000Index) && ((mTalks[mTalkIndex + 1][2] == null) || (mTalks[mTalkIndex + 1][2] == "")) )   // Bonus levels start without waiting for Talk timer to expire.
											|| ( (Date.now() - mTalkLastDate > 1000 * 30) && ((mTalks[mTalkIndex][2] == null) || (mTalks[mTalkIndex][2] == "")) )   // Dies on bonus level, want to hurry to the next one
										)
									)
									||
									(
										( (mTalkLastDate == 0) && ((mTalks[mTalkIndex][2] == null) || (mTalks[mTalkIndex][2] == "")) )   // Bonus levels HAVE NO TALK, so mTalkLastDate NEVER gets set (unless talk is interjected)
									)
								)
							)
							{
								console.assert(
									(mTalkLastDate > 0)
									|| ( (mTalkLastDate == 0) && ((mTalks[mTalkIndex][2] == null) || (mTalks[mTalkIndex][2] == "")) )
									, "WorldReset() Error: Bonus level finished BUT mTalkLastDate != 0! mTalkLastDate should NOT be set for bonus levels");
								
								mTalkLastDate = 0;
								mTalkIndex++;
								setCookie("TalkIndex", mTalkIndex);
								mTalkLevelCount = 0;
								console.log("!!! mTalkIndex CHANGED: " + mTalkIndex);
							}						
						}
						// </TALK NEXT>
					}
					
					// <NEXT STEP>
					if (mRestart.xyIndex == mPlayer.xyIndex) { SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundpop); }
					
					if (mWorldMode > 0)
					{
						console.assert(
							(mState == 2)
							|| ( (mUseTheForceState > 0) && ((mState == 1) || (mState == 2)) )
							, "WorldUpdate Error: mWorldMode == 1, Next Step: mState != 2 '" + mState + "', how did we get here?"
						);
						console.assert(
							((mLevelIndex > -1) && (mLevelIndex < mLevels.length))
							, "WorldUpdate() Error: mLevelIndex is invalid. '" + mLevelIndex + "'"
						);

						mWeekdayLevelsRemaining--;						
						if (mWeekdayLevelsRemaining == 0)
						{
							MenuFinished();   // COMPLETED this day!
						}
						else if (mWeekdayLevelsRemaining == 1)
						{
							MenuFinalLevel();   // Warning before final level (winds it's way back to WorldResetNew)
						}
						else
						{
							window.setTimeout(WorldResetNew, 15, true);   // Next Level
						}
					}
					else
					{
						// Tale of Frank... the oriingal weird setup
						window.setTimeout(WorldReset, 15, true);
					}
					// <NEXT STEP>

					requestFrame = false;
				}
				else
				{
					alert("WorldUpdate Error: Invalid mWorldState2Action '" + mWorldState2Action + "'. Can only be 2 or 3!");
				}
				// </NEW LEVEL>
			}
		}
		// </WORLDSTATE == 2>
		
		// <FAIL>	
		else if ( (mState == 0) && (mUseTheForceState == 0) && (mUrineState <= 0) && (mTalkStates[TalkType.fail] != 0) )
		{
			// <UNDETERMINED STATE>
			// We can no longer determine recursive failure (SolveUpdate determined this).
			// Colour random tiles to indicate the AI is thinking (even though it's given up)
			// Resets when player moves
			// Also happens for 100ms after every move, when full recursion has not happened
			if ((mSolutions == -1) || (Date.now() < mSolveUpdateDate))
			{
				if (mSolveUpdateColorFlag)
				{
					let count = 3;   // like keeping lots of white ones (this is going to happen a lot now with 60000 reduced to 5000)
					let xyIndex = -1;
					let tile = null;
					while (count > 0)
					{
						xyIndex = parseInt(Math.random() * mPlayFieldDivs.length);
						if (mPlayField[xyIndex] > 0)
						{
							tile = mPlayFieldDivs[xyIndex];
							if (
								(tile.colorTempTime == 0)
								&& ((tile.colorR == tile.colorRFinal) && (tile.colorG == tile.colorGFinal) && (tile.colorB == tile.colorBFinal))
								&& (tile.extra == 0)
							)
							{
								mPlayFieldDivs[xyIndex].solved = 0;
								// Could call TileSetColorTemp, but this happens ALL the time so "inlining" it
								mPlayFieldDivs[xyIndex].colorTempTime = mWorldFrameCounter + 400 / 16;   // holdDateNow if we switch back to Date.now() approach 
								mPlayFieldDivs[xyIndex].colorRTemp = 96;
								mPlayFieldDivs[xyIndex].colorGTemp = 96;
								mPlayFieldDivs[xyIndex].colorBTemp = parseInt(96.0 * (96.0 / 64.0));

								/*
								mPlayFieldDivs[xyIndex].solved = 0;
								// slightly darker to indicate brokenness
								tile.colorTempTime = mWorldFrameCounter + 1600 / 16;   // holdDateNow if we switch back to Date.now() approach 
								let color = parseInt(76 + parseInt(Math.random() * 3) * 10);
								tile.colorRTemp = color;
								tile.colorGTemp = color;
								tile.colorBTemp = parseInt(color * (96.0 / 64.0));
								*/
							}
						}
						count--;
					}
				}
			}
			// </UNDETERMINED STATE>
			
			// <SOLVEUPDATE>
			else
			{
				var newState = 0;

				// Turn OFF extra tiles so SolveUpdate works properly
				if (mTalkStates[TalkType.tileExtra] > 0) { TileExtraChangePlayFieldState(0); }

				if (mSolveUpdateCount == 0)
				{
					newState = SolveUpdateStart();
					mSolveUpdateDate = Date.now() + 200;   // user might be quickly moving, so don't unleash heavy investigation yet (save battery power)
				}
				else if (Date.now() > mSolveUpdateDate)
				{ 
					newState = SolveUpdate(10);   // 200 - too much impact
					if ((newState == 1) && (mStatePushPopped))
					{
						// since we removed some paths (to save memory), cannot DEFINITIVELY conclude player has failed.
						// stop searching (there's no point - playfield is currently too complicated)
						// show the player we're still thinking by lighting up the board with random blues
						newState = 0;
						mSolutions = -1;
					}
				}

				// Turn ON extra tiles so player can walk on them (do NOT change mTileTotal) - must NOT call SolveUpdate while extras are on
				if (mTalkStates[TalkType.tileExtra] > 0) { TileExtraChangePlayFieldState(1); }
				
				if (newState == 1)
				{
					// We can't finish this playfield, determine what to do (based on Urine, etc.)
					// Remember: Player hasn't moved so they will be able to move AFTER fail is declared - they're not stuck on edge tile - that's why I pass TRUE
					// "just" a fail, NOT a stuck
 					WorldUpdateFailStuck(true);
				}
				else
				{
					mState = newState;   // 0:keep trying   2:found a solution!

					if (mSolveUpdateColorFlag)   // Bonus and Milestone have already colored the tiles, do NOT mix (doesn't look good)
					{
						for (var xyIndex = 0; xyIndex < mPlayFieldDivs.length; xyIndex++)
						{
							// && (mPlayFieldDivs[xyIndex].finishTileState == 0)
							if (mPlayFieldDivs[xyIndex].solved > 1500)   // 10:1500 50:7000
							{
								mPlayFieldDivs[xyIndex].solved = 0;
								// Could call TileSetColorTemp, but this happens ALL the time so "inlining" it
								mPlayFieldDivs[xyIndex].colorTempTime = mWorldFrameCounter + 400 / 16;   // holdDateNow if we switch back to Date.now() approach 
								mPlayFieldDivs[xyIndex].colorRTemp = 96;
								mPlayFieldDivs[xyIndex].colorGTemp = 96;
								mPlayFieldDivs[xyIndex].colorBTemp = parseInt(96.0 * (96.0 / 64.0));
							}
						}
					}
				}
			}
			// </SOLVEUPDATE>
		}
		// </FAIL>
			
		/*
		if ((mWorldFrameCounter % 15) == 0)
		{
			for (var xyIndex = 0; xyIndex < mPlayFieldDivs.length; xyIndex++)
			{
				mPlayFieldDivs[xyIndex].solved *= 0.9;
			}
		}
		*/

		// Increase Time if mWorldState is NOT celebrating, mState is NOT FAILED, Word is DONE flying in.
		if ((mWorldMode == 1) && (mWorldState == 1) && (mState != 1) && (mWord.aliveRemember == 0) && (mUseTheForceState == 0) )
		{
			mStatNewTime += 1;   // each unit = 1/60th of a second
			mStatBottomLeftDiv.innerHTML = FormatTime(mStatNewTime);
		}
	}

	// if ((document.hidden) || (document.visibilityState == "hidden")) unncessary since requestAnimationFrame automatically disabled when page loses focus		
	if (requestFrame) { requestAnimationFrame(WorldUpdate); }
	mWorldUpdateCalled = false;	
}
// </WORLD>


// ---------------------------------------------------------------------------------------------------------------------
// <PLAYER>
// ---------------------------------------------------------------------------------------------------------------------
function Player()
{
	this.playfield = new Array(mTileXMax * mTileYMax); 

	this.moveDate1 = 0;
	this.moveTurn = 0;
	this.increaseLimit = 0;
	
	this.left = 0;   // private
	this.top = 0;
	this.xyIndex = 0;
	this.ChangePosition = function(pLeft, pTop) { this.left = pLeft; this.top = pTop; this.xyIndex = this.top * mTileXCount + this.left; }

	this.div = document.getElementById("player");
	// this.div = document.createElement("div");
	// this.div.style.cssText = "position:absolute; background-image:url('faces3500x350.png'); background-position: 0px 0px; background-repeat:no-repeat; background-size:100% 100%; left:-100px; top:-100px; width:350px; Height:350px; z-index:4; text-align:center; padding:0px; margin:0px; overflow:hidden;";
	// mWorldDiv.appendChild(this.div);

	this.transform = new Transform(this.div);

	this.transform.LerpChange(parseInt(window.innerWidth * 0.5), parseInt(window.innerHeight * 0.5), 1, 10, 10, 1);

	this.trailPulseSize = 0;
	this.faceState = -1;
	this.blinkState = 0;
	this.blinkCounter = 0;
	
	this.shadowSize = -1;
		
	this.textLines = new Array(1);
	this.textStart = 0;
	this.textEnd = 0;
	
	this.keySuccess = 37;
	this.rotateS = 0;
	this.restartPull = 0.0;
	this.turns = 0;
	this.keyOld = 0;

	this.rememberOldTurnKey	= -1;
	
	this.faces = new Array();
	for (var index = 0; index < 4; index++)
	{
		this.faces[index * 2] = document.getElementById("face" + index + "0");
		this.faces[index * 2 + 1] = document.getElementById("face" + index + "1");
	}
	
	this.FaceChange = function(pFaceState)
	{			
		console.assert((pFaceState >= 0) && (pFaceState <= 3), "FaceChange() Error - invalid pFaceState:" + pFaceState);
		if (pFaceState != this.faceState)
		{
			if (this.blinkState == 0)
			{
				this.faces[pFaceState * 2].style.visibility = "";
				this.faces[pFaceState * 2 + 1].style.visibility = "hidden";
			}
			else
			{
				this.faces[pFaceState * 2 + 1].style.visibility = "";			
				this.faces[pFaceState * 2].style.visibility = "hidden";
			}

			if (this.faceState != -1)
			{
				this.faces[this.faceState * 2].style.visibility = "hidden";
				this.faces[this.faceState * 2 + 1].style.visibility = "hidden";
			}
			
			this.faceState = pFaceState;
		}
	}
		
	this.PositionRandom = function()
	{
		this.xyIndex = -1;
		do
		{
			this.xyIndex = parseInt(Math.random() * mTileXYCount);
		}
		while (mPlayField[this.xyIndex] == 0)
		this.top = parseInt(this.xyIndex / mTileXCount);
		this.left = this.xyIndex - this.top * mTileXCount;		
	}
	
	this.Reset = function()
	{
		// don't like this - it's only half a reset which is both unexpected and bad
		this.FaceChange(0);
		this.div.style.zIndex = 4;
		this.restartPull = 0.0;
		this.turns = 0;
		this.keyOld = 0;
		this.rememberOldTurnKey	= 37 + parseInt(Math.random() * 4);
		gBrowser.KeyReset();
		
		/*
		// debug
		var hold = 0;
		for (var index = 0; index < this.playfield.length; index++)
		{
			hold = mSolvedPlayfield[0][index];
			if (hold == -1) { hold = 37; }
			else if (hold == -2) { hold = 39; }
			else if (hold == -3) { hold = 38; }
			else if (hold == -4) { hold = 40; }
			else if (hold == 0) { hold = 0; }
			else if (hold == 1) { hold = 1; }
			else { console.error("Player.Reset() Error: Unexpected playfield value :" + hold); }
			this.playfield[index] = hold; // mSolvedPlayfield[0][index];
		}
		*/
	}
		
	this.Update = function()
	{
		if (mWorldFreezeTime > 0)
		{
			gBrowser.KeyReset();
		}
		else if (mWorldState == 1) 
		{
			this.trailPulseSize += 0.075; if (this.trailPulseSize >= Math.PI) { this.trailPulseSize -= Math.PI; }

			var key = 0;
			var hold = gBrowser.KeyPop();				
			var keyOriginal = hold.key, keyTime = hold.time, keyShift = hold.shift;
			// console.log("keyOriginal:" + keyOriginal + "   keyShift:" + keyShift);
			if (keyOriginal == 32) { key = this.keySuccess; } else { key = keyOriginal; }

			var moveCounter = 0;
			var movedOnce = false;
			while (key != 0)
			{					
				console.assert(key != 32, "Player.Update() key is 32!!!");
				this.restartPull = 0.0;
				this.rotateS = 0;
			
				var dirX = 0, dirY = 0;
				if (key == 37)   // left arrow or w
				{
					dirX = -1;
					this.transform.jimRotate = 270; if (mWorldFlipped) { this.transform.jimRotate = 0; }
					RotateDiv(this.div, this.transform.jimRotate);			
				}
				else if (key == 39)   // right arrow or d
				{
					dirX = 1;
					this.transform.jimRotate = 90; if (mWorldFlipped) { this.transform.jimRotate = 180; }
					RotateDiv(this.div, this.transform.jimRotate);
				}
				else if (key == 38)   // up arrow or w
				{
					dirY = -1;
					this.transform.jimRotate = 0; if (mWorldFlipped) { this.transform.jimRotate = 270; }
					RotateDiv(this.div, this.transform.jimRotate); 
				}
				else if (key == 40)   // down arrow or s
				{
					dirY = 1;
					this.transform.jimRotate = 180; if (mWorldFlipped) { this.transform.jimRotate = 90; }
					RotateDiv(this.div, this.transform.jimRotate); 
				}
				else
				{
					console.error("Player.Update() Error: Unknown key '" + key + "' was pressed.");
				}
				// BOSS "Do level in Reverse"
				if (mLevelStageCount == 1) { RotateDiv( this.div, ((this.transform.jimRotate + 180) % 360) ); }

				if (mTalkStates[TalkType.control] == 0)
				{
					this.transform.jimLeft = mPlayFieldDivs[this.xyIndex].newLeft + parseInt(dirX * Math.random() * (mTileSize * 0.25));
					this.transform.jimTop = mPlayFieldDivs[this.xyIndex].newTop + parseInt(dirY * Math.random() * (mTileSize * 0.25));	
					this.transform.jimHeight *= 0.85;
					this.transform.jimWidth *= 0.85;

					this.transform.jimRotate += (-20 + Math.random() * 41);
					RotateDiv(this.div, this.transform.jimRotate);

					key = 0;
					moveCounter = 0;
					
					SoundBufferPlay(mSoundBufferTick, 0.05, -1, 1);
				}
				else if (
					((this.left + dirX >= 0) && (this.left + dirX < mTileXCount) && (this.top + dirY >= 0) && (this.top + dirY < mTileYCount))
					&& (
						(mPlayField[(this.top + dirY) * mTileXCount + (this.left + dirX)] > 0)
						||
						( ((this.top + dirY) * mTileXCount + (this.left + dirX) == mRestart.xyIndex) && (moveCounter == 0) && (keyOriginal != 32) )
					)
				)
				{	
					var repeat = 0;
					if (mState != 1)
					{
						mPlayback.Record(key, keyShift);
						repeat = mPlayback.MatchCurrent();   // did i fail following the EXACT same path?								
					}

					// <THAT'S ONE>
					if (repeat > 0)
					// if ( (repeat > 0) && (mTileTotal > 2) )
					{
						this.left += dirX; this.top += dirY;
						this.xyIndex = this.top * mTileXCount + this.left;									
						this.transform.jimLeft = mPlayFieldDivs[this.xyIndex].newLeft;
						this.transform.jimTop = mPlayFieldDivs[this.xyIndex].newTop;

						// <INSTANT REPEAT>
						if (repeat < 3)
						// if ((repeat < 3) || (mWorldMode > 0))
						{
							// exact same mistake twice, don't count as failure - it's a different path
							// like rolling doubles three times in Monopoly
							if (repeat == 1)
							{
								WordShow("THAT'S<BR>ONE!", "#FFFFFF", "#000000", 1, 2000, 0.01);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
								SoundBufferPlay(mSoundBufferMisc, 1.0, SoundBufferMiscType.soundthatsone);				
							}
							else if (repeat == 2)
							{
								WordShow("THAT'S<BR>TWO!!", "#FFFFFF", "#000000", 1, 2000, 0.01);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
								SoundBufferPlay(mSoundBufferMisc, 1.0, SoundBufferMiscType.soundthatstwo);				
							}
							/*
							else
							{
								WordShow("ENO<BR>UGH", "#FFFFFF", "#FF0000", 1, 4000, 0.05);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundcow);
								SoundBufferPlay(mSoundBufferMisc, 1.0, SoundBufferMiscType.soundenough);								
							}
							*/

							mPlayback.Add(false);    // aready have one playback recorded, (false) means don't record another		
							mState = 1;
							mWorldState = 2;
							mWorldState2Action = 3;
							mWorldStateAlive = Date.now() + 1000;
	
							// mPlayback.freezeTime = Date.now() + 500;
							// WorldLevelReset();
						}
						// </INSTANT REPEAT>

						// <THIRD REPEAT>
						else
						{
							console.assert((mUseTheForceState == 0) || (mUseTheForceState == 3));

							mRestart.xyIndex = mPlayer.xyIndex;
							RestartPosition(mRestart.xyIndex);
							mRestart.transform.LerpChange(mRestart.newLeft, mRestart.newTop, 1, mTileSize * 6, mTileSize * 6, 1);	

							WordShow("ENO<BR>UGH", "#FFFFFF", "#FF0000", 1, 4000, 0.05);
							SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
							SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundcow);
							SoundBufferPlay(mSoundBufferMisc, 1.0, SoundBufferMiscType.soundenough);

							WorldEndHole();
						}
						// </THIRD REPEAT>
						key = 0;
						moveCounter = 0;
					}
					// </THAT'S ONE>

					// <REPEAT EXACTLY>
					else if (
						(mUseTheForceState == 3)
						&& (this.playfield[this.top * mTileXCount + this.left] != key)
						&& ( ((this.top + dirY) * mTileXCount + (this.left + dirX)) != mRestart.xyIndexRemember )
					)
					{
						this.left += dirX; this.top += dirY;
						this.xyIndex = this.top * mTileXCount + this.left;									
						this.transform.jimLeft = mPlayFieldDivs[this.xyIndex].newLeft;
						this.transform.jimTop = mPlayFieldDivs[this.xyIndex].newTop;

						console.log(this.playfield[this.top * mTileXCount + this.left] + ":" + key);
						WordShow("WRONG", undefined, undefined, 1, 2000, 0.01);
						SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);

						mPlayback.Add();
						WorldLevelReset();

						key = 0;
						moveCounter = 0;
					}
					// </REPEAT EXACTLY>

					else
					{
						if (mUseTheForceState != 3) { this.playfield[this.top * mTileXCount + this.left] = key; }
					
						if (
							( (mLevelType == LevelType.Regular) || (mLevelType == LevelType.Tricky) )
							&& (mUseTheForceState != 1) && (keyShift == 0)
						)
						{
							var volume = 0.1; if (mState == 1) { volume = 0.05; }
							SoundBufferPlay(mSoundBufferTick, volume, -1, 1);
						}

						// <URINESTATE FAIL FAKE>
						if (
							(mUrineState > 0)
							&& (mState != 1)
							&& (mTileTotal > 10)
							&& (mTileTotalRemember - mTileTotal > 10)
							&& ( Math.random() < (1.0 / (mTileTotalRemember * 2.0)) )
						)
						{
							mState = 1;								
							MusicStop();
							TilesWhite();								
							this.FaceChange(1);
							WordShow("", "#000000", "#000000", 1, 100000);				
							SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundfailmaybe);
						}
						// </URINESTATE FAIL FAKE>

						// i can move! and perhaps keep moving!
						moveCounter++;
						this.keySuccess = key;

						// <BEFORE>
						// if (mTileTotal == mTileTotalRemember) { copyCanvasToClipboard(mCanvasMain); }

						mPlayField[this.xyIndex] = 0;   // kills tile, TilesUpdate will send it flying away towards corner
						if (mPlayFieldDivs[this.xyIndex].extra == 0) { mTileTotal--; }   // Player already Failed (mState = 1) from stepping on Extra tile, BUT just being paranoid							

						if (mState != 1) { TileSetColor(mPlayFieldDivs[this.xyIndex], 0, 0, 64, 0); }
						// </BEFORE>
						
						// <AFTER>							
						movedOnce = true;
						this.left += dirX; this.top += dirY;
						this.xyIndex = this.top * mTileXCount + this.left;

						if (mPlayFieldDivs[this.xyIndex].visiblePermanent <= 0)
						{
							SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundzapshort);
							mPlayFieldDivs[this.xyIndex].visiblePermanent = -1;   // Tile flickers BUT keeps .visiblePermanent setting
							if (Math.random() < 0.5)
							{
								this.transform.jimWidth = mTileSize * 5;
								this.transform.jimHeight = mTileSize * 0.5;								
							}
							else
							{
								this.transform.jimWidth = mTileSize * 0.5;
								this.transform.jimHeight = mTileSize * 5;								
							}
						}
						else
						{
							// remember this rotates
							this.transform.jimWidth = mTileSize * 0.5;
							this.transform.jimHeight = mTileSize * 1.1;
						}
						
						this.transform.jimLeft = mPlayFieldDivs[this.xyIndex].newLeft;
						this.transform.jimTop = mPlayFieldDivs[this.xyIndex].newTop;
						
						if (mState == 1)
						{
							// Initial Fail yields FaceChange(1) - huge shock, but it gets reduced afterward
							if (this.faceState != 2) { this.FaceChange(2); }
						}
						else
						{
							mState = 0; mSolveUpdateCount = 0; mSolutions = 0;   // start solving again!
						}							
						// </AFTER>
						
						mSpots.Add(mPlayer.transform.jimLeft, mPlayer.transform.jimTop);

						// this.keyOld = 0 is ignored
						if (
							( ((this.keyOld == 37) || (this.keyOld == 39)) && ((key == 38) || (key == 40)) )
							|| ( ((this.keyOld == 38) || (this.keyOld == 40)) && ((key == 37) || (key == 39)) )
						)
						{
							this.rememberOldTurnKey = this.keyOld;
							this.turns++;   // for levels that require LEAST or MOST turns
						}					
						this.keyOld = key;							
						
						// <TALK FAKE FAIL>
						if (
							(mTalkRandomCountdown > 0)
							&& (mState != 1)
							&& (mUrineState <= 0)
						)
						{
							mTalkRandomCountdown--;
							if (mTalkRandomCountdown == 0)
							{
								console.assert(mTalkRandomFailState == 0);
								mTalkRandomFailState = 1;
								mState = 1;
								MusicStop();
								TilesWhite();
								this.FaceChange(1);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundfail);									
								mPlayback.playerCurrent -= 1; if (mPlayback.playerCurrent < 0) { mPlayback.playerCurrent += mPlayback.players.length; }
							}							
						}
						// </TALK FAKE FAIL>
						
						// <FINISH TILE>
						if (
							(this.xyIndex == mFinishxyIndex)
							&& (mTileTotal != 1)
							&& (mState != 1)
						)
						{
							console.assert(mPlayFieldDivs[this.xyIndex].finishTileState > 0, "Player.Update() Error: Tile for mFinishxyIndex not set.");
							WordShow("NOT<BR>YET", undefined, undefined, 1, 2000, 0.01);
							SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
							
							mState = 1;
							mWorldState = 2;
							mWorldState2Action = 3;
							mWorldStateAlive = Date.now();
							
							key = 0;
							moveCounter = 0;								
						}
						// </FINISH TILE>

						// <GROW>
						else if ( 
							(mTileTotal == 1)
							&& ( (mLevelType == LevelType.Bonus) || (mLevelType == LevelType.MileStone) || (mLevelType == LevelType.OneHundred) || (mWeekdayLevelsRemaining == 1) ) 
						)
						{
							if (mGrowCount == 0)
							{									
								mGrowDie = false;
								mSolveUpdateColorFlag = false;								

								if (mWeekdayLevelsRemaining == 1)
								{
									mGrowCount = mUserData.weekday[mWorldDayOfWeek][mWorldEvening].growCount;
									// mGrowCount = (mWorldEvening) ? 25 : 10;																		
								}
								else if (mLevelType == LevelType.Bonus)
								{
									mGrowCount = 10;
									TalkPlay3000(TalkType2.failcountdown10);
								}
								else if (mLevelType == LevelType.MileStone)
								{
									mGrowCount = 25;
									TalkPlay3000(TalkType2.failcountdown25);
								}
								else if (mLevelType == LevelType.OneHundred)
								{
									mGrowCount = 50;	
									TalkPlay3000(TalkType2.failcountdown50);										
								}
							}
							else
							{
								mGrowCount--;
							}

							if (mGrowCount > 0)
							{
								SoundBufferPlay(mSoundBufferMisc, 1.0, SoundBufferMiscType.soundblip);
								mGrowWordTileTotal = 0;
								GrowTiles();   // prevents mTileTotal from becoming <= 1 which would finish level
								key = 0;
								gBrowser.KeyReset();
								mWorldFreezeTime = Date.now() + 100;
							}
						}
						// </GROW>
						
						else 
						{
							// <EXTRA TILE>
							// *** debug / fix *** - extra/tileExtra should NOT be concerned about UseTheForce or Urine. When those states are set, they should remove ALL .extra
							if ( (mState != 1) && (mPlayFieldDivs[this.xyIndex].extra > 0) && (mUseTheForceState == 0) && (mUrineState <= 0) ) { WorldUpdateFailStuck(true); }
							// </EXTRA TILE>
							
							if ( (keyShift > 0) && (this.xyIndex != mRestart.xyIndex) )
							{
								// shift = 1;   // keep going
							} 
							else 
							{
								hold = gBrowser.KeyPop();				
								keyOriginal = hold.key; keyTime = hold.time; keyShift = hold.shift;
								if (keyOriginal == 32) { key = this.keySuccess; } else { key = keyOriginal; }
								moveCounter = 0;									
							}
						}
					}
				}
				else
				{
					// unable to move in the requested direction, BUT can we move at all?
					key = 0;
					
					// <SINGLE STEP>
					// if no ambiguity, it finds next possible step
					if ( (keyOriginal == 32) && ((moveCounter == 0) || (keyShift == 2)) )
					{
						// is there 1 non-ambigous direction we can move?
						var counter = 0;
						var x = this.left, y = this.top;

						if ( (x - 1 < 0) || (mPlayField[y * mTileXCount + (x - 1)] == 0) ) { counter++; }
						if ( (x + 1 >= mTileXCount) || (mPlayField[y * mTileXCount + (x + 1)] == 0) ) { counter++; }
						if ( (y - 1 < 0) || (mPlayField[(y - 1) * mTileXCount + x] == 0) ) { counter++; }
						if ( (y + 1 >= mTileYCount) || (mPlayField[(y + 1) * mTileXCount + x] == 0) ) { counter++; }
						
						// no ambiguity, there's 1 direction - take it!
						if (counter == 3)
						{
							if ( (x - 1 >= 0) && (mPlayField[y * mTileXCount + (x - 1)] > 0) )
							{
								key = 37;
							}
							else if ( (x + 1 < mTileXCount) && (mPlayField[y * mTileXCount + (x + 1)] > 0) )
							{
								key = 39;
							}
							else if ( (y - 1 >= 0) && (mPlayField[(y - 1) * mTileXCount + x] > 0) )
							{
								key = 38;
							}
							else if ( (y + 1 < mTileYCount) && (mPlayField[(y + 1) * mTileXCount + x] > 0) )
							{
								key = 40;
							}
						}
						else   
						{
							// I can go left/right or up/down, choose based on previous turn
							if ( (this.rememberOldTurnKey == 37) && (x - 1 >= 0) && (mPlayField[y * mTileXCount + (x - 1)] > 0) ) { key = 37; }
							if ( (this.rememberOldTurnKey == 39) && (x + 1 < mTileXCount) && (mPlayField[y * mTileXCount + (x + 1)] > 0) ) { key = 39; }
							if ( (this.rememberOldTurnKey == 38) && (y - 1 >= 0) && (mPlayField[(y - 1) * mTileXCount + x] > 0) ) { key = 38; }
							if ( (this.rememberOldTurnKey == 40) && (y + 1 < mTileYCount) && (mPlayField[(y + 1) * mTileXCount + x] > 0) ) { key = 40; }
							
							if (key == 0)
							{
								// go any which way you can (truth be told if i couldn't go left, then i can go right, but this approach covers things I may not have thought of)
								if ( (x - 1 >= 0) && (mPlayField[y * mTileXCount + (x - 1)] > 0) ) { key = 37; }
								if ( (x + 1 < mTileXCount) && (mPlayField[y * mTileXCount + (x + 1)] > 0) ) { key = 39; }
								if ( (y - 1 >= 0) && (mPlayField[(y - 1) * mTileXCount + x] > 0) ) { key = 38; }
								if ( (y + 1 < mTileYCount) && (mPlayField[(y + 1) * mTileXCount + x] > 0) ) { key = 40; }
							}
						}
					}
					// </SINGLE STEP>

					// Blocked / Cannot Go Back / Fall Off Edge?									
					if (key == 0)
					{
						// <CONCRETE BLOCK>
						// (mTalkStates[TalkType.concreteBlock] != 0) && (mState != 1) && (mUseTheForceState == 0)
						if (
							((this.left + dirX >= 0) && (this.left + dirX < mTileXCount) && (this.top + dirY >= 0) && (this.top + dirY < mTileYCount))
							&& (mPlayFieldDivs[(this.top + dirY) * mTileXCount + (this.left + dirX)].concreteBlock != 0)
						)
						{
							let holdDirX = dirX, holdDirY = dirY;
							if (mWorldFlipped) { holdDirX = dirY; holdDirY = dirX; }
							this.transform.jimLeft = mPlayFieldDivs[this.xyIndex].newLeft + parseInt(holdDirX * mTileSize * (0.2 + Math.random() * 0.2));
							this.transform.jimTop = mPlayFieldDivs[this.xyIndex].newTop +  parseInt(holdDirY * mTileSize * (0.2 + Math.random() * 0.2));	
							this.transform.jimHeight *= 0.8;   // due to rotation this covers off up/down/left/right
							this.transform.jimRotate += (-10 + Math.random() * 21);
						
							var tile = mPlayFieldDivs[(this.top + dirY) * mTileXCount + (this.left + dirX)];
							// invisible concrete already revealed by player, currently do nothing
							if (tile.concreteBlock == 2)
							{
							}
							// concrete not showing, mark it permanently green ala minesweeper flag
							else if (tile.concreteBlock == 1)
							{
								TileSetColor(tile, 0, 255, 0, 1);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundconcreteblockhit);
								tile.concreteBlock = 2;
							}
							// concrete already showing as light green - acknowledge the bump by making it dark green
							else if (tile.concreteBlock == -1)
							{
								TileSetColorTemp(tile, 250, 0, 255, 0);
								SoundBufferPlay(mSoundBufferMisc, 0.25, SoundBufferMiscType.soundconcreteblockhit);
							}
						}
						// </CONCRETE BLOCK>
					
						// gBrowser.keyPopIndex = gBrowser.keyPushIndex;
						if (moveCounter == 0)
						{
							this.transform.jimHeight *= 0.85;
							this.transform.jimWidth *= 0.85;

							this.transform.jimRotate += (-20 + Math.random() * 41);
							RotateDiv(this.div, this.transform.jimRotate);						

							if (mState == 1) { this.FaceChange(2); } else { this.FaceChange(0); }					
						}
						else
						{
							// keyshift presumably pressed (i didn't really test much)
							if (moveCounter > 15)
							{
								SoundBufferPlay(mSoundBufferMisc, 1.0, SoundBufferMiscType.soundswishbig);
							}
							else
							{
								volume = 0.1 * Math.pow(2, (moveCounter * 0.5));
								if (volume > 1) { volume = 1; }
								SoundBufferPlay(mSoundBufferSwish, volume, -1, 5);
							}
						}
					}
				}	
			}
			
			// <MOVEDONCE>
			if (movedOnce)
			{
				if ( (mWorldMode == 1) && (mWorldState == 1) && (mState != 1) && (mUseTheForceState == 0) )
				{
					mStatNewSteps++;
					mStatBottomRightDiv.innerHTML = mStatNewSteps.toLocaleString();
				}

				// <HOLE>
				if (mPlayer.xyIndex == mRestart.xyIndexRemember)
				{
					console.assert((mUseTheForceState == 0) || (mUseTheForceState == 3), "WorldUpdate() Error: We're using the force '" + mUseTheForceState + " BUT we used the HOLE!");
					if (mLevelType == LevelType.Boss)
					{
						var innerHTML = "";
						switch (mLevelStageCount)
						{
						case 0:
						{
							innerHTML = "BUT THAT WAS ONLY<BR>THE FIRST STAGE!";
							break;
						}
						case 1:
						{
							innerHTML = "SURELY YOU COULD<BR>GO BACK?";
							break;
						}
						case 2:
						{
							innerHTML = "TOO<BR>EXACTING?";
							break;
						}				
						}
						WordShow(innerHTML, undefined, undefined, 1, 2000 + 1500);
						SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundpop);
						WorldEndHole();
					}
					else if (mUrineState > 0)
					{
						// console.assert(mWorldRepeatCount == 0, "WorldUpdate() Error: UrineState ended (player entered hole) BUT mWorldRepeatCount != 0 '" + mWorldRepeatCount + "'");
						// <URINESTATE END SUCCESS2>
						if (mUrineState == 1)
						{
							// Level could NOT be beaten. Entering Hole A SUCCESS! The number of attempts does NOT matter. Player can win by sheer tenacity.
							WordShow("SUCCESS!<BR>IT >WAS<<BR>IMPOSSIBLE!", "#FFFFFF", "#000000", 1.5, 4000);
							SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
							WorldEndStatUpdate(3);
							mUrineState = 0;
							mState = 2;
							WorldEndNew();
						}
						// </URINESTATE END SUCCESS2>
						else if (mUrineState == 2)
						// <URINESTATE END FAILURE2>
						{
							// Level COULD be beaten. Entering Hole A FAILURE. Let the player try the level normally.
							// hole usually sends to the next level, but this is URINE and the level was possible
							WordShow("FAIL!<BR>TOTALLY POSSIBLE!<BR>PROVE IT<BR>YOURSELF!", "#FFFFFF", "#000000", 1, 4000, 0.03);
							SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);

							if (mScoreUpdated == 0) { WorldEndStatUpdate(2); }					
							mPlayback.Reset();   // history from Urine is INVALID, don't want these kept around
							mUrineState = -1;   // a reminder this started as a urine level
							WorldLevelReset();
						}
						// </URINESTATE END FAILURE2>
					}
					else
					{
						if (mUrineState < 0)
						{
							WordShow("COWARD!", "#000000", "#FF0000", 1, 2000, 0.03);
							SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
						}
						else
						{
							if ((mRestart.penalty % 3) == 2) { TalkPlay3000(TalkType2.playerusedhole); }
							// 0,1,2 - first 3 attempts
							// 3 = hole appeared
							var innerHTML = "";
							if (mRestart.penalty > 2)
							{
								// 2000 + mRestart.penalty * 3000		
								innerHTML = 2 + (mRestart.penalty * 3) + "<BR>SECONDS";
							}
							else if (mWorldRepeatCount < 5)
							{
								innerHTML = "A<BR>NEW<BR>DAY";
							}
							else if (mWorldRepeatCount < 7)
							{
								innerHTML = "THERE IS<BR>NO SHAME.";
							}
							else if (mWorldRepeatCount < 9)
							{
								innerHTML = "THAT WAS<BR>SOMETHING.";
							}
							else if (mWorldRepeatCount < 11)
							{
								innerHTML = "I FORGIVE<BR>YOU.";
							}
							else
							{
								innerHTML = "THANK<BR>GOD.";
							}
							WordShow(innerHTML, undefined, undefined, 1, 2000 + 1500);
							SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundpop);
						}
						WorldEndHole();
					}
				}
				// </HOLE>

				// <URINESTATE END SUCCESS1>
				else if ( (mUrineState != 0) && (mTileTotal <= 1) )
				{
					// with Urine, it's POSSIBLE to be in mState == 1 AND STILL get mTileTotal <= 1
					if (mUrineState > 0)
					{
						WordShow("YOU ARE<BR>CHLORINE", "#00FFFF", "#000000", 1, 4000, 0.03);
						SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
					}
					else if (mUrineState < 0)
					{
						// Fail already recorded.
						WordShow("THE REAL PROOF<BR>WAS THE FRIENDS<BR>WE MADE ALONG THE WAY", "#FFFFFF", "#0000FF", 1.5, 4000);
						SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
					}
					mUrineState = 0;
					mState = 2;   // eliminate random fail (orange, not to be trusted)
					WorldEndNew();
				}
				// </URINESTATE END SUCCESS1>
				
				// <STUCK>
				else if (
					// case: we're on a tile not attached to anything and it's NOT a final tile
					((mTileTotal > 1) && (EdgeCount(mPlayer.left, mPlayer.top) == 4))
					// case: we're on the final tile BUT it's an extra 
					|| ((mTileTotal <= 1) && mPlayFieldDivs[mPlayer.top * mTileXCount + mPlayer.left].extra == 1)
				)
				{
					// may or may not be in a fail state, player may have gotten stuck before SolveUpdate() could calculate fail
					WorldUpdateFailStuck(false);
				}
				// </STUCK>

				else if (mGrowDie)
				{
					// FAIL. Music stopped, player did NOT complete grow challenge
					WordShow("SWAN<BR>SONGED", "#FFFFFF", "#FF0000", 1, 2000, 0.03);
					SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);		
					mState = 1;
					WorldEndNew();
				}
									
				else if ( (mState != -1) || (mTalkRandomFailState > 0) )
				{
					// <SUCCESS1>
					if ((mTileTotal <= 1) && (mPlayFieldDivs[this.xyIndex].extra == 0))
					{
						console.assert(mUrineState != 1, "WorldUpdate() Error: User finished IMPOSSIBLE urine level (mUrineState == 1)!");
						// console.log("mPlayer.turns:" + mPlayer.turns + "    mSolvedPlayfieldTurn:" + mSolvedPlayfieldTurn[0]);
						// SoundBuffersStop();
						// console.log("SUCCESS: mTileTotal <= 1: S:" + mState + " US:" + mUrineState + " Re:" + mWorldRepeatCount);
				
						if (
							( (mTalkStates[TalkType.turns] == 1) && (mPlayer.turns > mSolvedPlayfieldTurn[0]) )
							|| ( (mTalkStates[TalkType.turns] == 2) && (mPlayer.turns < mSolvedPlayfieldTurn[1]) )
						)
						{
							WorldUpdateFailStuck(false);
							if (mTalkStates[TalkType.turns] == 2)
							{
								WordShow("\"" + mPlayer.turns + "\"<BR>NEED<BR>MORE<BR>TURNS!", "#FFFFFF", "#000000", 1, 2000, 0.05);
							}
							else
							{
								WordShow("\"" + mPlayer.turns + "\"<BR>TOO<BR>MANY<BR>TURNS!", "#FFFFFF", "#000000", 1, 2000, 0.05);
							}
							SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);		
						}

						else if (mTalkStates[TalkType.finishTile] == 1)
						{
							// One End Tile that MUST be finished last.
							WordShow("YOU DID IT LAST<BR>YOU DID IT LEAST", "#000000", "#FF0000", 1.5, 2000);
							SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
							backgroundR = 255; backgroundG = 0; backgroundB = 0;	
							document.body.style.backgroundColor = RGBToHex(backgroundR, backgroundG, backgroundB);
							mState = 2;
							WorldEndNew();
						}
				
						else if (mTalkStates[TalkType.finishTile] == 2)
						{
							// Multiple End Tiles, and you can still finish another way
							if (mPlayFieldDivs[mPlayer.xyIndex].finishTileState == 0)
							{
								WordShow("DOESN'T<BR>COUNT", "#000000", "#FF0000", 1.5, 2000);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
								backgroundR = 255; backgroundG = 0; backgroundB = 0;	
								document.body.style.backgroundColor = RGBToHex(backgroundR, backgroundG, backgroundB);
								mPlayback.Add(); // next time this will be "That's One"
								WorldLevelReset();
							}
							else if (mPlayFieldDivs[mPlayer.xyIndex].finishTileState == 2)
							{
								WordShow("ALREADY<BR>DONE", "#000000", "#FF0000", 1.5, 2000);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
								backgroundR = 255; backgroundG = 0; backgroundB = 0;	
								document.body.style.backgroundColor = RGBToHex(backgroundR, backgroundG, backgroundB);
								mPlayback.Add(); // next time this will be "That's One"
								WorldLevelReset();
							}
							else
							{
								console.assert(mPlayFieldDivs[mPlayer.xyIndex].finishTileState == 1, "WorldUpdate() Error: We've finished on a tile where finishTileState != 1 '" + mPlayFieldDivs[mPlayer.xyIndex].finishTileState + "'");
								mPlayFieldDivs[mPlayer.xyIndex].finishTileState = 2;
								var holdCount = 0;
								for (var xyIndex = 0; xyIndex < mTileXYCount; xyIndex++)
								{
									if (mPlayFieldDivs[xyIndex].finishTileState == 1) { holdCount++; }
								}

								if (holdCount > 0)
								{
									WordShow(holdCount + "<BR>MORE!", undefined, undefined, 1.5, 2000);
									SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
									backgroundR = 255; backgroundG = 255; backgroundB = 255;	
									document.body.style.backgroundColor = RGBToHex(backgroundR, backgroundG, backgroundB);
									mPlayback.Add();
									WorldLevelReset();
								}
								else
								{
									WordShow("AND THEN<BR>THERE WERE NONE", "#FFFFFF", "#0000FF", 1, 2000 + 1500, 0.015);
									// you caught them all, "YOU SHOWED<BR>THE WAY", "YOU PERSEVERED", "ALL ENDINGS<BR>BELONG TO YOU"
									SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
									mState = 2;
									WorldEndNew();
								}
							}
						}
						
						else if (mLevelType == LevelType.Boss)
						{
							console.assert(mUrineState == 0, "WorldUpdate() Error: Boss level BUT mUrineState != 0 '" + mUrineState + "'");
							if (mLevelStageCount == 2)
							{
								WordShow("BOS<BR>SED", "#FFFFFF", "#0000FF", 1.2, 2000 + 1500, 0.015);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundbossed);
								SoundBufferPlay(mSoundBufferMisc, 0.25, SoundBufferMiscType.soundapplausenormal);
								mState = 2;
								WorldEndNew();
							}

							else if (mLevelStageCount == 1)
							{
								mLevelStageCount = 2;
								WordShow("REPEAT<BR>THAT<BR>EXACTLY", undefined, undefined, 1.5, 2000);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
								backgroundR = 128; backgroundG = 255; backgroundB = 128;	
								document.body.style.backgroundColor = RGBToHex(backgroundR, backgroundG, backgroundB);
								mUseTheForceState = 3;
								mPlayback.Reset();
								WorldLevelReset();
							}
				
							else
							{	
								console.assert(mLevelStageCount == 0);
								mLevelStageCount = 1;
								WordShow("GO BACK", undefined, undefined, 1.5, 2000);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
								backgroundR = 128; backgroundG = 255; backgroundB = 128;	
								document.body.style.backgroundColor = RGBToHex(backgroundR, backgroundG, backgroundB);				

								console.assert(mTalkStates[TalkType.finishTile] == 0, "WorldUpdate() Error(): Boss: TalkType.finishTile conflicts with Boss level, must be 0.");
								mFinishxyIndex = mRememberPlayerXYIndex;
								console.assert(mPlayFieldDivs[mFinishxyIndex].finishTileState == 0, "WorldUpdate() Error(): Boss Success Go Back: finishTileState NOT 0. Can't go back.");
								mPlayFieldDivs[mFinishxyIndex].finishTileState = 1;

								mRememberPlayerXYIndex = mPlayer.xyIndex;
								mPlayback.Reset();
								WorldLevelReset();
							}
						}
						else
						{
							// <USETHEFORCE START>
							// UseTheForce happens in 3 instances:
							// 1. Player finished a regular or tricky level PERFECTLY (a TEST to keep the win)
							// 2. Player finished a regular or tricky level AFTER failing (Use The Force to ERASE the loss)
							// 3. Player finished a urine level they FAILED by going into a garbage can FIRST (then being told it could be solved) (Use the Force to ERASE the loss)
							// Note: If player successfully overcame Urine, do NOT force a repeat.
															
							if
							(
								(
									(mWorldMode > 0)
									&& (mUseTheForceState == 0)
									&&
									(
										( (mLevelIndex > 2) && (mLevelIndex < 8) )
										|| ( (mLevelIndex > 12) && (mLevelIndex < 18) )
									)
									&& (mTileTotalRemember < 150)
									&& (Math.random() < 0.05)   // 50% chance with 10 levels
								)
								||
								(
									(mWorldMode == 0)
									&&
									(
										(mUseTheForceState == 0)
										&& ( (mLevelType == LevelType.Regular) || (mLevelType == LevelType.Tricky) )
										&& (mStatNewFrankWin + mStatNewFrankLoss + 1 > 24)
										&& (mUseTheForceStateWait <= 0)
									)
									&&
									(
										((mUrineState == 0) && (mScoreUpdated == 0) && (Math.random() < 0.05))   // mean.
										|| ((mUrineState == 0) && (mScoreUpdated == 1) && (Math.random() < 0.1))   // nice.
										|| ((mUrineState == -1) && (Math.random() < 0.15))   // nice. took urine hole but it was good, just proved it to themselves
										|| ((mUrineState == 2) && (Math.random() < 0.05))   // mean. finished a "good" urine level
										// note: mUrineState == 1 do NOT repeat a "bad" urine level.
									)
								)
							)
							{
								mUseTheForceState = 1;
								if ( (mUrineState < 0) || (mWorldRepeatCount >= 3) ) { mUseTheForceState = 2; }
								mUseTheForceStateWait = 4;   // do NOT allow usetheforcestate to occur for another 3 levels

								if (mUseTheForceState == 1)
								{
									WordShow("CAN YOU<BR>DUPLICATE<BR>PAST SUCCESS?", "#0000FF", "#FFFFFF", 1.5, 2000);
									SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
								}
								else
								{
									WordShow("USE<BR>THE<BR>FORCE", undefined, undefined, 1.5, 2000);
									SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
									SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundusetheforce);
								}
								MusicSelect();
								
								mUrineState = 0;
								mTalkRandomFailState = 0;
								mWorldRepeatCount = 0;

								mPlayback.Reset();
								WorldLevelReset();   // fixes mState
							}
							// </USETHEFORCE START>
							
							// <USETHEFORCE END SUCCESS>
							else if (mUseTheForceState > 0)
							{
								console.assert(mState != 1, "WorldUpdate() Success1 Error: Successfully used force, BUT mState == 1");   // should be 0 (player moved) or 2 (solved)
								console.assert(mWorldRepeatCount == 0, "WorldUpdate() Success1 Error: Successfully used force, BUT mWorldRepeatCount != 0 '" + mWorldRepeatCount + "'");
								if (mUseTheForceState == 1)
								{
									WordShow("YOU DID IT<BR>... AGAIN", "#0000FF", "#FF00FF", 1, 8000, 0.001);
									SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
								}
								else
								{
									WordShow("THAT WASN'T THE LEVEL<BR>YOU WERE LOOKING FOR", "#FFFFFF", "#000000", 2, 8000);   // these aren't the droids you're looking for
									SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);					
								}
								if (mWorldMode > 0)
								{
									mStatNewFail = mStatNewFailRemember;    // Forgive all the fails this level! Redemption!
								}
								else
								{
									WorldEndStatUpdate(3);   // May have LOST (WorldRepeat >= 3), but now REDEEMED! (so reset)
								}
								mState = 2;
								WorldEndNew();
							}
							// </USETHEFORCE END SUCCESS>
												
							/*
							else if ( (mTalkStates[TalkType.finishTile] == 1) && (mPlayFieldDivs[mPlayer.xyIndex].finishTileState != 1) )
							{
								// This can no longer happen since player will run into the REAL end tile en route, but I'm keeping the code
								if (mWorldRepeatCount == 2) { WorldEndStatUpdate(2); }
								mPlayback.freezeTime = Date.now() + 500;
								mPlayback.Add();

								mWorldState = 2;   // mWorldRepeatCount++;
								mWorldState2Action = 3;
								mWorldStateAlive = Date.now() + 2000;				

								WordShow("BAD<BR>ENDING", undefined, undefined, 1, 2000, 0.01);
								SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
							}
							*/
							
							else
							{
								WorldMessageNew();
								mState = 2;
								WorldEndNew();
							}
						}
					}
					// </SUCCESS1>
				}		

			}
			// </MOVEDONCE>
		}		
	}
	
	this.Draw = function()
	{
		var ratio = 1.1;
		if ((gBrowser.touchState > 0) && (Date.now() > gBrowser.touchStartDate)) { ratio = 1.4; }

		this.blinkCounter--;
		if (this.blinkCounter < 0)
		{
			if (this.faceState != -1)
			{
				if (this.blinkState == 0)
				{
					var id = SoundBufferMiscType.soundblink0; if (Math.round() < 0.5) { id = SoundBufferMiscType.soundblink1; } 
					SoundBufferPlay(mSoundBufferMisc, 0.05, id);
					this.faces[this.faceState * 2 + 1].style.visibility = "";
					this.faces[this.faceState * 2].style.visibility = "hidden";
					this.blinkState = 1;
					this.blinkCounter = 8 + parseInt(Math.random() * 4);
				}
				else
				{
					this.faces[this.faceState * 2].style.visibility = "";
					this.faces[this.faceState * 2 + 1].style.visibility = "hidden";
					this.blinkState = 0;
					if (Math.random() < 0.1)
					{
						this.blinkCounter = 8 + parseInt(Math.random() * 4);
					}
					else
					{
						this.blinkCounter = 180 + parseInt(Math.random() * 40);
					}
				}
			}
		}

		if ( (mWorldState == 2) && (this.xyIndex == mRestart.xyIndexRemember) )
		{
			// Hole: Sink into hole
			this.transform.LerpChange(mRestart.newLeft, mRestart.newTop, 0.05, 1, 1, 0.05);
		}
		else if ((mWorldState == 0) || (mWorldState == 2))
		{
			// Expand towards camera
			if (this.transform.jimWidth != this.transform.jimHeight) { this.transform.jimWidth = this.transform.jimHeight; }
			
			var hold = 700; if (mLevelGenerate != null) { hold = 100; }
			if (this.transform.jimWidth < hold)
			{
				this.transform.LerpChange(
					this.transform.jimLeft, this.transform.jimTop, 1
					, this.transform.jimWidth + 4, this.transform.jimHeight + 4, 1
				);
			}

			this.transform.jimRotate += 1;	
			RotateDiv(this.div, this.transform.jimRotate);
		}
		/*
		DEAD
		else if (mWorldState == 0)
		{
			// Level is building, fly towards center
			var width = this.transform.jimWidth, height = this.transform.jimHeight;
			var hold = 700; if (mLevelGenerate != null) { hold = 100; }

			if (this.transform.jimWidth < hold) { width += (mTimeDelta / 60); height += (mTimeDelta / 60); }			
			this.transform.LerpChange(
				window.innerWidth * 0.5, window.innerHeight * 0.5, 0.005
				, width, height, 1
			);
			this.transform.jimRotate += 1;	
			RotateDiv(this.div, this.transform.jimRotate);
		}
		*/
		else
		{
			// Normal
			var tileSize = -1;
			if (mWorldShadowType == 1)
			{
				tileSize = mTileSize2 * 0.85;
			}
			else
			{
				tileSize = mTileSize2 * 0.5;
			}
			tileSize = mTileSize2 * 1.1; // 0.9;
			
			if (tileSize < 1) { tileSize = 1; }		

			// <DRAG PLAYER TOWARDS HOLE>
			if (this.restartPull != 0.0)
			{
				if ( Math.pow(Math.pow((mRestart.newLeft - this.transform.jimLeft), 2.0) + Math.pow((mRestart.newTop - this.transform.jimTop), 2.0) , 0.5) < mTileSize2 * 0.5 )
				{
					var restartY = parseInt(mRestart.xyIndexRemember / mTileXCount);
					var restartX = mRestart.xyIndexRemember - (restartY * mTileXCount);
					this.ChangePosition(restartX, restartY);
					this.transform.LerpChange(mPlayFieldDivs[this.xyIndex].newLeft, mPlayFieldDivs[this.xyIndex].newTop, 1);
				}
				else
				{
					var angleRadians = Math.atan2(mRestart.newTop - this.transform.jimTop, mRestart.newLeft - this.transform.jimLeft);
					this.transform.LerpChange(
						this.transform.jimLeft + Math.cos(angleRadians) * this.restartPull
						, this.transform.jimTop + Math.sin(angleRadians) * this.restartPull
						, 1.0
						, tileSize * ratio, tileSize * ratio, 0.15
					);
					this.restartPull *= 1.005;   // 1.01 too fast
				}
			}
			// </DRAG PLAYER TOWARDS HOLE>			
			else
			{
				this.transform.LerpChange(
					mPlayFieldDivs[this.xyIndex].newLeft, mPlayFieldDivs[this.xyIndex].newTop, 0.05
					, tileSize * ratio, tileSize * ratio, 0.15
				);
			
				if (
					(mRestart.xyIndex != -1)
					&& (mWorldState == 1)
					&& (this.freezeTime == 0)
					&& (mTileTotal != mTileTotalRemember) 
					&& (Math.abs(this.transform.jimWidth - tileSize) < 1)
					&& (Math.abs(this.transform.jimHeight - tileSize) < 1)
				)
				{
					var hold = ((mWorldRepeatCount - 4) * 0.1); if (hold < 0.01) { hold = 0.01; }
					if (mUseTheForceState == 3) { hold = 0.05; }
					this.restartPull = hold;
				}
			}
			
			if (this.rotateS != 0)
			{
				this.transform.jimRotate += this.rotateS;
				RotateDiv(this.div, this.transform.jimRotate);
				this.rotateS *= 0.95;
				if (Math.abs(this.rotateS) < 0.1) { this.rotateS = 0; }
			}
		}

		if (mWorldFreezeTime > 0)
		{
			this.div.style.left = parseInt(this.transform.jimLeft - this.transform.jimWidth * 0.5) + ((-1 + parseInt(Math.random() * 2.0) * 2) * 5);
			this.div.style.top = parseInt(this.transform.jimTop - this.transform.jimHeight * 0.5) + ((-1 + parseInt(Math.random() * 2.0) * 2) * 5);
		}
	}
}
// </PLAYER>


// -----------------------------------------------------------------------------------------------------------------------
// <BROWSER>
// -----------------------------------------------------------------------------------------------------------------------
// USED TO BE GENERIC, now everything's specific to "You Can Always Go Back"
// Thought: Hold RIGHT mouse button to prevent movement twice in same direction. keyMouseR remembers the direction

function Browser()
{
	this.inputType = -1;   // 0:Keyboard 1:Mouse 2:Touch   (Keyboard + Mouse supported, Mouse + Touch NOT supported - must be either or due to mobile problems)
	this.inputTypeEventHTML = "";   // either "OnMouseUp" or "OnTouchEnd", an HTML element (DIV) must NEVER have both - one or the other 
	
	this.keys = new Array(20);
	this.keysTime = new Array(20);
	this.keysShift = new Array(20);
	
	this.keyPopIndex = 0;
	this.keyPushIndex = 0;

	this.mouseState = 0;   // 0:No Mouse Events   1:MouseDown   2:Moved One 
	this.mouseLDown = false;
	this.mouseRDown = false;
	this.mouseStartX = 0;
	this.mouseStartY = 0;
	this.mouseNewX = 0;
	this.mouseNewY = 0;
	this.mouseMovedDate = 0;   // After player moves, there's a delay before moving again
	this.mouseRememberKey = 0;
	
	this.touchState = 0;   // 0=not touching   1=touch started   2=DEAD (1 square movement hold)   3=instant movement
	this.touchStartX = 0;   // compare end to start to determine regular movement
	this.touchStartY = 0;
	this.touchCurrentX = 0;
	this.touchCurrentY = 0;
	this.touchStartDate = 0;

	// --------------------------------------------------------------------------------------------------------------------------------------
	// KEYBOARD
	// --------------------------------------------------------------------------------------------------------------------------------------
	this.KeyReset = function()
	{
		// should be changed to ALLReset()
		this.MouseReset();
		this.TouchReset();
		this.keyPopIndex = this.keyPushIndex;
	}
	
	this.KeyPop = function()
	{
		// if (Math.abs(this.keyPopIndex - this.keyPushIndex) > 5) { console.log("KEY HOW ! " + Math.abs(this.keyPopIndex - this.keyPushIndex)); }
	
		if (this.keyPopIndex != this.keyPushIndex)
		{
			this.keyPopIndex = (this.keyPopIndex + 1) % this.keys.length;
			
			var key = this.keys[this.keyPopIndex];
			if (mWorldFlipped)
			{
				if ((key == 37) || (key == 65)) { key = 38; }
				else if ((key == 39) || (key == 68)) { key = 40; }
				else if ((key == 38) || (key == 87)) { key = 37; }
				else if ((key == 40) || (key == 83)) { key = 39; }
			}
			return { key:key, time:this.keysTime[this.keyPopIndex], shift:this.keysShift[this.keyPopIndex] };
		}
		else
		{
			return { key:0, time:0, shift:0 };
		}
	}
	
	this.KeyPush = function(pKeyCode, pShift = 0)
	{
		if (mWorldState != 1)
		{
			this.keyPopIndex = this.keyPushIndex;
		}
		else
		{
			this.keyPushIndex = (this.keyPushIndex + 1) % this.keys.length;
			this.keys[this.keyPushIndex] = pKeyCode;
			this.keysTime[this.keyPushIndex] = Date.now();
			this.keysShift[this.keyPushIndex] = pShift;
		}
	}
	
	this.KeyPushAngle = function(pDeltaX, pDeltaY, pShift = 0)
	{	
		var angleRadians = Math.atan2(pDeltaY, pDeltaX);
		
		if ((angleRadians >= -Math.PI * 0.25) && (angleRadians < Math.PI * 0.25))
		{
			this.KeyPush(39, pShift);   // right
		}
		else if ((angleRadians >= -Math.PI * 0.75) && (angleRadians < -Math.PI * 0.25))
		{
			this.KeyPush(38, pShift);   // up
		}
		else if ((angleRadians >= Math.PI * 0.25) && (angleRadians < Math.PI * 0.75))
		{
			this.KeyPush(40, pShift);   // down
		}
		else
		{
			this.KeyPush(37, pShift) // left
		}		
	}

	this.OnKeyDown = function(pEvent)
	{
		// https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event
		if (this.inputType != 0)
		{
			this.inputTypeEventHTML = "OnMouseUp";
			this.inputType = 0;
		}
		
		if (mWorldState == 1)
		{
			var keyCode = pEvent.keyCode;
			
			if (keyCode == 65) { keyCode = 37; } else if (keyCode == 68) { keyCode = 39; } else if (keyCode == 87) { keyCode = 38; } else if (keyCode == 83) { keyCode = 40; }

			if (
				(keyCode == 37)   // left arrow
				|| (keyCode == 39)   // right arrow
				|| (keyCode == 38)   // up arrow
				|| (keyCode == 40)   // down arrow
				|| (keyCode == 32)
			)
			{
				var shift = 0;
				if (keyCode == 32)
				{
					if (pEvent.shiftKey) { shift = 2; } else { shift = 0; }
				}
				else
				{
					if (pEvent.shiftKey) { shift = 1; }		
				}
				this.KeyPush(keyCode, shift);
				if (mWorldState != 2) { mPlayer.Update(); }
				mPlayer.Draw();			
			}		
		}

		if (pEvent) { pEvent.preventDefault(); pEvent.stopPropagation(); }
		return false;
	}

	this.OnKeyUp = function(pEvent)
	{
		if (pEvent.keyCode == 27)
		{
			if (mButtonCloseDiv.style.display == "") { MenuMain(null, mWorldState); }
		}
	
		else if (mWorldClick != null)
		{
			let hold = mWorldClick;
			mWorldClick = null;
			hold();
		}

		else if (mWorldState > 0)
		{	
			if (pEvent.keyCode == 70)
			{ 
				WordShow("DEBUG<BR>SUCCESS!", "#FFFFFF", "#0000FF", 1.2, 2000 + 1500, 0.015);
				SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
				mState = 2;
				WorldEndNew();
				mWorldStateAlive = Date.now() + 100;
			}
		}		

		if (pEvent) { pEvent.preventDefault(); pEvent.stopPropagation(); }
		return false;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------
	// MOUSE
	// --------------------------------------------------------------------------------------------------------------------------------------
	/*
	1. left hold + movement - one square   (same if you swipe left and let go quickly)
	2. right hold + movement - instant move   (same if you swipe right and let go quickly)
	3. left click - one square cornering
	4. right click - instant move cornering

	2024-09-09 Moving mouse quickly does NOT result in INSTANT movement
	Intuitively players want this, BUT it's impossible to get it working reliably
	To easy to unintentionally trigger (same problem with touch). Lord knows I tried MANY things including analyzing a history of mouse positions
	As such, Instant movement MUST be tied to a mouse click
	
	New Idea 1: Mouse locked: holding left means you'll never move 2 squares in the same Direction
	Fix: Mouse Unlocked: Moving and Right-Click, instant move BUT you're kicked out of drag mode 
	*/
	
	this.MouseReset = function ()
	{
		this.mouseState = 0;
		// this.mouseLDown = false;
		// this.mouseRDown = false;
		this.mouseStartX = 0; this.mouseStartY = 0;
		this.mouseNewX = 0; this.mouseNewY = 0;
		this.mouseMovedDate = 0;
		
		this.mouseRememberKey = 0;
	}

	this.GetMousePosition = function(e)
	{
		if( !e ) {
			if( window.event ) {
				//DOM
				e = window.event;
			} else {
				//TOTAL FAILURE, WE HAVE NO WAY OF REFERENCING THE EVENT
				window.status = "Error: Can't capture mouse!";
				return;
			}
		}

		if( typeof( e.pageX ) == 'number' ) {
			//NS 4, NS 6+, Mozilla 0.9+
			var xcoord = e.pageX;
			var ycoord = e.pageY;
		} else {
			if( typeof( e.clientX ) == 'number' ) {
				//IE, Opera, NS 6+, Mozilla 0.9+
				//except that NS 6+ and Mozilla 0.9+ did pageX ...
				var xcoord = e.clientX;
				var ycoord = e.clientY;
				if( !( ( window.navigator.userAgent.indexOf( 'Opera' ) + 1 ) ||
				( window.ScriptEngine && ScriptEngine().indexOf( 'InScript' ) + 1 ) ||
				window.navigator.vendor == 'KDE' ) ) {
					if( document.body && ( document.body.scrollLeft || document.body.scrollTop ) ) {
						//IE 4, 5 & 6 (in non-standards compliant mode)
						xcoord += document.body.scrollLeft;
						ycoord += document.body.scrollTop;
					} else if( document.documentElement &&
					( document.documentElement.scrollLeft || document.documentElement.scrollTop ) ) {
						//IE 6 (in standards compliant mode)
						xcoord += document.documentElement.scrollLeft;
						ycoord += document.documentElement.scrollTop;
					}
				}
			} else {
				//TOTAL FAILURE, WE HAVE NO WAY OF OBTAINING THE
				//MOUSE COORDINATES
				xcoord = -100000; ycoord = -100000;
			}
		}
		
		return [parseInt(xcoord), parseInt(ycoord)];
	}

	this.OnMouseDown = function(pEvent)
	{
		if (this.inputType != 1)
		{
			this.inputTypeEventHTML = "OnMouseUp";
			this.inputType = 1;
		}

		let hold = this.GetMousePosition(pEvent);
		if (
			(mButtonCloseDiv.style.display == "")
			&& (hold[0] < parseInt(mButtonCloseDiv.style.width))
			&& (hold[1] < parseInt(mButtonCloseDiv.style.height))
		)			
		{
			// handled by OnMouseUp
		}
		else
		{
			// <BUTTONSTATE>
			if (pEvent.button == 0) { this.mouseLDown = true; }
			if (pEvent.button == 2) { this.mouseRDown = true; }
			// </BUTTONSTATE>

			if ( (mWorldFreezeTime == 0) && (mWorldState == 1) && (mWorldClick == null) )
			{
				this.MouseReset();
				this.mouseState = 1;
				this.mouseStartX = hold[0]; this.mouseStartY = hold[1];

			}
		}

		if (pEvent) { pEvent.preventDefault(); pEvent.stopPropagation(); }
		return false;
	}
	
	this.MouseProcess = function()
	{		
		// Direction is passed via this.mouseNewX and this.mouseNewY
		const ratio = Math.pow(2, (5 - mSensitivity.exponent)) * 0.2;
		const limit = 30 * ratio;
		
		// <STRAIGHTEN>
		// Ensure diagnol movement resolves to the best 90 degree
		if (
			(Math.abs(this.mouseNewX) >= limit)
			|| (Math.abs(this.mouseNewY) >= limit)
		)
		{
			if ((Math.abs(this.mouseNewX)) > (Math.abs(this.mouseNewY))) { this.mouseNewY = 0; } else { this.mouseNewX = 0; }
		}
		// </STRAIGHTEN>
		
		// <MOVE>	
		let key = -1;
		if (this.mouseNewX >= limit)
		{
			key = 39;   // right
		}
		else if (this.mouseNewX <= -limit)
		{
			key = 37;    // left
		}

		if (this.mouseNewY >= limit)
		{
			key = 40;   // down
		}
		else if (this.mouseNewY <= -limit)
		{
			key = 38;   // up
		}

		if (key != -1)
		{
			if (key != this.mouseRememberKey)
			{
				let shift = (this.mouseRDown) ? 1 : 0;
				this.KeyPush(key, shift);
				if (shift == 0) { this.mouseMovedDate = Date.now() + 120; }   // keep clearing mouseNewX/Y for 50/1000 of a second - prevents moving twice which is deadly
			}
			
			// clear any extra movement, NEVER want anything carried over. want nice solid snap-to-grid (invaluable feedback)
			this.mouseNewX = 0; this.mouseNewY = 0;
			this.mouseState = 2;
			mPlayer.Update();
			mPlayer.Draw();
			// this.mouseRememberKey = key;
		}
		// </MOVE>
	}

	this.OnMouseMove = function(pEvent)
	{	
		let hold = this.GetMousePosition(pEvent);
		if (
			(mButtonCloseDiv.style.display == "")
			&& (hold[0] < parseInt(mButtonCloseDiv.style.width))
			&& (hold[1] < parseInt(mButtonCloseDiv.style.height))
		)			
		{
			// handled by OnMouseUp
		}
		else
		{
			if (
				((this.mouseState > 0) || (requestPointerLock == 1))
				&& (mWorldFreezeTime == 0) && (mWorldState == 1) && (mWorldClick == null)
				&& (Date.now() > this.mouseMovedDate)
			)
			{
				// mouse is NOT touch. moving up then left down left requires dexterity beyond belief, and causes "jumps". dampen those jumps
				this.mouseNewX += JimPow(pEvent.movementX, 0.5); this.mouseNewY += JimPow(pEvent.movementY, 0.5);		
				this.MouseProcess();
			}
		}

		if (pEvent) { pEvent.preventDefault(); pEvent.stopPropagation(); }
		return false;
	}

	// 2024-09-09 You can get OnMouseUp WITHOUT an OnMouseMove - can't use .mouseNewX
	this.OnMouseUp = function(pEvent)
	{	
		let menuMainCalled = false;
		if (mButtonCloseDiv != null)
		{
			if (
				(mButtonCloseDiv.style.display == "")
				&& (pEvent.clientX < parseInt(mButtonCloseDiv.style.width))
				&& (pEvent.clientY < parseInt(mButtonCloseDiv.style.height))
			)			
			{
				MenuMain(null, mWorldState);
				menuMainCalled = true;
			}
		}

		if (!menuMainCalled)
		{
			if (mWorldClick != null)
			{
				let hold = mWorldClick;
				mWorldClick = null;
				hold();
			}

			else if ( (this.mouseState > 0) && (mWorldState == 1) ) 
			{	
				let hold = this.GetMousePosition(pEvent);	
				let mouseX = hold[0], mouseY = hold[1];
				
				let mouseCaptured = false;
				
				// <MOUSE CONFIG>
				if (requestPointerLock == 0)
				{
					var w = parseInt(window.innerWidth), h = parseInt(window.innerHeight);
					if ((mouseX < w * 0.075) && (mouseY < h * 0.075))
					{
						if (mSensitivity.style.display == "")
						{
							mSensitivity.exponent -= 0.5; if (mSensitivity.exponent <= 0) { mSensitivity.exponent = 0; } 
						}
						setCookie("SensitivityExponent", mSensitivity.exponent, 365 * 20);
						SensitivityShow();
						mouseCaptured = true;
					}
					else if ((mouseX > w * (1.0 - 0.075)) && (mouseY < h * 0.075))
					{
						if (mSensitivity.style.display == "")
						{
							mSensitivity.exponent += 0.5; if (mSensitivity.exponent >= 5) { mSensitivity.exponent = 5; }
						}
						setCookie("SensitivityExponent", mSensitivity.exponent, 365 * 20);
						SensitivityShow();	
						mouseCaptured = true;
					}
					/*
					else if ((mouseY < h * 0.075) && (mouseX > w * 0.25) && (mouseX < w * 0.75))
					{
						document.body.requestPointerLock( {unadjustedMovement: true} );
						mouseCaptured = true;
					}
					*/
				}
				// <MOUSE CONFIG>

				if ( (mWorldFreezeTime == 0) && (!mouseCaptured) && (this.mouseState == 1) )
				{
					// replace the compounded values from OnMouseMove because reduction not wanted
					this.mouseNewX = mouseX - this.mouseStartX;
					this.mouseNewY = mouseY - this.mouseStartY;
					
					if ( (Math.abs(this.mouseNewX) <= 4) && (Math.abs(this.mouseNewY) <= 4) )
					{
						// it was a "click" and NOT a gesture
						let shift = (this.mouseRDown) ? 1 : 0;
						this.KeyPush(32, shift);
						this.mouseNewX = 0; this.mouseNewY = 0;
						this.mouseState = 2;
						mPlayer.Update();
						mPlayer.Draw();
					}
					else
					{
						// no difference between onmousemove and onmouseup because player intent would be the same
						this.MouseProcess();
					}
				}
			}
			
			// <BUTTONSTATE>
			if (pEvent.button == 0) { this.mouseLDown = false; }
			if (pEvent.button == 2) { this.mouseRDown = false; }
			// </BUTTONSTATE>		
			
			if ((!this.mouseLDown) && (!this.mouseRDown)) { this.mouseState = 0; }
		}
		
		if (pEvent) { pEvent.preventDefault(); pEvent.stopPropagation(); }
		return false;	
	}

	// --------------------------------------------------------------------------------------------------------------------------------------
	// TOUCH
	// --------------------------------------------------------------------------------------------------------------------------------------
	// https://developer.mozilla.org/en-US/docs/Web/API/Touch
	this.TouchReset = function()
	{
		this.touchState = 0;   // 0=not touching   1=touch started   2=DEAD (1 square movement hold)   3=instant movement
		this.touchStartX = 0;   // compare end to start to determine regular movement
		this.touchStartY = 0;
		this.touchCurrentX = 0;
		this.touchCurrentY = 0;
		this.touchStartDate = 0;
	}

	this.OnTouchStart = function(pEvent)
	{
		// Investigate: 2024-09-12 on iPhone Safari I can get an OnTouchStart TWICE before OnTouchEnd 
		// if (this.touchState != 0) { alert("OnTouchStart Error() : touchState != 0 '" + this.touchState + "'"); }
		
		if (this.inputType != 2)
		{
			document.removeEventListener('mousedown', Browser_OnMouseDown);
			document.removeEventListener('mousemove', Browser_OnMouseMove);
			document.removeEventListener('mouseup', Browser_OnMouseUp);

			this.inputTypeEventHTML = "OnTouchEnd";
			this.inputType = 2;
		}
		
		if (
			(mButtonCloseDiv.style.display == "")
			&& (parseInt(pEvent.touches[0].pageX) < parseInt(mButtonCloseDiv.style.width) * 1.2)
			&& (parseInt(pEvent.touches[0].pageY) < parseInt(mButtonCloseDiv.style.height) * 1.2)
		)
		{
			// handled by OnTouchEnd
		}
		else
		{
			if ((mWorldFreezeTime == 0) && (mWorldState == 1) && (mWorldClick == null))
			{
				this.TouchReset();
			
				this.touchState = 1;
				this.touchStartX = parseInt(pEvent.touches[0].pageX);
				this.touchStartY = parseInt(pEvent.touches[0].pageY);	
				this.touchStartDate = Date.now() + 450;   // after 1/2 second of holding switch to instant mode
				this.touchCurrentX = this.touchStartX;
				this.touchCurrentY = this.touchStartY;
			}
		}
		
		// TouchMove and TouchEnd STILL happen - BUT Mouse events do NOT.
		if (pEvent) { pEvent.preventDefault(); pEvent.stopPropagation(); }
		return false;	
	}

	this.TouchProcessUpdate = function()
	{
		if (this.touchState == 1) 
		{
			// Touch Special Case: User holds for 750ms
			if (Date.now() - this.touchStartDate > 450 * 2)
			{
				// we have not moved for a very long time (almost 1 second)
				this.KeyPush(32, 2);   // Attempt to finish the level (Shift + SpaceBar)
				this.touchState = 0;
				mPlayer.Update();
				mPlayer.Draw();
				// 2024-09-05 DEBUG
				// WordShow("DEBUG<BR>SUCCESS!", "#FFFFFF", "#0000FF", 1.2, 2000 + 1500, 0.015);
				// SoundBufferPlay(mSoundBufferMisc, 1, SoundBufferMiscType.soundthud);
				// mState = 2;
				// WorldEndNew();
				// mWorldStateAlive = Date.now() + 100;
			}
			
			// Touch Special Case: User swiped and held BEFORE instant mode clicked in, followup when instant mode clicks in
			else if (Date.now() > this.touchStartDate)
			{
				this.TouchProcess(25, 1);
			}
		}
	}
	
	this.TouchProcess = function(pLimit = -1, pShift = -1)
	{
		// Depends on this.touchCurrentX/Y and this.touchStartX/Y
		if (pLimit == -1) { alert("TouchProcess() Error: pLimit == -1"); }
		if (pShift == -1) { alert("TouchProcess() Error: pShift == -1"); }
		if (this.touchState == 0) { alert("TouchProcess() Error: this.touchState == 0"); }
	 	if (mWorldState != 1) { alert("TouchProcess() Error: mWorldState != 1 '" + mWorldState + "'"); }

		// convert the touch angle to a keystroke
		let deltaX = this.touchCurrentX - this.touchStartX;
		let deltaY = this.touchCurrentY - this.touchStartY;

		if ((Math.abs(deltaX) >= pLimit) || (Math.abs(deltaY) >= pLimit))
		{
			if ((Math.abs(deltaX)) > (Math.abs(deltaY))) { deltaY = 0; } else { deltaX = 0; }

			this.KeyPushAngle(deltaX, deltaY, pShift);
			this.touchStartX = this.touchCurrentX;   // cut off any extra, don't want it influencing next instant move
			this.touchStartY = this.touchCurrentY;
			this.touchState = 2;   // we've moved
			mPlayer.Update();
			mPlayer.Draw();   // Draw can be called twice in the same frame, not going to fix.
		}
	}

	this.OnTouchMove = function(pEvent)
	{	
		if (
			(mButtonCloseDiv.style.display == "")
			&& (parseInt(pEvent.touches[0].pageX) < parseInt(mButtonCloseDiv.style.width) * 1.2)
			&& (parseInt(pEvent.touches[0].pageY) < parseInt(mButtonCloseDiv.style.height) * 1.2)
		)
		{
			// handled by OnTouchEnd
		}
		else
		{
			if ( (this.touchState > 0) && (mWorldFreezeTime == 0) && (mWorldState == 1) && (mWorldClick == null) )
			{	
				// remember the movement in case user holds touching but stops moving
				// WorldUpdate will start polling Browser_ontouchmove using this memory)
				this.touchCurrentX = parseInt(pEvent.touches[0].pageX);
				this.touchCurrentY = parseInt(pEvent.touches[0].pageY);		
				// instant movement requires more emphasis (25 as opposed to 15) (not too much, not enough screen)
				// limit may need to be increased on newer phones with higher pixel resolutions (unsure)
				if (Date.now() > this.touchStartDate) { this.TouchProcess(25, 1); }
			}
		}

		if (pEvent) { pEvent.preventDefault(); pEvent.stopPropagation(); }
		return false;
	}

	this.OnTouchEnd = function(pEvent)
	{	
		// let clientRect = mButtonCloseDiv.getBoundingClientRect();
		if (
			(mButtonCloseDiv.style.display == "")
			&& (pEvent.changedTouches[0].pageX < parseInt(mButtonCloseDiv.style.width) * 1.2)
			&& (pEvent.changedTouches[0].pageY < parseInt(mButtonCloseDiv.style.height) * 1.2)
		)
		{
			MenuMain(null, mWorldState);
		}

		else if (mWorldClick != null)
		{
			let hold = mWorldClick;
			mWorldClick = null;
			hold();
		}

		else if ( (this.touchState > 0) && (mWorldFreezeTime == 0) && (mWorldState == 1) )
		{
			/*
			Test using:
			1. Large snake playfield - running at LOW fps while calculating answer
			2. Large snake playfield - AFTER death, Normal/FAST 60fps 
			3. Remove Tap - ensure all player input is "noticed"
			4. Slow iPad - has DIFFERENT resolution (touchx, touchy) (which is why instant is determined by time)
			*/

			if (this.touchState == 1)   // player has NOT held-to-move so move 1 square
			{
				// Remember: Browser_ontouchmove may not have beeen called
				this.touchCurrentX = parseInt(pEvent.changedTouches[0].pageX);
				this.touchCurrentY = parseInt(pEvent.changedTouches[0].pageY);

				// Tap
				if ( (Math.abs(this.touchStartX - this.touchCurrentX) < 15) && (Math.abs(this.touchStartY - this.touchCurrentY) < 15) )
				{
					this.KeyPush(32, 0);
				}
				// Swipe
				else
				{
					this.TouchProcess(0, 0);
				}
				mPlayer.Update();
				mPlayer.Draw();
			}
		}

		this.touchState = 0;
	
		if (pEvent) { pEvent.preventDefault(); pEvent.stopPropagation(); }	
		return false;
	}

}

// Instantiate the Browser object (badly encapsulates everything)
var gBrowser = new Browser();
function Browser_OnMouseDown(pEvent) { gBrowser.OnMouseDown(pEvent); }
function Browser_OnMouseUp(pEvent) { gBrowser.OnMouseUp(pEvent); }
function Browser_OnMouseMove(pEvent) { gBrowser.OnMouseMove(pEvent); }
</SCRIPT>


</HEAD>

<BODY oncontextmenu="return false;">

<canvas id="CanvasMain" Width=50 Height=50 Style='position:absolute; left:0px; top:0px; z-index:3;'></canvas>

<DIV ID="WorldContainer">
	<DIV Id="TextSize" Style="position:absolute; visibility:hidden; height:auto; width:auto; white-space:nowrap; text-align:center;">&nbsp;</DIV>
	<DIV Id="mouse" Style="position:absolute; white-space:nowrap; z-index:40; font-size:80px; left:0px; top:0px; width:10px; height:10px; overflow:visible;"></DIV>

	<DIV ID='player' Style='position:absolute; left:0px; top:0px; width:50px; height:50px; z-index:4;'>
		<IMG ID='face00' Src='myface-01-normal.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>
		<IMG ID='face01' Src='myface-01-normal-blink.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>
		<IMG ID='face10' Src='myface-02-fail.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>
		<IMG ID='face11' Src='myface-02-fail-blink.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>
		<IMG ID='face20' Src='myface-03-afterfail.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>
		<IMG ID='face21' Src='myface-03-afterfail-blink.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>
		<IMG ID='face30' Src='myface-04-success.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>
		<IMG ID='face31' Src='myface-04-success-blink.png' Style='position:absolute; left:0px; top:0px; width:100%; height:100%; visibility:hidden;'>
	</DIV>	
</DIV>

<DIV ID="StatTopLeftDiv" Style='position:absolute; padding:calc(100vh * 0.05) 0px 0px calc(100vw * 0.05); margin:0px; left:0px; top:0px; z-index:2;'></DIV>
<DIV ID="StatTopRightDiv" Style='position:absolute; padding:calc(100vh * 0.05) calc(100vw * 0.05) 0px 0px; margin:0px; right:0px; top:0px; z-index:2;'></DIV>
<DIV ID="StatBottomLeftDiv" Style='position:absolute; padding:0px 0px calc(100vh * 0.05) calc(100vw * 0.05); margin:0px; left:0px; bottom:0px; z-index:2;'></DIV>
<DIV ID="StatBottomRightDiv" Style='position:absolute; padding:0px calc(100vw * 0.05) calc(100vh * 0.05) 0px; margin:0px; right:0px; bottom:0px; z-index:2;'></DIV>

<DIV ID="ButtonClose" Class="ButtonClose" Style="position:absolute; padding:0px; margin:0px; left:0px; top:0px; display:none; opacity:1.0; cursor:pointer; width:50px; height:50px; background:#ff0000; background-color:#ccccff; box-sizing:border-box; border:4px solid #666666;">

<div id="JimInput" style="display:none;"><SPAN Style="font-family: monospace, monospace; color:#000000FF; background-color:#FF000000FF;">.JKK.<BR>.<B>XXX</B>.<BR>.....</SPAN></DIV>

<!--
<input id="JimInput" type="text" Value="<B>rockbottom</B>" />
-->

<!--
<DIV ID="ButtonClose" Class="ButtonClose" Style="position:absolute; padding:0px; margin:0px; left:10px; top:10px; display:none; opacity:0.5; cursor:pointer; width:53px; height:53px; background:#ff0000; background-color:#ccccff; box-sizing:border-box; border:4px solid #666666;">
	<DIV Style="position:absolute; padding:0px; margin:0px; left:2px; top:-4px; font-size:42px; line-height:100%; color:#000000;">&#9776;</DIV>
	<DIV Style="position:absolute; padding:0px; margin:0px; left:5px; top:-2px; font-size:42px; line-height:100%; color:#ffffff;">&#9776;</DIV>
</DIV>
-->

<!--
Thought this would help cache the songs but NOPE! Appears to hurt mobile Safari (interferes with javascript Audio object?).
<AUDIO ID="musicsong0endless" Src="music-song0-endless.mp3"></AUDIO>
<AUDIO ID="musicsong1choplifter" Src="music-song1-choplifter.mp3"></AUDIO>
<AUDIO ID="musicsong2nonsense" Src="music-song2-nonsense.mp3"></AUDIO>
<AUDIO ID="musicsong3547545scotland" Src="music-song3-547545-scotland.mp3"></AUDIO>
<AUDIO ID="musicsong4construction" Src="music-song4-construction.mp3"></AUDIO>
<AUDIO ID="musicsong5concordia" Src="music-song5-concordia.mp3"></AUDIO>
<AUDIO ID="musicsong6345948newyork" Src="music-song6-345948-new-york.mp3"></AUDIO>
<AUDIO ID="musicsong7246198usetheforce" Src="music-song7-246198-usetheforce.mp3"></AUDIO>
<AUDIO ID="musicsong8urineurout" Src="music-song8-urineurout.mp3"></AUDIO>
<AUDIO ID="musicsong9silver" Src="music-song9-silver.mp3"></AUDIO>
-->

</BODY>
</HTML>

